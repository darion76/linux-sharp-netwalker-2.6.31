diff -urNBb -x linux-2.6.31.9-ER1-efikamx/Documentation/dontdiff linux-2.6.31.9-ER1-efikamx.orig/arch/arm/mach-mx25/mx25_3stack.c linux-2.6.31.9-ER1-efikamx/arch/arm/mach-mx25/mx25_3stack.c
--- linux-2.6.31.9-ER1-efikamx.orig/arch/arm/mach-mx25/mx25_3stack.c	2009-12-12 13:16:54.000000000 -0600
+++ linux-2.6.31.9-ER1-efikamx/arch/arm/mach-mx25/mx25_3stack.c	2010-01-07 22:20:55.774484071 -0600
@@ -142,7 +142,7 @@
 	{
 	 .name = "nand.bootloader",
 	 .offset = 0,
-	 .size = 1024 * 1024},
+	 .size = 3 * 1024 * 1024},
 	{
 	 .name = "nand.kernel",
 	 .offset = MTDPART_OFS_APPEND,
diff -urNBb -x linux-2.6.31.9-ER1-efikamx/Documentation/dontdiff linux-2.6.31.9-ER1-efikamx.orig/arch/arm/mach-mx35/clock.c linux-2.6.31.9-ER1-efikamx/arch/arm/mach-mx35/clock.c
--- linux-2.6.31.9-ER1-efikamx.orig/arch/arm/mach-mx35/clock.c	2009-12-12 13:16:51.000000000 -0600
+++ linux-2.6.31.9-ER1-efikamx/arch/arm/mach-mx35/clock.c	2010-01-07 22:20:55.700266415 -0600
@@ -1891,7 +1891,9 @@
 		clk_register(*clkp);
 
 	/* Turn off all possible clocks */
-	__raw_writel(MXC_CCM_CGR0_ECT_MASK | MXC_CCM_CGR0_EMI_MASK,
+	__raw_writel(MXC_CCM_CGR0_ECT_MASK | MXC_CCM_CGR0_EMI_MASK |
+		     MXC_CCM_CGR0_ESDHC1_MASK | MXC_CCM_CGR0_ESDHC2_MASK |
+		     MXC_CCM_CGR0_ESDHC3_MASK,
 		     MXC_CCM_CGR0);
 	__raw_writel(MXC_CCM_CGR1_GPIO1_MASK | MXC_CCM_CGR1_GPIO2_MASK |
 		     MXC_CCM_CGR1_GPIO3_MASK | MXC_CCM_CGR1_GPT_MASK |
diff -urNBb -x linux-2.6.31.9-ER1-efikamx/Documentation/dontdiff linux-2.6.31.9-ER1-efikamx.orig/arch/arm/mach-mx35/mx35_3stack.c linux-2.6.31.9-ER1-efikamx/arch/arm/mach-mx35/mx35_3stack.c
--- linux-2.6.31.9-ER1-efikamx.orig/arch/arm/mach-mx35/mx35_3stack.c	2009-12-12 13:16:57.000000000 -0600
+++ linux-2.6.31.9-ER1-efikamx/arch/arm/mach-mx35/mx35_3stack.c	2010-01-07 22:20:55.797351858 -0600
@@ -152,7 +152,7 @@
 	{
 	 .name = "nand.bootloader",
 	 .offset = 0,
-	 .size = 1024 * 1024},
+	 .size = 3 * 1024 * 1024},
 	{
 	 .name = "nand.kernel",
 	 .offset = MTDPART_OFS_APPEND,
diff -urNBb -x linux-2.6.31.9-ER1-efikamx/Documentation/dontdiff linux-2.6.31.9-ER1-efikamx.orig/arch/arm/mach-mx37/mx37_3stack.c linux-2.6.31.9-ER1-efikamx/arch/arm/mach-mx37/mx37_3stack.c
--- linux-2.6.31.9-ER1-efikamx.orig/arch/arm/mach-mx37/mx37_3stack.c	2009-12-12 13:16:57.000000000 -0600
+++ linux-2.6.31.9-ER1-efikamx/arch/arm/mach-mx37/mx37_3stack.c	2010-01-07 22:20:55.532186860 -0600
@@ -398,8 +398,10 @@
 	 },
 };
 
+extern int g_di1_tvout;
 static void mxc_init_fb(void)
 {
+	g_di1_tvout = 1;
 	(void)platform_device_register(&mxc_fb_device[0]);
 	(void)platform_device_register(&mxc_fb_device[1]);
 	(void)platform_device_register(&mxc_fb_device[2]);
diff -urNBb -x linux-2.6.31.9-ER1-efikamx/Documentation/dontdiff linux-2.6.31.9-ER1-efikamx.orig/arch/arm/mach-mx51/clock.c linux-2.6.31.9-ER1-efikamx/arch/arm/mach-mx51/clock.c
--- linux-2.6.31.9-ER1-efikamx.orig/arch/arm/mach-mx51/clock.c	2009-12-16 17:16:07.000000000 -0600
+++ linux-2.6.31.9-ER1-efikamx/arch/arm/mach-mx51/clock.c	2010-01-07 22:20:55.139758262 -0600
@@ -320,8 +320,10 @@
 
 static int _clk_pll_set_rate(struct clk *clk, unsigned long rate)
 {
-	u32 reg;
+	u32 reg, reg1;
 	u32 pllbase;
+	struct timespec nstimeofday;
+	struct timespec curtime;
 
 	long mfi, pdf, mfn, mfd = 999999;
 	s64 temp64;
@@ -357,7 +359,26 @@
 		__raw_writel(mfd, pllbase + MXC_PLL_DP_HFS_MFD);
 		__raw_writel(mfn, pllbase + MXC_PLL_DP_HFS_MFN);
 	}
-
+	/* If auto restart is disabled, restart the PLL and
+	  * wait for it to lock.
+	  */
+	reg = __raw_readl(pllbase + MXC_PLL_DP_CTL);
+	if (reg & MXC_PLL_DP_CTL_UPEN) {
+		reg = __raw_readl(pllbase + MXC_PLL_DP_CONFIG);
+		if (!(reg & MXC_PLL_DP_CONFIG_AREN)) {
+			reg1 = __raw_readl(pllbase + MXC_PLL_DP_CTL);
+			reg1 |= MXC_PLL_DP_CTL_RST;
+			__raw_writel(reg1, pllbase + MXC_PLL_DP_CTL);
+		}
+		/* Wait for lock */
+		getnstimeofday(&nstimeofday);
+		while (!(__raw_readl(pllbase + MXC_PLL_DP_CTL)
+					& MXC_PLL_DP_CTL_LRF)) {
+			getnstimeofday(&curtime);
+			if (curtime.tv_nsec - nstimeofday.tv_nsec > SPIN_DELAY)
+				panic("pll_set_rate: pll relock failed\n");
+		}
+	}
 	clk->rate = rate;
 	return 0;
 }
@@ -1338,7 +1359,7 @@
 	.enable = _clk_ipu_enable,
 	.disable = _clk_ipu_disable,
 	.set_parent = _clk_ipu_set_parent,
-	 .flags = CPU_FREQ_TRIG_UPDATE | AHB_MED_SET_POINT,
+	 .flags = CPU_FREQ_TRIG_UPDATE | AHB_MED_SET_POINT | RATE_PROPAGATES,
 	},
 	{
 	 .name = "ipu_sec_clk",
@@ -1433,6 +1454,7 @@
 	.set_rate = _clk_ipu_di_set_rate,
 	.enable = _clk_enable,
 	.disable = _clk_disable,
+	.flags = RATE_PROPAGATES,
 	},
 	{
 	.name = "ipu_di1_clk",
@@ -1446,6 +1468,7 @@
 	.set_rate = _clk_ipu_di_set_rate,
 	.enable = _clk_enable,
 	.disable = _clk_disable,
+	.flags = RATE_PROPAGATES,
 	},
 };
 
diff -urNBb -x linux-2.6.31.9-ER1-efikamx/Documentation/dontdiff linux-2.6.31.9-ER1-efikamx.orig/arch/arm/mach-mx51/devices.c linux-2.6.31.9-ER1-efikamx/arch/arm/mach-mx51/devices.c
--- linux-2.6.31.9-ER1-efikamx.orig/arch/arm/mach-mx51/devices.c	2010-01-07 14:32:41.057917595 -0600
+++ linux-2.6.31.9-ER1-efikamx/arch/arm/mach-mx51/devices.c	2010-01-07 22:20:54.966968962 -0600
@@ -311,6 +311,7 @@
 	if (cpu_is_mx51_rev(CHIP_REV_2_0) > 0)
 		mxc_ipu_data.rev = 2;
 
+	mxc_ipu_data.di_clk[0] = clk_get(NULL, "ipu_di0_clk");
 	mxc_ipu_data.di_clk[1] = clk_get(NULL, "ipu_di1_clk");
 	/* Temporarily setup MIPI module to legacy mode */
 	clk = clk_get(NULL, "mipi_hsp_clk");
diff -urNBb -x linux-2.6.31.9-ER1-efikamx/Documentation/dontdiff linux-2.6.31.9-ER1-efikamx.orig/arch/arm/mach-mx51/mx51_3stack.c linux-2.6.31.9-ER1-efikamx/arch/arm/mach-mx51/mx51_3stack.c
--- linux-2.6.31.9-ER1-efikamx.orig/arch/arm/mach-mx51/mx51_3stack.c	2009-12-12 13:16:54.000000000 -0600
+++ linux-2.6.31.9-ER1-efikamx/arch/arm/mach-mx51/mx51_3stack.c	2010-01-07 22:20:55.542821578 -0600
@@ -418,9 +418,10 @@
 		},
 };
 
+extern int g_di1_tvout;
 static void mxc_init_fb(void)
 {
-
+	g_di1_tvout = 1;
 	if (cpu_is_mx51_rev(CHIP_REV_2_0) > 0)
 		lcd_data.reset = lcd_reset_to2;
 
diff -urNBb -x linux-2.6.31.9-ER1-efikamx/Documentation/dontdiff linux-2.6.31.9-ER1-efikamx.orig/arch/arm/mach-mx51/mx51_babbage.c linux-2.6.31.9-ER1-efikamx/arch/arm/mach-mx51/mx51_babbage.c
--- linux-2.6.31.9-ER1-efikamx.orig/arch/arm/mach-mx51/mx51_babbage.c	2009-12-12 13:16:58.000000000 -0600
+++ linux-2.6.31.9-ER1-efikamx/arch/arm/mach-mx51/mx51_babbage.c	2010-01-07 22:20:55.551669437 -0600
@@ -98,11 +98,12 @@
 static struct fb_videomode video_modes[] = {
 	{
 	 /* 720p60 TV output */
-	 "720P60", 60, 1280, 720, 7418,
-	 220, 110,
-	 20, 5,
-	 40, 5,
-	 FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT | FB_SYNC_EXT,
+	 "720P60", 60, 1280, 720, 13468,
+	 260, 109,
+	 25, 4,
+	 1, 1,
+	 FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT |
+			FB_SYNC_EXT,
 	 FB_VMODE_NONINTERLACED,
 	 0,},
 	{
@@ -338,6 +339,7 @@
 	return 0;
 }
 
+extern int g_di1_tvout;
 static int __init mxc_init_fb(void)
 {
 	int pixclk = 0;
@@ -350,12 +352,15 @@
 		fb_data[0].mode_str = NULL;
 		fb_data[1].mode_str = NULL;
 	}
+	g_di1_tvout = 1;
 
+	/* DI1: Dumb LCD */
 	if (enable_wvga) {
 		fb_data[1].interface_pix_fmt = IPU_PIX_FMT_RGB565;
 		fb_data[1].mode_str = "800x480M-16@55";
 	}
 
+	/* DI0: lVDS */
 	if (enable_mitsubishi_xga) {
 		fb_data[0].interface_pix_fmt = IPU_PIX_FMT_LVDS666;
 		fb_data[0].mode = &(video_modes[1]);
@@ -385,49 +390,73 @@
 	if (cpu_is_mx51_rev(CHIP_REV_1_1) == 2)
 		handle_edid(&pixclk);
 
-	if (enable_vga)
+	if (enable_vga) {
 		printk(KERN_INFO "VGA monitor is primary\n");
-	else if (enable_wvga)
+		g_di1_tvout = 0;
+	} else if (enable_wvga) {
 		printk(KERN_INFO "WVGA LCD panel is primary\n");
-	else if (!enable_tv)
+		g_di1_tvout = 0;
+	} else if (enable_tv == 2)
+		printk(KERN_INFO "HDTV is primary\n");
+	else
 		printk(KERN_INFO "DVI monitor is primary\n");
 
 	if (enable_tv) {
-		printk(KERN_INFO "TV is specified as %d\n", enable_tv);
-		if (!fb_data[0].mode) {
-			fb_data[0].mode = &(video_modes[0]);
-			if (!enable_wvga)
-				fb_data[1].mode_str = "800x600M-16@60";
-		}
-	}
-
-	if (enable_tv) {
-		struct clk *clk, *di_clk;
-		clk = clk_get(NULL, "pll3");
-		di_clk = clk_get(NULL, "ipu_di0_clk");
-		clk_disable(clk);
-		clk_disable(di_clk);
-		clk_set_rate(clk, 297000000);
-		clk_set_rate(di_clk, 297000000 / 4);
-		clk_enable(clk);
-		clk_enable(di_clk);
-		clk_put(di_clk);
-		clk_put(clk);
+		printk(KERN_INFO "HDTV is specified as %d\n", enable_tv);
+		fb_data[1].interface_pix_fmt = IPU_PIX_FMT_YUV444;
+		fb_data[1].mode = &(video_modes[0]);
 	}
 
 	/* Once a customer knows the platform configuration,
 	   this should be simplified to what is desired.
 	 */
 	if (enable_vga || enable_wvga || enable_tv == 2) {
-		(void)platform_device_register(&mxc_fb_device[1]); /* VGA */
+		/*
+		 * DI1 -> DP-BG channel:
+		 *
+		 *    dev    di-out-fmt    default-videmode
+		 *
+		 * 1. VGA       RGB 	   1024x768M-16@60
+		 * 2. WVGA      RGB 	   800x480M-16@55
+		 * 3. TVE       YUV	   video_modes[0]
+		 */
+		(void)platform_device_register(&mxc_fb_device[1]);
 		if (fb_data[0].mode_str || fb_data[0].mode)
+			/*
+			 * DI0 -> DC channel:
+			 *
+			 *    dev    di-out-fmt    default-videmode
+			 *
+			 * 1. LVDS      RGB 	   video_modes[1]
+			 * 2. DVI       RGB 	   1024x768M-16@60
+			 */
 			(void)platform_device_register(&mxc_fb_device[0]);
 	} else {
-		(void)platform_device_register(&mxc_fb_device[0]); /* DVI */
+		/*
+		 * DI0 -> DP-BG channel:
+		 *
+		 *    dev    di-out-fmt    default-videmode
+		 *
+		 * 1. LVDS      RGB 	   video_modes[1]
+		 * 2. DVI       RGB 	   1024x768M-16@60
+		 */
+		(void)platform_device_register(&mxc_fb_device[0]);
 		if (fb_data[1].mode_str || fb_data[1].mode)
+			/*
+			 * DI1 -> DC channel:
+			 *
+			 *    dev    di-out-fmt    default-videmode
+			 *
+			 * 1. VGA       RGB 	   1024x768M-16@60
+			 * 2. WVGA      RGB 	   800x480M-16@55
+			 * 3. TVE       YUV	   video_modes[0]
+			 */
 			(void)platform_device_register(&mxc_fb_device[1]);
 	}
 
+	/*
+	 * DI0/1 DP-FG channel:
+	 */
 	(void)platform_device_register(&mxc_fb_device[2]);
 
 	return 0;
@@ -466,7 +495,7 @@
 	return 1;
 }
 
-__setup("tv", tv_setup);
+__setup("hdtv", tv_setup);
 #else
 static inline void mxc_init_fb(void)
 {
diff -urNBb -x linux-2.6.31.9-ER1-efikamx/Documentation/dontdiff linux-2.6.31.9-ER1-efikamx.orig/arch/arm/mach-mx51/mx51_efikamx.c linux-2.6.31.9-ER1-efikamx/arch/arm/mach-mx51/mx51_efikamx.c
--- linux-2.6.31.9-ER1-efikamx.orig/arch/arm/mach-mx51/mx51_efikamx.c	2010-01-07 19:41:20.703837428 -0600
+++ linux-2.6.31.9-ER1-efikamx/arch/arm/mach-mx51/mx51_efikamx.c	2010-01-24 14:42:24.000000000 -0600
@@ -57,9 +57,9 @@
 #include "mx51_efikamx.h"
 
 extern int board_id[2];
-u8 edid[256];
 
-int fb_dump_var( const char *func_char, struct fb_var_screeninfo *var);
+int sii9022_reinit(struct fb_var_screeninfo *var);
+int cs8556_reinit(struct fb_var_screeninfo *var);
 
 #define VIDEO_MODE_HDMI_DEF	4
 #define VIDEO_MODE_VGA_DEF	2
@@ -67,13 +67,19 @@
 #define MEGA              1000000
 
 int __initdata video_output = { VIDEO_OUT_STATIC_AUTO };
-int __initdata video_mode = { VIDEO_MODE_HDMI_DEF };
+int __initdata video_mode = { VIDEO_OUT_STATIC_AUTO };
 int __initdata hdmi_audio = { 1 };
-int __initdata enable_hdmi_spdif = { 1 }; // always on Efika MX
+int __initdata enable_hdmi_spdif = { 0 }; // spdif doesn't work
 int __initdata clock_auto = { 1 };
 char __initdata vmode[32] = { 0 };
 int __initdata mxc_debug = { 1 };
 int __initdata extsync = { 1 };
+int __initdata sink_dvi = { 0 };
+int __initdata sink_monitor = { 0 };
+int __initdata pixclk_limit = { KHZ2PICOS(133200) };
+int __initdata video_max_res = { 0 };
+u8 edid[256];
+
 struct fb_videomode __initdata mxcfb_preferred;
 EXPORT_SYMBOL(hdmi_audio);
 EXPORT_SYMBOL(enable_hdmi_spdif);
@@ -81,7 +87,6 @@
 EXPORT_SYMBOL(vmode);
 EXPORT_SYMBOL(mxc_debug);
 EXPORT_SYMBOL(extsync);
-EXPORT_SYMBOL(video_output);
 EXPORT_SYMBOL(video_mode);
 
 
@@ -93,6 +98,7 @@
  * @ingroup MSL_MX51
  */
 int (*sii9022_func)( const char *procfs_buffer );
+extern int sii9022_reinit(struct fb_var_screeninfo *var);
 extern void __init mx51_efikamx_io_init(void);
 extern struct cpu_wp *(*get_cpu_wp)(int *wp);
 extern void (*set_num_cpu_wp)(int num);
@@ -310,11 +315,28 @@
 	return 0;
 }
 
+ // silence compiler warning because we don't use this right now
+static void fb_dump_var( const char *func_char, struct fb_var_screeninfo *var)
+{
+	if ( var == NULL )	
+		return;
+
+	printk(KERN_INFO "%s geometry %u %u %u %u\n", 
+	  func_char,  var->xres, var->yres, var->xres_virtual, var->yres_virtual);
+	printk(KERN_INFO "%s offset %u %u %u %u %u\n",
+	  func_char, var->xoffset, var->yoffset, var->height, var->width, var->bits_per_pixel);
+	printk(KERN_INFO "%s timings %u %u %u %u %u %u %u\n",
+	  func_char, var->pixclock, var->left_margin, var->right_margin, 
+	  var->upper_margin, var->lower_margin, var->hsync_len, var->vsync_len ); 	
+	printk(KERN_INFO "%s accel_flags %u sync %u vmode %u\n",
+	  func_char, var->accel_flags, var->sync, var->vmode );	
+}
+
+
 void mxcfb_videomode_to_modelist(const struct fb_info *info, const struct fb_videomode *modedb, int num,
 			      struct list_head *head)
 {
-	int i;
-
+	int i, del = 0;
 	INIT_LIST_HEAD(head);
 
 	for (i = 0; i < num; i++) {
@@ -322,18 +343,48 @@
 		struct list_head *pos, *n;
 		struct fb_modelist *modelist;
 		
-		list_for_each_safe(pos, n, head) {
-			modelist = list_entry(pos, struct fb_modelist, list);
-			if ( res_matches_refresh(modelist->mode, 
-									modedb[i].xres, modedb[i].yres, modedb[i].refresh) ) {
+		del = 0;
+		
+		if ( modedb[i].flag & FB_MODE_IS_FIRST ) {
+			printk(KERN_INFO "found preferred video mode %ux%u%s%u pclk=%u\n",
+				modedb[i].xres, modedb[i].yres, 
+				(modedb[i].vmode & FB_VMODE_INTERLACED ) ? "i@" : "@",
+				modedb[i].refresh,
+				modedb[i].pixclock );
+				
+			memcpy((void *) &mxcfb_preferred, (const void *) &modedb[i], sizeof(struct fb_videomode));	
+			// and we carry on because the next few lines may delete it
+		}
+		
+		if ( modedb[i].pixclock < pixclk_limit ) {
+			printk(KERN_INFO "%ux%u%s%u pclk=%u removed (exceed %u limit)\n",
+				modedb[i].xres, modedb[i].yres, 
+				(modedb[i].vmode & FB_VMODE_INTERLACED ) ? "i@" : "@",
+				modedb[i].refresh,
+				modedb[i].pixclock,
+				pixclk_limit );
+			continue; // next i, practically deleted
+		}
+		else if ( (modedb[i].vmode & FB_VMODE_INTERLACED) ) {
+			printk(KERN_INFO "%ux%u%s%u pclk=%u removed (interlaced)\n",
+				modedb[i].xres, modedb[i].yres, 
+				(modedb[i].vmode & FB_VMODE_INTERLACED ) ? "i@" : "@",
+				modedb[i].refresh,
+				modedb[i].pixclock );
+			continue; // next i, practically deleted
+		}
 
 				/* if candidate is a detail timing, delete existing one in modelist !
 				  * note: some TV has 1280x720@60 in standard timings but also has 1280x720 in detail timing block 
 				  *         in this case, use detail timing !
 				  */
-				if ( ((modelist->mode.vmode & FB_VMODE_INTERLACED) ^
-					 (modedb[i].vmode & FB_VMODE_INTERLACED)) == 0 &&
-					 ( modedb[i].flag & FB_MODE_IS_DETAILED ) ) {
+		list_for_each_safe(pos, n, head) {
+			modelist = list_entry(pos, struct fb_modelist, list);
+			
+			if ( res_matches_refresh(modelist->mode,
+				modedb[i].xres, modedb[i].yres, modedb[i].refresh) ) {
+
+				if ( ( modedb[i].flag & FB_MODE_IS_DETAILED ) ) {
 
 					printk(KERN_INFO "%ux%u%s%u pclk=%u removed (duplicate)\n",
 						modelist->mode.xres, modelist->mode.yres, 
@@ -342,109 +393,13 @@
 						modelist->mode.pixclock );
 					list_del(pos);
 					kfree(pos);
+					del = 1;
 				}
 			}
 		}
-		if (fb_add_videomode(&modedb[i], head))
-			return;
-
-	}
-}
-
-void mxcfb_sanitize_modelist(const struct fb_info *info, const struct fb_videomode *modedb, int num,
-			      struct list_head *head)
-{
-	struct fb_videomode *pmode;
-	int i;
-
-	pmode = (struct fb_videomode *) fb_find_best_display(&info->monspecs, head);
-	if (pmode)
-	{
-		fb_dump_mode("PREFERRED", pmode);
-		memcpy((void *) &mxcfb_preferred, (const void *) pmode, sizeof(struct fb_videomode));
-	}
-
-	for (i = 0; i < num; i++) {
-
-		struct list_head *pos, *n;
-		struct fb_modelist *modelist;
-
-		list_for_each_safe(pos, n, head) {
-			modelist = list_entry(pos, struct fb_modelist, list);
-			if (PICOS2KHZ(modelist->mode.pixclock) > 133000 ) {
-				printk(KERN_INFO "%ux%u%s%u pclk=%u removed (pixclk higher than %lu limit)\n",
-					modelist->mode.xres, modelist->mode.yres,
-					(modelist->mode.vmode & FB_VMODE_INTERLACED ) ? "i@" : "@",
-					modelist->mode.refresh,
-					modelist->mode.pixclock, KHZ2PICOS(133000) );
-
-				if (0 == memcmp((void *) &mxcfb_preferred, (void *) &modelist->mode, sizeof(struct fb_videomode)))
-				{
-					printk(KERN_INFO "uh-oh! deleted preferred mode!\n");
-				}
-				list_del(pos);
-				kfree(pos);
-			}
-		}
 
-	}
-}
-
-void mxcfb_update_default_var(struct fb_var_screeninfo *var, 
-									struct fb_info *info, 
-									const struct fb_videomode *def_mode )
-{
-	struct fb_monspecs *specs = &info->monspecs;
-	const struct fb_videomode *mode = NULL;
-//	struct fb_var_screeninfo var_tmp;
-	int modeidx = 0;
-	
-	printk(KERN_INFO "%s mode_opt=%s vmode=%s\n", __func__ , fb_mode_option, vmode );
-
-	fb_dump_mode("preferred mode", &mxcfb_preferred);
-
-	/* user specified vmode,  ex: support reduce blanking, such as 1280x768MR-16@60 */
-//	if ( vmode[0] ) {
-		/* use edid support modedb or modedb in modedb.c */
-//		modeidx = fb_find_mode(var, info, vmode, specs->modedb, specs->modedb_len, def_mode, 16);
-//	}
-/*	else */if ( specs->modedb != NULL) {
-#if 0
-		fb_videomode_to_var( &var_tmp, def_mode);
-		mode = fb_find_nearest_mode( def_mode, &info->modelist );
-#else
-		mode = fb_find_best_display(specs, &info->modelist);
-#endif
-
-		if ( mode ) {
-			fb_videomode_to_var(var, mode);
-			printk(KERN_INFO "best mode is %ux%u@%u pclk=%u\n",
-				mode->xres, mode->yres, mode->refresh, mode->pixclock );
-			fb_dump_mode("best mode", mode);
-		} else {
-			mode = fb_find_nearest_mode( &mxcfb_preferred, &info->modelist );
-			if ( mode ) {
-				fb_videomode_to_var(var, mode);
-				printk(KERN_INFO "nearest mode (%ux%u@%u pclk=%u) is %ux%u@%u pclk=%u\n",
-					mxcfb_preferred.xres, mxcfb_preferred.yres, mxcfb_preferred.refresh, mxcfb_preferred.pixclock,
-				mode->xres, mode->yres, mode->refresh, mode->pixclock );
-			fb_dump_mode("nearest mode", mode);
-			} else {
-				mode = fb_find_nearest_mode( def_mode, &info->modelist );
-				if ( mode ) {
-					fb_videomode_to_var(var, mode);
-					printk(KERN_INFO "nearest default (%ux%u@%u pclk=%u) is %ux%u@%u pclk=%u\n",
-						def_mode->xres, def_mode->yres, def_mode->refresh, def_mode->pixclock,
-						mode->xres, mode->yres, mode->refresh, mode->pixclock );
-					fb_dump_mode("nearest default", mode);
-				}
-			}
-		}
-	}
-
-	if ( modeidx == 0 && mode == NULL ) { /* no best monitor support mode timing found, use def_video_mode timing ! */
-		fb_videomode_to_var(var, def_mode);
-	fb_dump_var( __func__, var );
+		if (del == 0)
+			fb_add_videomode(&modedb[i], head);
 	}
 }
 
@@ -499,25 +454,30 @@
 
 	clk_put(di_clk);
 	clk_put(clk);
-	
 }
 
-int mxcfb_di_clock_adjust(int hdmi_output, u32 pixel_clock)
+int mxcfb_di_clock_adjust(int video_output, u32 pixel_clock)
 {
 	char *clk_di = "ipu_di0_clk";
 	u32 rate = 0;
 	static u32 pixel_clock_last = 0;
-	static int hdmi_output_last = 0;
+	static int video_output_last = 0;
 	
 	if( clock_auto == 0 )
 		return 0;
 
 	/* avoid uncessary clock change to reduce unknown impact chance */
-	if ( pixel_clock && (pixel_clock == pixel_clock_last) && hdmi_output == hdmi_output_last )
+	if ( pixel_clock && (pixel_clock == pixel_clock_last) && video_output == video_output_last )
+	{
+		printk(KERN_INFO "pclk %u same to previous one, skipping!\n", pixel_clock );
 		return 0;
-
+	}
+	if ( pixel_clock < 6000 || pixel_clock > 40000 ) { /* 25Mhz~148Mhz */
+		printk(KERN_INFO "pclk %u exceed limitation (6000~40000)!\n", pixel_clock );
+		return -1;
+	}
 	pixel_clock_last = pixel_clock;
-	hdmi_output_last = hdmi_output;	
+	video_output_last = video_output;	
 	
 			if ( pixel_clock == 0 ) {
 		printk(KERN_INFO "%s incorrect clock rate (%u), reset to %u\n", 
@@ -525,15 +485,68 @@
 				rate = 260*MEGA;
 			}
 			else
-				rate = (u32) (PICOS2KHZ(pixel_clock) * 1000UL)*4;
+		rate = (u32) (PICOS2KHZ(pixel_clock) * 1000UL)*1;
 
 			printk("%s pixelclk=%u rate=%u\n", __func__, pixel_clock, rate );
 			
-			clock_update("pll3", rate, clk_di, 4);
+	clock_update("pll3", rate, clk_di, 1);
 
 	return 0;
 }
 	
+void mxcfb_adjust(struct fb_var_screeninfo *var )
+{
+	if( clock_auto )
+		mxcfb_di_clock_adjust( video_output, var->pixclock );
+	if ( 1 /*(video_output == VIDEO_OUT_STATIC_HDMI) */) {
+		sii9022_reinit( var );
+	}
+}
+
+void mxcfb_update_default_var(struct fb_var_screeninfo *var, 
+									struct fb_info *info, 
+									const struct fb_videomode *def_mode )
+{
+	struct fb_monspecs *specs = &info->monspecs;
+	const struct fb_videomode *mode = NULL;
+//	struct fb_var_screeninfo var_tmp;
+	int modeidx = 0;
+
+	printk(KERN_INFO "%s mode_opt=%s vmode=%s\n", __func__ , fb_mode_option, vmode );
+
+	fb_dump_mode("preferred mode", &mxcfb_preferred);
+
+	/* user specified vmode,  ex: support reduce blanking, such as 1280x768MR-16@60 */
+	if ( vmode[0] ) {
+		/* use edid support modedb or modedb in modedb.c */
+		modeidx = fb_find_mode(var, info, vmode, specs->modedb, specs->modedb_len, def_mode, 16);
+	}
+	else if ( specs->modedb != NULL) {
+		mode = fb_find_best_display(specs, &info->modelist);
+
+		if ( mode ) {
+			fb_videomode_to_var(var, mode);
+			printk(KERN_INFO "best mode is %ux%u@%u pclk=%u\n",
+				mode->xres, mode->yres, mode->refresh, mode->pixclock );
+			fb_dump_mode("best mode", mode);
+		} else {
+			mode = fb_find_nearest_mode( def_mode, &info->modelist );
+			if ( mode ) {
+				fb_videomode_to_var(var, mode);
+				printk(KERN_INFO "nearest default (%ux%u@%u pclk=%u) is %ux%u@%u pclk=%u\n",
+					def_mode->xres, def_mode->yres, def_mode->refresh, def_mode->pixclock,
+					mode->xres, mode->yres, mode->refresh, mode->pixclock );
+				fb_dump_mode("nearest default", mode);
+			}
+		}
+	}
+
+	if ( modeidx == 0 && mode == NULL ) { /* no best monitor support mode timing found, use def_video_mode timing ! */
+		fb_videomode_to_var(var, def_mode);
+		fb_dump_var( __func__, var );
+	}
+}
+
 void mxc_init_fb(void)
 {	
 	if ( mxc_fb_initialized )
@@ -553,7 +566,6 @@
 
 static int __init hdmi_setup(char *__unused)
 {
-	video_mode = VIDEO_MODE_HDMI_DEF; /* default cea mode */
 	video_output = VIDEO_OUT_STATIC_HDMI;	
 	return 1;
 }
@@ -587,6 +599,17 @@
 	return 1;
 }
 
+static int __init max_res_setup(char *options)
+{
+	if (!options || !*options)
+		return 1;
+		
+	video_max_res = simple_strtol(options, NULL, 10);
+	printk("video_max_res=%d\n", video_max_res);
+	
+	return 1;
+}
+
 static int __init vmode_setup(char *options)
 {
 	if (!options || !*options)
@@ -604,6 +627,7 @@
 __setup("video_mode=", video_mode_setup);
 __setup("clock_auto=", clock_setup);
 __setup("vmode=", vmode_setup);
+__setup("max_res=", max_res_setup);
 
 
 
@@ -697,12 +721,12 @@
 	{
 	 .name = "flash",
 	 .offset = 0,
-	 .size = MTDPART_SIZ_FULL,
+	 .size = 0x200000,
 	},
 };
 
 static struct flash_platform_data mxc_spi_flash_data = {
-	.name = "m25p80",
+	.name = "mxc_spi_nor",
 	.parts = mxc_spi_nor_partitions,
 	.nr_parts = ARRAY_SIZE(mxc_spi_nor_partitions),
 	.type = "sst25vf032b",
diff -urNBb -x linux-2.6.31.9-ER1-efikamx/Documentation/dontdiff linux-2.6.31.9-ER1-efikamx.orig/arch/arm/mach-stmp378x/include/mach/lcdif.h linux-2.6.31.9-ER1-efikamx/arch/arm/mach-stmp378x/include/mach/lcdif.h
--- linux-2.6.31.9-ER1-efikamx.orig/arch/arm/mach-stmp378x/include/mach/lcdif.h	2009-12-12 13:16:51.000000000 -0600
+++ linux-2.6.31.9-ER1-efikamx/arch/arm/mach-stmp378x/include/mach/lcdif.h	2010-01-07 22:20:55.251526300 -0600
@@ -73,6 +73,7 @@
 struct stmp3xxx_platform_fb_data {
 	struct list_head list;
 	struct stmp3xxx_platform_fb_entry *cur;
+	struct stmp3xxx_platform_fb_entry *next;
 };
 
 #define STMP3XXX_LCDIF_PANEL_INIT	1
diff -urNBb -x linux-2.6.31.9-ER1-efikamx/Documentation/dontdiff linux-2.6.31.9-ER1-efikamx.orig/arch/arm/mm/fault-armv.c linux-2.6.31.9-ER1-efikamx/arch/arm/mm/fault-armv.c
--- linux-2.6.31.9-ER1-efikamx.orig/arch/arm/mm/fault-armv.c	2009-09-09 17:13:59.000000000 -0500
+++ linux-2.6.31.9-ER1-efikamx/arch/arm/mm/fault-armv.c	2010-01-09 14:35:54.532446045 -0600
@@ -153,14 +153,11 @@
 
 	page = pfn_to_page(pfn);
 	mapping = page_mapping(page);
-	if (mapping) {
 #ifndef CONFIG_SMP
-		int dirty = test_and_clear_bit(PG_dcache_dirty, &page->flags);
-
-		if (dirty)
+	if (test_and_clear_bit(PG_dcache_dirty, &page->flags))
 			__flush_dcache_page(mapping, page);
 #endif
-
+	if (mapping) {
 		if (cache_is_vivt())
 			make_coherent(mapping, vma, addr, pfn);
 		else if (vma->vm_flags & VM_EXEC)
diff -urNBb -x linux-2.6.31.9-ER1-efikamx/Documentation/dontdiff linux-2.6.31.9-ER1-efikamx.orig/arch/arm/plat-mxc/dvfs_per.c linux-2.6.31.9-ER1-efikamx/arch/arm/plat-mxc/dvfs_per.c
--- linux-2.6.31.9-ER1-efikamx.orig/arch/arm/plat-mxc/dvfs_per.c	2009-12-12 13:16:57.000000000 -0600
+++ linux-2.6.31.9-ER1-efikamx/arch/arm/plat-mxc/dvfs_per.c	2010-01-07 22:36:34.000000000 -0600
@@ -45,6 +45,7 @@
 #include <mach/hardware.h>
 #include <mach/mxc_dvfs.h>
 #include <mach/sdram_autogating.h>
+#include <mach/clock.h>
 #if defined(CONFIG_ARCH_MX37)
 #include <mach/mxc_dptc.h>
 #endif
@@ -82,7 +83,7 @@
 void stop_dvfs_per(void);
 int dvfs_per_active(void);
 int dvfs_per_divider_active(void);
-int dvfs_per_pixel_clk_limit(int pix_clk);
+int dvfs_per_pixel_clk_limit(void);
 
 extern int low_bus_freq_mode;
 extern int bus_freq_scaling_is_active;
@@ -500,12 +501,15 @@
 		return 0;
 
 	if (bus_freq_scaling_is_active) {
+		dvfs_per_is_paused = 1;
 		printk(KERN_INFO "Cannot start DVFS-PER since bus_freq_scaling is active\n");
 		return 0;
 	}
 
-	if (!ipu_freq_scaled) {
-		printk(KERN_INFO "Cannot start DVFS-PER since pixel clock is above 60MHz\n");
+	if (!dvfs_per_pixel_clk_limit()) {
+		dvfs_per_is_paused = 1;
+		printk(KERN_INFO "Cannot start DVFS-PER since pixel clock is\
+			above 60MHz or divider is not even\n");
 		return 0;
 	}
 
@@ -613,12 +617,52 @@
 	return dvfs_per_low_freq;
 }
 
-int dvfs_per_pixel_clk_limit(int pix_clk)
+int dvfs_per_pixel_clk_limit()
 {
-	if (pix_clk < DVFS_MAX_PIX_CLK && (!ipu_freq_scaled))
+	struct clk *disp0_pixel_clk;
+	struct clk *disp1_pixel_clk;
+	int disp0_rate = 0;
+	int disp1_rate = 0;
+	int div1 = 0;
+	int div2 = 0;
+	int even_div1 = 1;
+	int even_div2  = 1;
+
+	disp0_pixel_clk = clk_get(NULL, "pixel_clk.0");
+	disp1_pixel_clk = clk_get(NULL, "pixel_clk.1");
+
+	if (disp0_pixel_clk != NULL)
+		disp0_rate = clk_get_rate(disp0_pixel_clk);
+
+	if (disp1_pixel_clk != NULL)
+		disp1_rate = clk_get_rate(disp1_pixel_clk);
+
+	/* DVFS-PER will not work if pixel clock divider is odd */
+	if (disp0_rate != 0)
+		div1  = (clk_get_rate(
+			clk_get_parent(disp0_pixel_clk)) * 10) / disp0_rate;
+
+	if ((div1 % 2) || ((div1 / 10) % 2))
+		even_div1 = 0;
+
+	if ((div2 % 2) || ((div2 / 10) % 2))
+		even_div2 = 0;
+
+	if (disp1_rate != 0)
+		div2  = (clk_get_rate(
+			clk_get_parent(disp1_pixel_clk)) * 10) / disp1_rate;
+
+	if (((disp0_rate < DVFS_MAX_PIX_CLK && even_div1) ||
+		!clk_get_usecount(disp0_pixel_clk)) &&
+		((disp1_rate < DVFS_MAX_PIX_CLK && even_div2) ||
+		!clk_get_usecount(disp1_pixel_clk)))
 		ipu_freq_scaled = 1;
 	else
 		ipu_freq_scaled = 0;
+
+	clk_put(disp0_pixel_clk);
+	clk_put(disp1_pixel_clk);
+
 	return ipu_freq_scaled;
 }
 
diff -urNBb -x linux-2.6.31.9-ER1-efikamx/Documentation/dontdiff linux-2.6.31.9-ER1-efikamx.orig/arch/arm/plat-mxc/include/mach/mxc_dvfs.h linux-2.6.31.9-ER1-efikamx/arch/arm/plat-mxc/include/mach/mxc_dvfs.h
--- linux-2.6.31.9-ER1-efikamx.orig/arch/arm/plat-mxc/include/mach/mxc_dvfs.h	2009-12-12 13:16:57.000000000 -0600
+++ linux-2.6.31.9-ER1-efikamx/arch/arm/plat-mxc/include/mach/mxc_dvfs.h	2010-01-07 22:20:55.141421309 -0600
@@ -224,7 +224,7 @@
 extern void stop_dvfs_per(void);
 extern int dvfs_per_active(void);
 extern int dvfs_per_divider_active(void);
-extern int dvfs_per_pixel_clk_limit(int pix_clk);
+extern int dvfs_per_pixel_clk_limit(void);
 #else
 static inline int start_dvfs_per(void)
 {
@@ -245,7 +245,7 @@
 	return 0;
 }
 
-static inline int dvfs_per_pixel_clk_limit(int pix_clk)
+static inline int dvfs_per_pixel_clk_limit(void)
 {
 	return 0;
 }
diff -urNBb -x linux-2.6.31.9-ER1-efikamx/Documentation/dontdiff linux-2.6.31.9-ER1-efikamx.orig/arch/arm/plat-stmp3xxx/clock.c linux-2.6.31.9-ER1-efikamx/arch/arm/plat-stmp3xxx/clock.c
--- linux-2.6.31.9-ER1-efikamx.orig/arch/arm/plat-stmp3xxx/clock.c	2009-12-12 13:16:56.000000000 -0600
+++ linux-2.6.31.9-ER1-efikamx/arch/arm/plat-stmp3xxx/clock.c	2010-01-07 22:20:55.730284869 -0600
@@ -578,6 +578,9 @@
 					REGS_CLKCTRL_BASE + HW_CLKCTRL_CPU);
 				hclk.rate = 0;
 			}
+
+			__raw_writel(1 << clk->bypass_shift,
+					clk->bypass_reg + shift);
 		} else
 			__raw_writel(1 << clk->bypass_shift,
 					clk->bypass_reg + shift);
diff -urNBb -x linux-2.6.31.9-ER1-efikamx/Documentation/dontdiff linux-2.6.31.9-ER1-efikamx.orig/arch/arm/plat-stmp3xxx/cpufreq.c linux-2.6.31.9-ER1-efikamx/arch/arm/plat-stmp3xxx/cpufreq.c
--- linux-2.6.31.9-ER1-efikamx.orig/arch/arm/plat-stmp3xxx/cpufreq.c	2009-12-12 13:16:57.000000000 -0600
+++ linux-2.6.31.9-ER1-efikamx/arch/arm/plat-stmp3xxx/cpufreq.c	2010-01-07 22:20:55.058326665 -0600
@@ -60,7 +60,7 @@
 	1450000, 355000, 3300000, 1750000, 0 },
 	{ 392730, 130910, 130910, 0, 1475000,
 	1375000, 225000, 3300000, 1750000, 0 },
-	{ 360000, 120000, 120000, 0, 13750000,
+	{ 360000, 120000, 120000, 0, 1375000,
 	1275000, 200000, 3300000, 1750000, 0 },
 	{ 261820, 130910, 130910, 0, 1275000,
 	1175000, 173000, 3300000, 1750000, 0 },
diff -urNBb -x linux-2.6.31.9-ER1-efikamx/Documentation/dontdiff linux-2.6.31.9-ER1-efikamx.orig/arch/arm/plat-stmp3xxx/pinmux.c linux-2.6.31.9-ER1-efikamx/arch/arm/plat-stmp3xxx/pinmux.c
--- linux-2.6.31.9-ER1-efikamx.orig/arch/arm/plat-stmp3xxx/pinmux.c	2009-12-12 13:16:54.000000000 -0600
+++ linux-2.6.31.9-ER1-efikamx/arch/arm/plat-stmp3xxx/pinmux.c	2010-01-07 22:20:55.820373708 -0600
@@ -429,6 +429,16 @@
 	stmp3xxx_setl(1 << gpio, pm->pin2irq);
 }
 
+static void stmp3xxx_pin_disable_irq(unsigned irq)
+{
+	struct stmp3xxx_pinmux_bank *pm;
+	unsigned gpio;
+
+	stmp3xxx_irq_to_gpio(irq, &pm, &gpio);
+	stmp3xxx_clearl(1 << gpio, pm->irqen);
+	stmp3xxx_clearl(1 << gpio, pm->pin2irq);
+}
+
 static inline
 struct stmp3xxx_pinmux_bank *to_pinmux_bank(struct gpio_chip *chip)
 {
@@ -510,6 +520,7 @@
 	.ack	= stmp3xxx_pin_ack_irq,
 	.mask	= stmp3xxx_pin_mask_irq,
 	.unmask	= stmp3xxx_pin_unmask_irq,
+	.disable = stmp3xxx_pin_disable_irq,
 	.set_type = stmp3xxx_set_irqtype,
 };
 
diff -urNBb -x linux-2.6.31.9-ER1-efikamx/Documentation/dontdiff linux-2.6.31.9-ER1-efikamx.orig/arch/arm/plat-stmp3xxx/usb_common.c linux-2.6.31.9-ER1-efikamx/arch/arm/plat-stmp3xxx/usb_common.c
--- linux-2.6.31.9-ER1-efikamx.orig/arch/arm/plat-stmp3xxx/usb_common.c	2009-12-12 13:16:53.000000000 -0600
+++ linux-2.6.31.9-ER1-efikamx/arch/arm/plat-stmp3xxx/usb_common.c	2010-01-07 22:20:55.220679214 -0600
@@ -206,21 +206,6 @@
 int usb_phy_enable(void)
 {
 	u32 tmp;
-	/*
-	* Set these bits so that we can force the OTG bits high
-	* so the ARC core operates properly
-	*/
-	stmp3xxx_clearl(BM_POWER_CTRL_CLKGATE,
-		      REGS_POWER_BASE + HW_POWER_CTRL);
-	stmp3xxx_setl(BM_POWER_DEBUG_VBUSVALIDPIOLOCK |
-			 BM_POWER_DEBUG_AVALIDPIOLOCK |
-			 BM_POWER_DEBUG_BVALIDPIOLOCK,
-			 REGS_POWER_BASE + HW_POWER_DEBUG);
-	tmp = __raw_readl(REGS_POWER_BASE + HW_POWER_STS);
-	tmp |= BM_POWER_STS_BVALID | BM_POWER_STS_AVALID |
-		       BM_POWER_STS_VBUSVALID;
-	__raw_writel(tmp, REGS_POWER_BASE + HW_POWER_STS);
-
 	/* Reset USBPHY module */
 	stmp3xxx_setl(BM_USBPHY_CTRL_SFTRST,
 		      REGS_USBPHY_BASE + HW_USBPHY_CTRL);
diff -urNBb -x linux-2.6.31.9-ER1-efikamx/Documentation/dontdiff linux-2.6.31.9-ER1-efikamx.orig/drivers/media/video/mxc/capture/ipu_still.c linux-2.6.31.9-ER1-efikamx/drivers/media/video/mxc/capture/ipu_still.c
--- linux-2.6.31.9-ER1-efikamx.orig/drivers/media/video/mxc/capture/ipu_still.c	2009-12-12 13:16:52.000000000 -0600
+++ linux-2.6.31.9-ER1-efikamx/drivers/media/video/mxc/capture/ipu_still.c	2010-01-07 22:20:55.626286774 -0600
@@ -90,6 +90,8 @@
 
 	if (cam->v2f.fmt.pix.pixelformat == V4L2_PIX_FMT_YUV420)
 		pixel_fmt = IPU_PIX_FMT_YUV420P;
+	else if (cam->v2f.fmt.pix.pixelformat == V4L2_PIX_FMT_NV12)
+		pixel_fmt = IPU_PIX_FMT_NV12;
 	else if (cam->v2f.fmt.pix.pixelformat == V4L2_PIX_FMT_YUV422P)
 		pixel_fmt = IPU_PIX_FMT_YUV422P;
 	else if (cam->v2f.fmt.pix.pixelformat == V4L2_PIX_FMT_UYVY)
diff -urNBb -x linux-2.6.31.9-ER1-efikamx/Documentation/dontdiff linux-2.6.31.9-ER1-efikamx.orig/drivers/media/video/mxc/capture/mxc_v4l2_capture.c linux-2.6.31.9-ER1-efikamx/drivers/media/video/mxc/capture/mxc_v4l2_capture.c
--- linux-2.6.31.9-ER1-efikamx.orig/drivers/media/video/mxc/capture/mxc_v4l2_capture.c	2009-12-12 13:16:54.000000000 -0600
+++ linux-2.6.31.9-ER1-efikamx/drivers/media/video/mxc/capture/mxc_v4l2_capture.c	2010-01-07 22:20:54.591406568 -0600
@@ -1135,10 +1135,12 @@
 
 	/*
 	 * Set the default current cropped resolution to be the same with
-	 * the cropping boundary.
+	 * the cropping boundary(except for tvin module).
 	 */
+	if (cam->device_type != 1) {
 	cam->crop_current.width = cam->crop_bounds.width;
 	cam->crop_current.height = cam->crop_bounds.height;
+	}
 
 	/* This essentially loses the data at the left and bottom of the image
 	 * giving a digital zoom image, if crop_current is less than the full
diff -urNBb -x linux-2.6.31.9-ER1-efikamx/Documentation/dontdiff linux-2.6.31.9-ER1-efikamx.orig/drivers/media/video/mxc/output/mxc_v4l2_output.c linux-2.6.31.9-ER1-efikamx/drivers/media/video/mxc/output/mxc_v4l2_output.c
--- linux-2.6.31.9-ER1-efikamx.orig/drivers/media/video/mxc/output/mxc_v4l2_output.c	2009-12-12 13:16:57.000000000 -0600
+++ linux-2.6.31.9-ER1-efikamx/drivers/media/video/mxc/output/mxc_v4l2_output.c	2010-01-15 12:58:43.000000000 -0600
@@ -1081,7 +1081,6 @@
 	bool use_direct_adc = false;
 	mm_segment_t old_fs;
 	int rc = 0;
-	volatile u32 *address;
 
 	dev_dbg(dev, "mxc_v4l2out_streamon: field format=%d\n",
 		vout->field_fmt);
@@ -1363,10 +1362,9 @@
 		vout->display_buf_size = vout->xres *
 			vout->yres * fbi->var.bits_per_pixel / 8;
 		/* green screen */
-		address = phys_to_virt(vout->display_bufs[0]);
-		memset(address, 0x10, vout->display_buf_size);
-		address = phys_to_virt(vout->display_bufs[1]);
-		memset(address, 0x10, vout->display_buf_size);
+		memset(fbi->screen_base, 0x10,
+				fbi->fix.line_length * fbi->var.yres_virtual);
+
 		if (INTERLACED_CONTENT(vout))
 			vout->post_proc_ch = MEM_VDI_PRP_VF_MEM;
 		else
@@ -1969,6 +1967,14 @@
 	case VIDIOC_REQBUFS:
 		{
 			struct v4l2_requestbuffers *req = arg;
+			
+#ifdef CONFIG_MACH_MX51_EFIKAMX
+			extern void mx51_efikamx_drop_caches(void);
+
+			/* workaround to avoid dma_alloc_coherent failed during totem playback */
+			mx51_efikamx_drop_caches();
+#endif
+			
 			if ((req->type != V4L2_BUF_TYPE_VIDEO_OUTPUT) ||
 			    (req->memory != V4L2_MEMORY_MMAP)) {
 				dev_dbg(&vdev->dev,
diff -urNBb -x linux-2.6.31.9-ER1-efikamx/Documentation/dontdiff linux-2.6.31.9-ER1-efikamx.orig/drivers/media/video/pxp.c linux-2.6.31.9-ER1-efikamx/drivers/media/video/pxp.c
--- linux-2.6.31.9-ER1-efikamx.orig/drivers/media/video/pxp.c	2009-12-12 13:16:56.000000000 -0600
+++ linux-2.6.31.9-ER1-efikamx/drivers/media/video/pxp.c	2010-01-07 22:20:54.744029838 -0600
@@ -47,6 +47,9 @@
 
 #define V4L2_OUTPUT_TYPE_INTERNAL	4
 
+#define PXP_WAITCON	((__raw_readl(HW_PXP_NEXT_ADDR) & BM_PXP_NEXT_ENABLED) \
+				!= BM_PXP_NEXT_ENABLED)
+
 #define REG_OFFSET	0x10
 #define REGS1_NUMS	16
 #define REGS2_NUMS	5
@@ -170,15 +173,15 @@
 		ctrl |= BM_PXP_CTRL_ENABLE;
 
 	__raw_writel(ctrl, HW_PXP_CTRL_ADDR);
+	pxp->regs_virt->ctrl = ctrl;
 }
 
 static void pxp_set_rgbbuf(struct pxps *pxp)
 {
-	__raw_writel(pxp->outb_phys, HW_PXP_RGBBUF_ADDR);
+	pxp->regs_virt->rgbbuf = pxp->outb_phys;
 	/* Always equal to the FB size */
-	__raw_writel(BF(pxp->fb.fmt.width, PXP_RGBSIZE_WIDTH) |
-			  BF(pxp->fb.fmt.height, PXP_RGBSIZE_HEIGHT),
-			  HW_PXP_RGBSIZE_ADDR);
+	pxp->regs_virt->rgbsize = BF(pxp->fb.fmt.width, PXP_RGBSIZE_WIDTH) |
+				BF(pxp->fb.fmt.height, PXP_RGBSIZE_HEIGHT);
 }
 
 static void pxp_set_s0colorkey(struct pxps *pxp)
@@ -186,11 +189,11 @@
 	/* Low and high are set equal. V4L does not allow a chromakey range */
 	if (pxp->s0_chromakey == -1) {
 		/* disable color key */
-		__raw_writel(0xFFFFFF, HW_PXP_S0COLORKEYLOW_ADDR);
-		__raw_writel(0, HW_PXP_S0COLORKEYHIGH_ADDR);
+		pxp->regs_virt->s0colorkeylow = 0xFFFFFF;
+		pxp->regs_virt->s0colorkeyhigh = 0;
 	} else {
-		__raw_writel(pxp->s0_chromakey, HW_PXP_S0COLORKEYLOW_ADDR);
-		__raw_writel(pxp->s0_chromakey, HW_PXP_S0COLORKEYHIGH_ADDR);
+		pxp->regs_virt->s0colorkeylow = pxp->s0_chromakey;
+		pxp->regs_virt->s0colorkeyhigh = pxp->s0_chromakey;
 	}
 }
 
@@ -198,21 +201,21 @@
 {
 	/* Low and high are set equal. V4L does not allow a chromakey range */
 	if (pxp->s1_chromakey_state != 0 && pxp->s1_chromakey != -1) {
-		__raw_writel(pxp->s1_chromakey, HW_PXP_OLCOLORKEYLOW_ADDR);
-		__raw_writel(pxp->s1_chromakey, HW_PXP_OLCOLORKEYHIGH_ADDR);
+		pxp->regs_virt->olcolorkeylow = pxp->s1_chromakey;
+		pxp->regs_virt->olcolorkeyhigh = pxp->s1_chromakey;
 	} else {
 		/* disable color key */
-		__raw_writel(0xFFFFFF, HW_PXP_OLCOLORKEYLOW_ADDR);
-		__raw_writel(0, HW_PXP_OLCOLORKEYHIGH_ADDR);
+		pxp->regs_virt->olcolorkeylow = 0xFFFFFF;
+		pxp->regs_virt->olcolorkeyhigh = 0;
 	}
 }
 
 static void pxp_set_oln(struct pxps *pxp)
 {
-	__raw_writel((u32)pxp->fb.base, HW_PXP_OLn_ADDR(0));
-	__raw_writel(BF(pxp->fb.fmt.width >> 3, PXP_OLnSIZE_WIDTH) |
-				BF(pxp->fb.fmt.height >> 3, PXP_OLnSIZE_HEIGHT),
-				HW_PXP_OLnSIZE_ADDR(0));
+	pxp->regs_virt->ol0.ol = (u32)pxp->fb.base;
+	pxp->regs_virt->ol0.olsize =
+		BF(pxp->fb.fmt.width >> 3, PXP_OLnSIZE_WIDTH) |
+		BF(pxp->fb.fmt.height >> 3, PXP_OLnSIZE_HEIGHT);
 }
 
 static void pxp_set_olparam(struct pxps *pxp)
@@ -234,7 +237,8 @@
 		olparam |= BM_PXP_OLnPARAM_ENABLE_COLORKEY;
 	if (pxp->overlay_state)
 		olparam |= BM_PXP_OLnPARAM_ENABLE;
-	__raw_writel(olparam, HW_PXP_OLnPARAM_ADDR(0));
+
+	pxp->regs_virt->ol0.olparam = olparam;
 }
 
 static void pxp_set_s0param(struct pxps *pxp)
@@ -245,7 +249,7 @@
 	s0param |= BF(pxp->drect.top >> 3, PXP_S0PARAM_YBASE);
 	s0param |= BF(pxp->s0_width >> 3, PXP_S0PARAM_WIDTH);
 	s0param |= BF(pxp->s0_height >> 3, PXP_S0PARAM_HEIGHT);
-	__raw_writel(s0param, HW_PXP_S0PARAM_ADDR);
+	pxp->regs_virt->s0param = s0param;
 }
 
 static void pxp_set_s0crop(struct pxps *pxp)
@@ -256,7 +260,7 @@
 	s0crop |= BF(pxp->srect.top >> 3, PXP_S0CROP_YBASE);
 	s0crop |= BF(pxp->drect.width >> 3, PXP_S0CROP_WIDTH);
 	s0crop |= BF(pxp->drect.height >> 3, PXP_S0CROP_HEIGHT);
-	__raw_writel(s0crop, HW_PXP_S0CROP_ADDR);
+	pxp->regs_virt->s0crop = s0crop;
 }
 
 static int pxp_set_scaling(struct pxps *pxp)
@@ -282,7 +286,7 @@
 	yscale = pxp->srect.height * 0x1000 / pxp->drect.height;
 	s0scale = BF(yscale, PXP_S0SCALE_YSCALE) |
 		  BF(xscale, PXP_S0SCALE_XSCALE);
-	__raw_writel(s0scale, HW_PXP_S0SCALE_ADDR);
+	pxp->regs_virt->s0scale = s0scale;
 
 out:
 	pxp_set_ctrl(pxp);
@@ -311,7 +315,7 @@
 
 static void pxp_set_s0bg(struct pxps *pxp)
 {
-	__raw_writel(pxp->s0_bgcolor, HW_PXP_S0BACKGROUND_ADDR);
+	pxp->regs_virt->s0background = pxp->s0_bgcolor;
 }
 
 static void pxp_set_csc(struct pxps *pxp)
@@ -716,14 +719,14 @@
 	return ret;
 }
 
-static void pxp_buf_output(struct pxps *pxp)
+static void pxp_buf_next(struct pxps *pxp)
 {
 	dma_addr_t Y, U, V;
 
 	if (pxp->active) {
 		pxp->active->state = VIDEOBUF_ACTIVE;
 		Y = videobuf_to_dma_contig(pxp->active);
-		__raw_writel(Y, HW_PXP_S0BUF_ADDR);
+		pxp->regs_virt->s0buf = Y;
 		if ((pxp->s0_fmt->fourcc == V4L2_PIX_FMT_YUV420) ||
 		    (pxp->s0_fmt->fourcc == V4L2_PIX_FMT_YUV422P)) {
 			int s = 1;	/* default to YUV 4:2:2 */
@@ -731,27 +734,74 @@
 				s = 2;
 			U = Y + (pxp->s0_width * pxp->s0_height);
 			V = U + ((pxp->s0_width * pxp->s0_height) >> s);
-			__raw_writel(U, HW_PXP_S0UBUF_ADDR);
-			__raw_writel(V, HW_PXP_S0VBUF_ADDR);
+			pxp->regs_virt->s0ubuf = U;
+			pxp->regs_virt->s0vbuf = V;
 		}
-		__raw_writel(BM_PXP_CTRL_ENABLE, HW_PXP_CTRL_SET_ADDR);
+		pxp->regs_virt->ctrl =
+			__raw_readl(HW_PXP_CTRL_ADDR) | BM_PXP_CTRL_ENABLE;
 	}
+
+	__raw_writel(pxp->regs_phys, HW_PXP_NEXT_ADDR);
+}
+
+static void pxp_next_handle(struct work_struct *w)
+{
+	struct pxps *pxp = container_of(w, struct pxps, work);
+	struct pxp_buffer *buf, *next;
+	unsigned long flags;
+
+	if (pxp->next_queue_ended == 1)
+		return;
+
+	spin_lock_irqsave(&pxp->lock, flags);
+
+	while (!list_empty(&pxp->nextq)) {
+		spin_unlock_irqrestore(&pxp->lock, flags);
+
+		if (!wait_event_interruptible_timeout(pxp->done, PXP_WAITCON,
+					5 * HZ) || signal_pending(current)) {
+			spin_lock_irqsave(&pxp->lock, flags);
+			list_for_each_entry_safe(buf, next, &pxp->nextq, queue)
+				list_del(&buf->queue);
+			spin_unlock_irqrestore(&pxp->lock, flags);
+			pxp->next_queue_ended = 1;
+			return;
+		}
+
+		spin_lock_irqsave(&pxp->lock, flags);
+		buf = list_entry(pxp->nextq.next,
+					struct pxp_buffer,
+					queue);
+		list_del_init(&buf->queue);
+		pxp->active = &buf->vb;
+		pxp->active->state = VIDEOBUF_QUEUED;
+		pxp_buf_next(pxp);
+	}
+
+	spin_unlock_irqrestore(&pxp->lock, flags);
 }
 
 static void pxp_buf_queue(struct videobuf_queue *q,
 			struct videobuf_buffer *vb)
 {
 	struct pxps *pxp = q->priv_data;
+	struct pxp_buffer *buf;
 	unsigned long flags;
 
 	spin_lock_irqsave(&pxp->lock, flags);
 
+	if (list_empty(&pxp->outq)) {
 	list_add_tail(&vb->queue, &pxp->outq);
 	vb->state = VIDEOBUF_QUEUED;
 
-	if (!pxp->active) {
 		pxp->active = vb;
-		pxp_buf_output(pxp);
+		pxp_buf_next(pxp);
+	} else {
+		list_add_tail(&vb->queue, &pxp->outq);
+
+		buf = container_of(vb, struct pxp_buffer, vb);
+		list_add_tail(&buf->queue, &pxp->nextq);
+		queue_work(pxp->workqueue, &pxp->work);
 	}
 
 	spin_unlock_irqrestore(&pxp->lock, flags);
@@ -1021,13 +1070,16 @@
 	if (ret)
 		return ret;
 
+	pxp->next_queue_ended = 0;
+	pxp->workqueue = create_singlethread_workqueue("pxp");
+
 	videobuf_queue_dma_contig_init(&pxp->s0_vbq,
 				&pxp_vbq_ops,
 				&pxp->pdev->dev,
 				&pxp->lock,
 				V4L2_BUF_TYPE_VIDEO_OUTPUT,
 				V4L2_FIELD_NONE,
-				sizeof(struct videobuf_buffer),
+				sizeof(struct pxp_buffer),
 				pxp);
 
 	return 0;
@@ -1037,8 +1089,12 @@
 {
 	struct pxps *pxp = video_get_drvdata(video_devdata(file));
 
+	if (pxp->workqueue)
+		destroy_workqueue(pxp->workqueue);
+
 	videobuf_stop(&pxp->s0_vbq);
 	videobuf_mmap_free(&pxp->s0_vbq);
+	pxp->active = NULL;
 
 	mutex_lock(&pxp->mutex);
 	pxp->users--;
@@ -1121,27 +1177,23 @@
 
 	__raw_writel(BM_PXP_STAT_IRQ, HW_PXP_STAT_CLR_ADDR);
 
-	vb = pxp->active;
-	vb->state = VIDEOBUF_DONE;
-	do_gettimeofday(&vb->ts);
-	vb->field_count++;
-
-	list_del_init(&vb->queue);
-
 	if (list_empty(&pxp->outq)) {
-		pxp->active = NULL;
+		pr_warning("irq: outq empty!!!\n");
 		goto out;
 	}
 
-	pxp->active = list_entry(pxp->outq.next,
+	vb = list_entry(pxp->outq.next,
 				struct videobuf_buffer,
 				queue);
+	list_del_init(&vb->queue);
 
-	pxp_buf_output(pxp);
+	vb->state = VIDEOBUF_DONE;
+	do_gettimeofday(&vb->ts);
+	vb->field_count++;
 
-out:
 	wake_up(&vb->done);
-
+	wake_up(&pxp->done);
+out:
 	spin_unlock_irqrestore(&pxp->lock, flags);
 
 	return IRQ_HANDLED;
@@ -1172,7 +1224,20 @@
 	pxp->res = res;
 	pxp->irq = irq;
 
+	pxp->regs_virt = dma_alloc_coherent(NULL,
+				PAGE_ALIGN(sizeof(struct pxp_registers)),
+				&pxp->regs_phys, GFP_KERNEL);
+	if (pxp->regs_virt == NULL) {
+		dev_err(&pdev->dev, "failed to allocate pxp_register object\n");
+		err = -ENOMEM;
+		goto exit;
+	}
+
+	init_waitqueue_head(&pxp->done);
+
+	INIT_WORK(&pxp->work, pxp_next_handle);
 	INIT_LIST_HEAD(&pxp->outq);
+	INIT_LIST_HEAD(&pxp->nextq);
 	spin_lock_init(&pxp->lock);
 	mutex_init(&pxp->mutex);
 
@@ -1241,6 +1306,9 @@
 	video_unregister_device(pxp->vdev);
 	video_device_release(pxp->vdev);
 
+	if (pxp->regs_virt)
+		dma_free_coherent(0, PAGE_ALIGN(sizeof(struct pxp_registers)),
+				pxp->regs_virt, pxp->regs_phys);
 	kfree(pxp->outb);
 	kfree(pxp);
 
diff -urNBb -x linux-2.6.31.9-ER1-efikamx/Documentation/dontdiff linux-2.6.31.9-ER1-efikamx.orig/drivers/media/video/pxp.h linux-2.6.31.9-ER1-efikamx/drivers/media/video/pxp.h
--- linux-2.6.31.9-ER1-efikamx.orig/drivers/media/video/pxp.h	2009-12-12 13:16:54.000000000 -0600
+++ linux-2.6.31.9-ER1-efikamx/drivers/media/video/pxp.h	2010-01-07 22:20:54.745919299 -0600
@@ -16,12 +16,56 @@
  * http://www.gnu.org/copyleft/gpl.html
  */
 
+struct pxp_overlay_registers {
+	u32 ol;
+	u32 olsize;
+	u32 olparam;
+	u32 olparam2;
+};
+
+/* Registers feed for PXP_NEXT */
+struct pxp_registers {
+	u32 ctrl;
+	u32 rgbbuf;
+	u32 rgbbuf2;
+	u32 rgbsize;
+	u32 s0buf;
+	u32 s0ubuf;
+	u32 s0vbuf;
+	u32 s0param;
+	u32 s0background;
+	u32 s0crop;
+	u32 s0scale;
+	u32 s0offset;
+	u32 s0colorkeylow;
+	u32 s0colorkeyhigh;
+	u32 olcolorkeylow;
+	u32 olcolorkeyhigh;
+
+	struct pxp_overlay_registers ol0;
+	struct pxp_overlay_registers ol1;
+	struct pxp_overlay_registers ol2;
+	struct pxp_overlay_registers ol3;
+	struct pxp_overlay_registers ol4;
+	struct pxp_overlay_registers ol5;
+	struct pxp_overlay_registers ol6;
+	struct pxp_overlay_registers ol7;
+};
+
+struct pxp_buffer {
+	/* Must be first! */
+	struct videobuf_buffer vb;
+	struct list_head queue;
+};
+
 struct pxps {
 	struct platform_device *pdev;
 	struct resource *res;
 	int irq;
 	void __iomem *regs;
 
+	struct work_struct work;
+	struct workqueue_struct *workqueue;
 	spinlock_t lock;
 	struct mutex mutex;
 	int users;
@@ -31,6 +75,7 @@
 	struct videobuf_queue s0_vbq;
 	struct videobuf_buffer *active;
 	struct list_head outq;
+	struct list_head nextq;
 
 	int output;
 	u32 *outb;
@@ -61,6 +106,12 @@
 	int local_alpha_state;
 	int s1_chromakey_state;
 	u32 s1_chromakey;
+
+	/* PXP_NEXT */
+	u32 regs_phys;
+	struct pxp_registers *regs_virt;
+	wait_queue_head_t done;
+	int next_queue_ended;
 };
 
 struct pxp_data_format {
diff -urNBb -x linux-2.6.31.9-ER1-efikamx/Documentation/dontdiff linux-2.6.31.9-ER1-efikamx.orig/drivers/mmc/host/mx_sdhci.c linux-2.6.31.9-ER1-efikamx/drivers/mmc/host/mx_sdhci.c
--- linux-2.6.31.9-ER1-efikamx.orig/drivers/mmc/host/mx_sdhci.c	2009-12-12 13:16:57.000000000 -0600
+++ linux-2.6.31.9-ER1-efikamx/drivers/mmc/host/mx_sdhci.c	2010-01-07 22:20:55.709362570 -0600
@@ -1185,6 +1185,15 @@
 
 	/* Stop the clock when the req is done */
 	flags = SDHCI_DATA_ACTIVE | SDHCI_DOING_WRITE | SDHCI_DOING_READ;
+	if (machine_is_mx35_3ds()) {
+		/* Do not disable the eSDHC clk on MX35 3DS board,
+		 * since SYSTEM can't boot up after the reset key
+		 * is pressed when the SD/MMC boot mode is used.
+		 * The root cause is that the ROM code don't ensure
+		 * the SD/MMC clk is running when boot system.
+		 * */
+		mmc_request_done(host->mmc, mrq);
+	} else {
 	if (!(readl(host->ioaddr + SDHCI_PRESENT_STATE) & flags)) {
 		if (host->plat_data->clk_flg) {
 			clk_disable(host->clk);
@@ -1193,6 +1202,8 @@
 	}
 
 	mmc_request_done(host->mmc, mrq);
+	}
+
 }
 
 static void sdhci_timeout_timer(unsigned long data)
diff -urNBb -x linux-2.6.31.9-ER1-efikamx/Documentation/dontdiff linux-2.6.31.9-ER1-efikamx.orig/drivers/mtd/nand/gpmi/gpmi-base.c linux-2.6.31.9-ER1-efikamx/drivers/mtd/nand/gpmi/gpmi-base.c
--- linux-2.6.31.9-ER1-efikamx.orig/drivers/mtd/nand/gpmi/gpmi-base.c	2009-12-12 13:16:57.000000000 -0600
+++ linux-2.6.31.9-ER1-efikamx/drivers/mtd/nand/gpmi/gpmi-base.c	2010-01-07 22:20:55.446926936 -0600
@@ -34,6 +34,7 @@
 #include <linux/slab.h>
 #include <linux/regulator/consumer.h>
 #include <asm/div64.h>
+#include <asm/sizes.h>
 
 #include <mach/stmp3xxx.h>
 #include <mach/platform.h>
@@ -41,7 +42,7 @@
 #include <mach/regs-gpmi.h>
 #include <mach/dma.h>
 #include "gpmi.h"
-#include "nand_device_info.h"
+#include "../nand_device_info.h"
 
 /* Macro definitions for the i.MX23. Some will be different for other SoC's. */
 
@@ -160,7 +161,7 @@
  * hardware block for error correction.
  */
 
-static int bch = 0/* = 0 */;
+static int bch = 1;
 
 /* Forward references. */
 
@@ -1580,7 +1581,7 @@
 	ecc = g->raw_oob_mode == 0 && raw_mode == 0;
 
 	if (sndcmd) {
-		if (!bch_mode())
+		if (!bch_mode() || !ecc)
 			oob_offset = mtd->writesize;
 		if (likely(ecc) && !bch_mode())
 			oob_offset += chip->ecc.bytes * chip->ecc.steps;
@@ -1606,7 +1607,7 @@
 	if (map_buffers && bch_mode())
 		bufphys = dma_map_single(&g->dev->dev, chip->buffers->databuf,
 				mtd->writesize, DMA_FROM_DEVICE);
-	if (dma_mapping_error(&g->dev->dev, bufphys))
+	if (bch_mode() && dma_mapping_error(&g->dev->dev, bufphys))
 		bufphys = g->data_buffer_handle;
 
 	/* ECC read */
@@ -1657,8 +1658,8 @@
 {
 	int status = 0;
 	struct gpmi_nand_data *g = chip->priv;
-	loff_t oob_offset;
-	dma_addr_t oobphys;
+	loff_t oob_offset = 0;
+	dma_addr_t oobphys, bufphys;
 	int ecc;
 	int err = 0;
 
@@ -1674,12 +1675,15 @@
 	ecc = g->raw_oob_mode == 0 && raw_mode == 0;
 
 	/* Send command to start input data     */
+	if (!bch_mode() || !ecc) {
 	oob_offset = mtd->writesize;
 	if (likely(ecc)) {
 		oob_offset += chip->ecc.bytes * chip->ecc.steps;
 		memset(chip->oob_poi + g->oob_free, 0xff,
 		       mtd->oobsize - g->oob_free);
 	}
+	}
+
 	chip->cmdfunc(mtd, NAND_CMD_SEQIN, oob_offset, page);
 
 	/* call ECC */
@@ -1696,8 +1700,15 @@
 			copies++;
 		}
 
+		bufphys = ~0;
+
+		if (bch_mode()) {
+			bufphys = g->data_buffer_handle;
+			memset(g->data_buffer, 0xff, mtd->writesize);
+		}
+
 		g->hc->write(g->hc, g->selected_chip, g->cchip->d,
-			     g->cchip->error.handle, ~0, oobphys);
+			     g->cchip->error.handle, bufphys, oobphys);
 
 		err = gpmi_dma_exchange(g, NULL);
 	} else
@@ -2100,7 +2111,15 @@
  */
 static int gpmi_scan_middle(struct gpmi_nand_data *g)
 {
-	int oobsize = 0;
+	struct mtd_info          *mtd    = &g->mtd;
+	struct nand_chip         *nand   = &g->nand;
+	struct nand_device_info  *info   = &g->device_info;
+	int                      index   = 0;
+	uint64_t                 physical_medium_size_in_bytes;
+	uint64_t                 logical_medium_size_in_bytes;
+	uint64_t                 logical_chip_size_in_bytes;
+	uint32_t                 page_data_size_in_bytes;
+	uint32_t                 page_oob_size_in_bytes;
 
 	/*
 	 * Hook the command function provided by the reference implementation.
@@ -2109,8 +2128,8 @@
 	 * now.
 	 */
 
-	g->saved_command = g->nand.cmdfunc;
-	g->nand.cmdfunc = gpmi_command;
+	g->saved_command = nand->cmdfunc;
+	nand->cmdfunc = gpmi_command;
 
 	/* Identify the NAND Flash devices. */
 
@@ -2121,12 +2140,31 @@
 
 	gpmi_set_timings(g, 0);
 
-	/* Limit to 2G size due to Kernel larger 4G space support */
-	if (g->mtd.size == 0) {
-		g->mtd.size = 1 << 31;
-		g->nand.chipsize = do_div(g->mtd.size, g->nand.numchips);
+	/*
+	 * Compute some important facts about the medium.
+	 *
+	 * Note that we don't yet support a medium of size larger than 2 GiB. If
+	 * we find the physical medium is too large, then we pretend it's
+	 * smaller.
+	 */
+
+	physical_medium_size_in_bytes =
+				nand->numchips * info->chip_size_in_bytes;
+
+	if (physical_medium_size_in_bytes > (2LL*SZ_1G)) {
+		logical_medium_size_in_bytes = 2LL*SZ_1G;
+		logical_chip_size_in_bytes = 2LL*SZ_1G;
+		do_div(logical_chip_size_in_bytes, nand->numchips);
+
+	} else {
+		logical_medium_size_in_bytes = physical_medium_size_in_bytes;
+		logical_chip_size_in_bytes   = info->chip_size_in_bytes;
 	}
 
+	page_data_size_in_bytes = 1 << (fls(info->page_total_size_in_bytes)-1);
+	page_oob_size_in_bytes  = info->page_total_size_in_bytes -
+							page_data_size_in_bytes;
+
 	/*
 	 * In all currently-supported geometries, the number of ECC bytes that
 	 * apply to the OOB bytes is the same.
@@ -2134,59 +2172,72 @@
 
 	g->ecc_oob_bytes = 9;
 
-	/* Look at the page size and configure appropriately. */
+	/* Configure ECC. */
 
-	switch (g->mtd.writesize) {
-	case 2048:		/* 2K page */
-		g->nand.ecc.layout = &gpmi_oob_64;
-		g->nand.ecc.bytes = 9;
+	switch (page_data_size_in_bytes) {
+	case 2048:
+		nand->ecc.layout          = &gpmi_oob_64;
+		nand->ecc.bytes           = 9;
 		g->oob_free = 19;
 		g->hwecc_type_read = GPMI_ECC4_RD;
 		g->hwecc_type_write = GPMI_ECC4_WR;
-		oobsize = 64;
 		break;
 	case 4096:
-		g->nand.ecc.layout = &gpmi_oob_128;
-		g->nand.ecc.bytes = 18;
+		nand->ecc.layout          = &gpmi_oob_128;
+		nand->ecc.bytes           = 18;
 		g->oob_free = 65;
 		g->hwecc_type_read = GPMI_ECC8_RD;
 		g->hwecc_type_write = GPMI_ECC8_WR;
-		oobsize = 218;
 		break;
 	default:
-		printk(KERN_ERR "Unsupported writesize %d.", g->mtd.writesize);
+		printk(KERN_ERR "Unsupported page data size %d.",
+						page_data_size_in_bytes);
+		return -ENXIO;
 		break;
 	}
 
-	g->mtd.ecclayout = g->nand.ecc.layout;
-	/* sanity check */
-	if (oobsize > NAND_MAX_OOBSIZE ||
-					g->mtd.writesize > NAND_MAX_PAGESIZE) {
+	mtd->ecclayout = nand->ecc.layout;
+
+	/* Configure the MTD geometry. */
+
+	mtd->size        = logical_medium_size_in_bytes;
+	mtd->erasesize   = info->block_size_in_pages * page_data_size_in_bytes;
+	mtd->writesize   = page_data_size_in_bytes;
+	mtd->oobavail    = mtd->ecclayout->oobavail;
+	mtd->oobsize     = page_oob_size_in_bytes;
+	mtd->subpage_sft = 0; /* We don't support sub-page writing. */
+
+	/* Configure the struct nand_chip geometry. */
+
+	nand->chipsize         = logical_chip_size_in_bytes;
+	nand->page_shift       = ffs(page_data_size_in_bytes) - 1;
+	nand->pagemask         = (nand->chipsize >> nand->page_shift) - 1;
+	nand->subpagesize      = mtd->writesize >> mtd->subpage_sft;
+	nand->phys_erase_shift = ffs(mtd->erasesize) - 1;
+	nand->bbt_erase_shift  = nand->phys_erase_shift;
+	nand->chip_shift       = ffs(nand->chipsize) - 1;
+
+	/* Sanity check */
+
+	if (mtd->oobsize > NAND_MAX_OOBSIZE ||
+					mtd->writesize > NAND_MAX_PAGESIZE) {
 		printk(KERN_ERR "Internal error. Either page size "
 		       "(%d) > max (%d) "
 		       "or oob size (%d) > max(%d). Sorry.\n",
-		       oobsize, NAND_MAX_OOBSIZE,
-		       g->mtd.writesize, NAND_MAX_PAGESIZE);
+		       mtd->oobsize, NAND_MAX_OOBSIZE,
+		       mtd->writesize, NAND_MAX_PAGESIZE);
 		return -ERANGE;
 	}
 
 	/* Install the ECC. */
 
-	if (oobsize > 0) {
-		g->mtd.oobsize = oobsize;
-		/* otherwise error; oobsize should be set
-		   in valid cases */
-		if (!bch_mode())
-			g->hc = gpmi_ecc_find("ecc8");
-		else
 			g->hc = gpmi_ecc_find("bch");
-		g->hc->setup(g->hc, 0, g->mtd.writesize, g->mtd.oobsize);
-		return 0;
-	}
+	for (index = 0; index < nand->numchips; index++)
+		g->hc->setup(g->hc, index, mtd->writesize, mtd->oobsize);
 
-	/* If control arrives here, something has gone wrong. */
+	/* Return success. */
 
-	return -ENXIO;
+	return 0;
 
 }
 
diff -urNBb -x linux-2.6.31.9-ER1-efikamx/Documentation/dontdiff linux-2.6.31.9-ER1-efikamx.orig/drivers/mtd/nand/gpmi/gpmi-bch.c linux-2.6.31.9-ER1-efikamx/drivers/mtd/nand/gpmi/gpmi-bch.c
--- linux-2.6.31.9-ER1-efikamx.orig/drivers/mtd/nand/gpmi/gpmi-bch.c	2009-12-12 13:16:57.000000000 -0600
+++ linux-2.6.31.9-ER1-efikamx/drivers/mtd/nand/gpmi/gpmi-bch.c	2010-01-07 22:20:54.796954941 -0600
@@ -193,8 +193,8 @@
 
 	switch (writesize) {
 	case 2048:
-		ecc0 = 4;
-		eccn = 4;
+		ecc0 = 8;
+		eccn = 8;
 		metasize = 10;
 		break;
 	case 4096:
@@ -203,7 +203,7 @@
 			eccn = 8;
 		} else {
 			ecc0 = 16;
-			eccn = 14;
+			eccn = 16;
 		}
 
 		metasize = 10;
@@ -220,10 +220,10 @@
 	state->nands[index].ecc0 = ecc0;
 	state->nands[index].eccn = eccn;
 
-	__raw_writel(BF(writesize/512, BCH_FLASH0LAYOUT0_NBLOCKS) |
+	__raw_writel(BF(writesize/512 - 1, BCH_FLASH0LAYOUT0_NBLOCKS) |
 		     BF(metasize, BCH_FLASH0LAYOUT0_META_SIZE) |
 		     BF(ecc0 >> 1, BCH_FLASH0LAYOUT0_ECC0) | /* for oob */
-		     BF(0x00, BCH_FLASH0LAYOUT0_DATA0_SIZE), layout);
+		     BF(512, BCH_FLASH0LAYOUT0_DATA0_SIZE), layout);
 	__raw_writel(BF(writesize + oobsize, BCH_FLASH0LAYOUT1_PAGE_SIZE) |
 		     BF(eccn >> 1, BCH_FLASH0LAYOUT1_ECCN) | /* for dblock */
 		     BF(512, BCH_FLASH0LAYOUT1_DATAN_SIZE), layout + 0x10);
@@ -409,6 +409,8 @@
 		BM_APBH_CHn_CMD_IRQONCMPLT      |
 		BF(BV_APBH_CHn_CMD_COMMAND__NO_DMA_XFER, APBH_CHn_CMD_COMMAND);
 
+	init_completion(&state->nands[index].done);
+
 	return 0;
 }
 
@@ -437,7 +439,7 @@
 	if (err)
 		return err;
 
-	printk(KERN_DEBUG"%s: initialized\n", __func__);
+	printk(KERN_INFO"%s: initialized\n", __func__);
 	return 0;
 }
 
diff -urNBb -x linux-2.6.31.9-ER1-efikamx/Documentation/dontdiff linux-2.6.31.9-ER1-efikamx.orig/drivers/mtd/nand/gpmi/gpmi.h linux-2.6.31.9-ER1-efikamx/drivers/mtd/nand/gpmi/gpmi.h
--- linux-2.6.31.9-ER1-efikamx.orig/drivers/mtd/nand/gpmi/gpmi.h	2009-12-12 13:16:56.000000000 -0600
+++ linux-2.6.31.9-ER1-efikamx/drivers/mtd/nand/gpmi/gpmi.h	2010-01-07 22:20:55.325239019 -0600
@@ -30,7 +30,7 @@
 #include <mach/regs-ecc8.h>
 
 #include "gpmi-hamming-22-16.h"
-#include "nand_device_info.h"
+#include "../nand_device_info.h"
 
 #define GPMI_ECC4_WR \
 	(BM_GPMI_ECCCTRL_ENABLE_ECC | \
diff -urNBb -x linux-2.6.31.9-ER1-efikamx/Documentation/dontdiff linux-2.6.31.9-ER1-efikamx.orig/drivers/mtd/nand/gpmi/Makefile linux-2.6.31.9-ER1-efikamx/drivers/mtd/nand/gpmi/Makefile
--- linux-2.6.31.9-ER1-efikamx.orig/drivers/mtd/nand/gpmi/Makefile	2009-12-12 13:16:55.000000000 -0600
+++ linux-2.6.31.9-ER1-efikamx/drivers/mtd/nand/gpmi/Makefile	2010-01-07 22:20:55.314734886 -0600
@@ -4,4 +4,3 @@
 gpmi-objs += gpmi-hamming-13-8.o
 gpmi-objs += gpmi-bch.o
 gpmi-objs += gpmi-ecc8.o
-gpmi-objs += nand_device_info.o
diff -urNBb -x linux-2.6.31.9-ER1-efikamx/Documentation/dontdiff linux-2.6.31.9-ER1-efikamx.orig/drivers/mtd/nand/gpmi/nand_device_info.c linux-2.6.31.9-ER1-efikamx/drivers/mtd/nand/gpmi/nand_device_info.c
--- linux-2.6.31.9-ER1-efikamx.orig/drivers/mtd/nand/gpmi/nand_device_info.c	2009-12-12 13:16:56.000000000 -0600
+++ linux-2.6.31.9-ER1-efikamx/drivers/mtd/nand/gpmi/nand_device_info.c	1969-12-31 18:00:00.000000000 -0600
@@ -1,2297 +0,0 @@
-/*
- * Copyright 2009 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-
-/*
- * The code contained herein is licensed under the GNU General Public
- * License. You may obtain a copy of the GNU General Public License
- * Version 2 or later at the following locations:
- *
- * http://www.opensource.org/licenses/gpl-license.html
- * http://www.gnu.org/copyleft/gpl.html
- */
-
-#include <asm/sizes.h>
-#include <linux/mtd/nand.h>
-
-#include "nand_device_info.h"
-
-/*
- * Type 2
- */
-static struct nand_device_info nand_device_info_table_type_2[] __initdata =
-{
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0x20,
-	.device_code              = 0xf1,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
-	.chip_size_in_bytes       = 128LL*SZ_1M,
-	.block_size_in_pages      = 64,
-	.page_total_size_in_bytes = 2*SZ_1K + 64,
-	.ecc_strength_in_bits     = 4,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 30,
-	.data_hold_in_ns          = 20,
-	.address_setup_in_ns      = 25,
-	.gpmi_sample_delay_in_ns  = 6,
-	.tREA_in_ns               = -1,
-	.tRLOH_in_ns              = -1,
-	.tRHOH_in_ns              = -1,
-	"NAND01GW3",
-	},
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0xad,
-	.device_code              = 0xf1,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
-	.chip_size_in_bytes       = 128LL*SZ_1M,
-	.block_size_in_pages      = 64,
-	.page_total_size_in_bytes = 2*SZ_1K + 64,
-	.ecc_strength_in_bits     = 4,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 45,
-	.data_hold_in_ns          = 30,
-	.address_setup_in_ns      = 25,
-	.gpmi_sample_delay_in_ns  = 6,
-	.tREA_in_ns               = -1,
-	.tRLOH_in_ns              = -1,
-	.tRHOH_in_ns              = -1,
-	NULL,
-	},
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0x2c,
-	.device_code              = 0xf1,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
-	.chip_size_in_bytes       = 128LL*SZ_1M,
-	.block_size_in_pages      = 64,
-	.page_total_size_in_bytes = 2*SZ_1K + 64,
-	.ecc_strength_in_bits     = 4,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 30,
-	.data_hold_in_ns          = 20,
-	.address_setup_in_ns      = 10,
-	.gpmi_sample_delay_in_ns  = 6,
-	.tREA_in_ns               = -1,
-	.tRLOH_in_ns              = -1,
-	.tRHOH_in_ns              = -1,
-	NULL,
-	},
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0xec,
-	.device_code              = 0xf1,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
-	.chip_size_in_bytes       = 128LL*SZ_1M,
-	.block_size_in_pages      = 64,
-	.page_total_size_in_bytes = 2*SZ_1K + 64,
-	.ecc_strength_in_bits     = 4,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 35,
-	.data_hold_in_ns          = 25,
-	.address_setup_in_ns      = 0,
-	.gpmi_sample_delay_in_ns  = 6,
-	.tREA_in_ns               = -1,
-	.tRLOH_in_ns              = -1,
-	.tRHOH_in_ns              = -1,
-	"K9F1F08",
-	},
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0x98,
-	.device_code              = 0xf1,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
-	.chip_size_in_bytes       = 128LL*SZ_1M,
-	.block_size_in_pages      = 64,
-	.page_total_size_in_bytes = 2*SZ_1K + 64,
-	.ecc_strength_in_bits     = 4,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 30,
-	.data_hold_in_ns          = 20,
-	.address_setup_in_ns      = 0,
-	.gpmi_sample_delay_in_ns  = 6,
-	.tREA_in_ns               = -1,
-	.tRLOH_in_ns              = -1,
-	.tRHOH_in_ns              = -1,
-	"TC58NVG0S3",
-	},
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0x45,
-	.device_code              = 0xf1,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
-	.chip_size_in_bytes       = 128LL*SZ_1M,
-	.block_size_in_pages      = 64,
-	.page_total_size_in_bytes = 2*SZ_1K + 64,
-	.ecc_strength_in_bits     = 4,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 45,
-	.data_hold_in_ns          = 32,
-	.address_setup_in_ns      = 0,
-	.gpmi_sample_delay_in_ns  = 6,
-	.tREA_in_ns               = -1,
-	.tRLOH_in_ns              = -1,
-	.tRHOH_in_ns              = -1,
-	NULL,
-	},
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0x20,
-	.device_code              = 0xda,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
-	.chip_size_in_bytes       = 256LL*SZ_1M,
-	.block_size_in_pages      = 64,
-	.page_total_size_in_bytes = 2*SZ_1K + 64,
-	.ecc_strength_in_bits     = 4,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 20,
-	.data_hold_in_ns          = 30,
-	.address_setup_in_ns      = 0,
-	.gpmi_sample_delay_in_ns  = 6,
-	.tREA_in_ns               = -1,
-	.tRLOH_in_ns              = -1,
-	.tRHOH_in_ns              = -1,
-	"NAND02GW3",
-	},
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0xad,
-	.device_code              = 0xda,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
-	.chip_size_in_bytes       = 256LL*SZ_1M,
-	.block_size_in_pages      = 64,
-	.page_total_size_in_bytes = 2*SZ_1K + 64,
-	.ecc_strength_in_bits     = 4,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 30,
-	.data_hold_in_ns          = 25,
-	.address_setup_in_ns      = 10,
-	.gpmi_sample_delay_in_ns  = 6,
-	.tREA_in_ns               = -1,
-	.tRLOH_in_ns              = -1,
-	.tRHOH_in_ns              = -1,
-	"HY27UF082G2M, HY27UG082G2M, HY27UG082G1M",
-	},
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0x2c,
-	.device_code              = 0xda,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
-	.chip_size_in_bytes       = 256LL*SZ_1M,
-	.block_size_in_pages      = 64,
-	.page_total_size_in_bytes = 2*SZ_1K + 64,
-	.ecc_strength_in_bits     = 4,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 20,
-	.data_hold_in_ns          = 10,
-	.address_setup_in_ns      = 10,
-	.gpmi_sample_delay_in_ns  = 6,
-	.tREA_in_ns               = -1,
-	.tRLOH_in_ns              = -1,
-	.tRHOH_in_ns              = -1,
-	"MT29F2G08",
-	},
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0xec,
-	.device_code              = 0xda,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
-	.chip_size_in_bytes       = 256LL*SZ_1M,
-	.block_size_in_pages      = 64,
-	.page_total_size_in_bytes = 2*SZ_1K + 64,
-	.ecc_strength_in_bits     = 4,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 20,
-	.data_hold_in_ns          = 10,
-	.address_setup_in_ns      = 20,
-	.gpmi_sample_delay_in_ns  = 6,
-	.tREA_in_ns               = -1,
-	.tRLOH_in_ns              = -1,
-	.tRHOH_in_ns              = -1,
-	"K9F2G08U0M",
-	},
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0x98,
-	.device_code              = 0xda,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
-	.chip_size_in_bytes       = 256LL*SZ_1M,
-	.block_size_in_pages      = 64,
-	.page_total_size_in_bytes = 2*SZ_1K + 64,
-	.ecc_strength_in_bits     = 4,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 20,
-	.data_hold_in_ns          = 30,
-	.address_setup_in_ns      = 0,
-	.gpmi_sample_delay_in_ns  = 6,
-	.tREA_in_ns               = -1,
-	.tRLOH_in_ns              = -1,
-	.tRHOH_in_ns              = -1,
-	"TC58NVG1S3",
-	},
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0x45,
-	.device_code              = 0xda,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
-	.chip_size_in_bytes       = 256LL*SZ_1M,
-	.block_size_in_pages      = 64,
-	.page_total_size_in_bytes = 2*SZ_1K + 64,
-	.ecc_strength_in_bits     = 4,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 45,
-	.data_hold_in_ns          = 32,
-	.address_setup_in_ns      = 0,
-	.gpmi_sample_delay_in_ns  = 6,
-	.tREA_in_ns               = -1,
-	.tRLOH_in_ns              = -1,
-	.tRHOH_in_ns              = -1,
-	NULL,
-	},
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0x20,
-	.device_code              = 0xdc,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
-	.chip_size_in_bytes       = 512LL*SZ_1M,
-	.block_size_in_pages      = 64,
-	.page_total_size_in_bytes = 2*SZ_1K + 64,
-	.ecc_strength_in_bits     = 4,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 45,
-	.data_hold_in_ns          = 30,
-	.address_setup_in_ns      = 10,
-	.gpmi_sample_delay_in_ns  = 6,
-	.tREA_in_ns               = -1,
-	.tRLOH_in_ns              = -1,
-	.tRHOH_in_ns              = -1,
-	NULL,
-	},
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0xad,
-	.device_code              = 0xdc,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
-	.chip_size_in_bytes       = 512LL*SZ_1M,
-	.block_size_in_pages      = 64,
-	.page_total_size_in_bytes = 2*SZ_1K + 64,
-	.ecc_strength_in_bits     = 4,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 45,
-	.data_hold_in_ns          = 30,
-	.address_setup_in_ns      = 10,
-	.gpmi_sample_delay_in_ns  = 10,
-	.tREA_in_ns               = -1,
-	.tRLOH_in_ns              = -1,
-	.tRHOH_in_ns              = -1,
-	"HY27UH084G2M, HY27UG084G2M, HY27UH084G1M",
-	},
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0x2c,
-	.device_code              = 0xdc,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
-	.chip_size_in_bytes       = 512LL*SZ_1M,
-	.block_size_in_pages      = 64,
-	.page_total_size_in_bytes = 2*SZ_1K + 64,
-	.ecc_strength_in_bits     = 4,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 20,
-	.data_hold_in_ns          = 10,
-	.address_setup_in_ns      = 10,
-	.gpmi_sample_delay_in_ns  = 6,
-	.tREA_in_ns               = -1,
-	.tRLOH_in_ns              = -1,
-	.tRHOH_in_ns              = -1,
-	"MT29F4G08",
-	},
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0xec,
-	.device_code              = 0xdc,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
-	.chip_size_in_bytes       = 512LL*SZ_1M,
-	.block_size_in_pages      = 64,
-	.page_total_size_in_bytes = 2*SZ_1K + 64,
-	.ecc_strength_in_bits     = 4,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 25,
-	.data_hold_in_ns          = 25,
-	.address_setup_in_ns      = 20,
-	.gpmi_sample_delay_in_ns  = 6,
-	.tREA_in_ns               = -1,
-	.tRLOH_in_ns              = -1,
-	.tRHOH_in_ns              = -1,
-	NULL,
-	},
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0x98,
-	.device_code              = 0xdc,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
-	.chip_size_in_bytes       = 512LL*SZ_1M,
-	.block_size_in_pages      = 64,
-	.page_total_size_in_bytes = 2*SZ_1K + 64,
-	.ecc_strength_in_bits     = 4,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 25,
-	.data_hold_in_ns          = 25,
-	.address_setup_in_ns      = 0,
-	.gpmi_sample_delay_in_ns  = 6,
-	.tREA_in_ns               = -1,
-	.tRLOH_in_ns              = -1,
-	.tRHOH_in_ns              = -1,
-	"TH58NVG2S3",
-	},
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0x45,
-	.device_code              = 0xdc,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
-	.chip_size_in_bytes       = 512LL*SZ_1M,
-	.block_size_in_pages      = 64,
-	.page_total_size_in_bytes = 2*SZ_1K + 64,
-	.ecc_strength_in_bits     = 4,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 45,
-	.data_hold_in_ns          = 32,
-	.address_setup_in_ns      = 0,
-	.gpmi_sample_delay_in_ns  = 6,
-	.tREA_in_ns               = -1,
-	.tRLOH_in_ns              = -1,
-	.tRHOH_in_ns              = -1,
-	NULL,
-	},
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0xad,
-	.device_code              = 0xd3,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
-	.chip_size_in_bytes       = 1LL*SZ_1G,
-	.block_size_in_pages      = 64,
-	.page_total_size_in_bytes = 2*SZ_1K + 64,
-	.ecc_strength_in_bits     = 4,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 30,
-	.data_hold_in_ns          = 25,
-	.address_setup_in_ns      = 20,
-	.gpmi_sample_delay_in_ns  = 6,
-	.tREA_in_ns               = -1,
-	.tRLOH_in_ns              = -1,
-	.tRHOH_in_ns              = -1,
-	"HY27UH088G2M",
-	},
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0x20,
-	.device_code              = 0xd3,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
-	.chip_size_in_bytes       = 1LL*SZ_1G,
-	.block_size_in_pages      = 64,
-	.page_total_size_in_bytes = 2*SZ_1K + 64,
-	.ecc_strength_in_bits     = 4,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 45,
-	.data_hold_in_ns          = 30,
-	.address_setup_in_ns      = 10,
-	.gpmi_sample_delay_in_ns  = 6,
-	.tREA_in_ns               = -1,
-	.tRLOH_in_ns              = -1,
-	.tRHOH_in_ns              = -1,
-	"NAND08GW3BxANx",
-	},
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0x2c,
-	.device_code              = 0xd3,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
-	.chip_size_in_bytes       = 1LL*SZ_1G,
-	.block_size_in_pages      = 64,
-	.page_total_size_in_bytes = 2*SZ_1K + 64,
-	.ecc_strength_in_bits     = 4,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 25,
-	.data_hold_in_ns          = 15,
-	.address_setup_in_ns      = 10,
-	.gpmi_sample_delay_in_ns  = 6,
-	.tREA_in_ns               = -1,
-	.tRLOH_in_ns              = -1,
-	.tRHOH_in_ns              = -1,
-	"MT29F8G08FABWG",
-	},
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0x98,
-	.device_code              = 0xd3,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
-	.chip_size_in_bytes       = 1LL*SZ_1G,
-	.block_size_in_pages      = 64,
-	.page_total_size_in_bytes = 2*SZ_1K + 64,
-	.ecc_strength_in_bits     = 4,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 45,
-	.data_hold_in_ns          = 32,
-	.address_setup_in_ns      = 0,
-	.gpmi_sample_delay_in_ns  = 6,
-	.tREA_in_ns               = -1,
-	.tRLOH_in_ns              = -1,
-	.tRHOH_in_ns              = -1,
-	NULL,
-	},
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0x20,
-	.device_code              = 0xd5,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
-	.chip_size_in_bytes       = 2LL*SZ_1G,
-	.block_size_in_pages      = 64,
-	.page_total_size_in_bytes = 2*SZ_1K + 64,
-	.ecc_strength_in_bits     = 4,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 45,
-	.data_hold_in_ns          = 30,
-	.address_setup_in_ns      = 10,
-	.gpmi_sample_delay_in_ns  = 6,
-	.tREA_in_ns               = -1,
-	.tRLOH_in_ns              = -1,
-	.tRHOH_in_ns              = -1,
-	NULL,
-	},
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0xad,
-	.device_code              = 0xd5,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
-	.chip_size_in_bytes       = 2LL*SZ_1G,
-	.block_size_in_pages      = 64,
-	.page_total_size_in_bytes = 2*SZ_1K + 64,
-	.ecc_strength_in_bits     = 4,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 25,
-	.data_hold_in_ns          = 30,
-	.address_setup_in_ns      = 10,
-	.gpmi_sample_delay_in_ns  = 6,
-	.tREA_in_ns               = -1,
-	.tRLOH_in_ns              = -1,
-	.tRHOH_in_ns              = -1,
-	NULL,
-	},
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0x2c,
-	.device_code              = 0xd5,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
-	.chip_size_in_bytes       = 2LL*SZ_1G,
-	.block_size_in_pages      = 64,
-	.page_total_size_in_bytes = 2*SZ_1K + 64,
-	.ecc_strength_in_bits     = 4,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 45,
-	.data_hold_in_ns          = 32,
-	.address_setup_in_ns      = 0,
-	.gpmi_sample_delay_in_ns  = 6,
-	.tREA_in_ns               = -1,
-	.tRLOH_in_ns              = -1,
-	.tRHOH_in_ns              = -1,
-	NULL,
-	},
-	{true}
-};
-
-/*
- * Large MLC
- */
-static struct nand_device_info nand_device_info_table_large_mlc[] __initdata =
-{
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0x98,
-	.device_code              = 0xda,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
-	.chip_size_in_bytes       = 256LL*SZ_1M,
-	.block_size_in_pages      = 128,
-	.page_total_size_in_bytes = 2*SZ_1K + 64,
-	.ecc_strength_in_bits     = 4,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 20,
-	.data_hold_in_ns          = 30,
-	.address_setup_in_ns      = 0,
-	.gpmi_sample_delay_in_ns  = 6,
-	.tREA_in_ns               = -1,
-	.tRLOH_in_ns              = -1,
-	.tRHOH_in_ns              = -1,
-	"TC58NVG1D4BFT00",
-	},
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0x45,
-	.device_code              = 0xda,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
-	.chip_size_in_bytes       = 256LL*SZ_1M,
-	.block_size_in_pages      = 128,
-	.page_total_size_in_bytes = 2*SZ_1K + 64,
-	.ecc_strength_in_bits     = 4,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 20,
-	.data_hold_in_ns          = 30,
-	.address_setup_in_ns      = 0,
-	.gpmi_sample_delay_in_ns  = 6,
-	.tREA_in_ns               = -1,
-	.tRLOH_in_ns              = -1,
-	.tRHOH_in_ns              = -1,
-	NULL,
-	},
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0x45,
-	.device_code              = 0xdc,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
-	.chip_size_in_bytes       = 512LL*SZ_1M,
-	.block_size_in_pages      = 128,
-	.page_total_size_in_bytes = 2*SZ_1K + 64,
-	.ecc_strength_in_bits     = 4,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 20,
-	.data_hold_in_ns          = 30,
-	.address_setup_in_ns      = 0,
-	.gpmi_sample_delay_in_ns  = 6,
-	.tREA_in_ns               = -1,
-	.tRLOH_in_ns              = -1,
-	.tRHOH_in_ns              = -1,
-	NULL,
-	},
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0x98,
-	.device_code              = 0xd3,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
-	.chip_size_in_bytes       = 1LL*SZ_1G,
-	.block_size_in_pages      = 128,
-	.page_total_size_in_bytes = 2*SZ_1K + 64,
-	.ecc_strength_in_bits     = 4,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 35,
-	.data_hold_in_ns          = 30,
-	.address_setup_in_ns      = 0,
-	.gpmi_sample_delay_in_ns  = 6,
-	.tREA_in_ns               = -1,
-	.tRLOH_in_ns              = -1,
-	.tRHOH_in_ns              = -1,
-	"TH58NVG3D4xFT00",
-	},
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0x45,
-	.device_code              = 0xd3,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
-	.chip_size_in_bytes       = 1LL*SZ_1G,
-	.block_size_in_pages      = 128,
-	.page_total_size_in_bytes = 2*SZ_1K + 64,
-	.ecc_strength_in_bits     = 4,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 35,
-	.data_hold_in_ns          = 20,
-	.address_setup_in_ns      = 0,
-	.gpmi_sample_delay_in_ns  = 6,
-	.tREA_in_ns               = -1,
-	.tRLOH_in_ns              = -1,
-	.tRHOH_in_ns              = -1,
-	NULL,
-	},
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0x98,
-	.device_code              = 0xd5,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
-	.chip_size_in_bytes       = 2LL*SZ_1G,
-	.block_size_in_pages      = 128,
-	.page_total_size_in_bytes = 2*SZ_1K + 64,
-	.ecc_strength_in_bits     = 4,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 35,
-	.data_hold_in_ns          = 15,
-	.address_setup_in_ns      = 0,
-	.gpmi_sample_delay_in_ns  = 6,
-	.tREA_in_ns               = -1,
-	.tRLOH_in_ns              = -1,
-	.tRHOH_in_ns              = -1,
-	"TH58NVG4D4xFT00",
-	},
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0x45,
-	.device_code              = 0xd5,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
-	.chip_size_in_bytes       = 2LL*SZ_1G,
-	.block_size_in_pages      = 128,
-	.page_total_size_in_bytes = 2*SZ_1K + 64,
-	.ecc_strength_in_bits     = 4,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 35,
-	.data_hold_in_ns          = 15,
-	.address_setup_in_ns      = 0,
-	.gpmi_sample_delay_in_ns  = 6,
-	.tREA_in_ns               = -1,
-	.tRLOH_in_ns              = -1,
-	.tRHOH_in_ns              = -1,
-	NULL,
-	},
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0x98,
-	.device_code              = 0xdc,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
-	.chip_size_in_bytes       = 512LL*SZ_1M,
-	.block_size_in_pages      = 128,
-	.page_total_size_in_bytes = 2*SZ_1K + 64,
-	.ecc_strength_in_bits     = 4,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 20,
-	.data_hold_in_ns          = 30,
-	.address_setup_in_ns      = 0,
-	.gpmi_sample_delay_in_ns  = 6,
-	.tREA_in_ns               = -1,
-	.tRLOH_in_ns              = -1,
-	.tRHOH_in_ns              = -1,
-	"TC58NVG2D4BFT00",
-	},
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0xec,
-	.device_code              = 0xdc,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
-	.chip_size_in_bytes       = 512LL*SZ_1M,
-	.block_size_in_pages      = 128,
-	.page_total_size_in_bytes = 2*SZ_1K + 64,
-	.ecc_strength_in_bits     = 4,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 25,
-	.data_hold_in_ns          = 15,
-	.address_setup_in_ns      = 25,
-	.gpmi_sample_delay_in_ns  = 6,
-	.tREA_in_ns               = -1,
-	.tRLOH_in_ns              = -1,
-	.tRHOH_in_ns              = -1,
-	"K9G4G08U0M",
-	},
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0xad,
-	.device_code              = 0xdc,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
-	.chip_size_in_bytes       = 512LL*SZ_1M,
-	.block_size_in_pages      = 128,
-	.page_total_size_in_bytes = 2*SZ_1K + 64,
-	.ecc_strength_in_bits     = 4,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 45,
-	.data_hold_in_ns          = 25,
-	.address_setup_in_ns      = 50,
-	.gpmi_sample_delay_in_ns  = 6,
-	.tREA_in_ns               = -1,
-	.tRLOH_in_ns              = -1,
-	.tRHOH_in_ns              = -1,
-	"HY27UT084G2M, HY27UU088G5M",
-	},
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0x20,
-	.device_code              = 0xdc,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
-	.chip_size_in_bytes       = 512LL*SZ_1M,
-	.block_size_in_pages      = 128,
-	.page_total_size_in_bytes = 2*SZ_1K + 64,
-	.ecc_strength_in_bits     = 4,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 40,
-	.data_hold_in_ns          = 20,
-	.address_setup_in_ns      = 30,
-	.gpmi_sample_delay_in_ns  = 6,
-	.tREA_in_ns               = -1,
-	.tRLOH_in_ns              = -1,
-	.tRHOH_in_ns              = -1,
-	"NAND04GW3C2AN1E",
-	},
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0xec,
-	.device_code              = 0xd3,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
-	.chip_size_in_bytes       = 1LL*SZ_1G,
-	.block_size_in_pages      = 128,
-	.page_total_size_in_bytes = 2*SZ_1K + 64,
-	.ecc_strength_in_bits     = 4,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 20,
-	.data_hold_in_ns          = 15,
-	.address_setup_in_ns      = 20,
-	.gpmi_sample_delay_in_ns  = 6,
-	.tREA_in_ns               = -1,
-	.tRLOH_in_ns              = -1,
-	.tRHOH_in_ns              = -1,
-	"K9G8G08U0M, K9HAG08U1M",
-	},
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0xad,
-	.device_code              = 0xd3,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
-	.chip_size_in_bytes       = 1LL*SZ_1G,
-	.block_size_in_pages      = 128,
-	.page_total_size_in_bytes = 2*SZ_1K + 64,
-	.ecc_strength_in_bits     = 4,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 60,
-	.data_hold_in_ns          = 30,
-	.address_setup_in_ns      = 50,
-	.gpmi_sample_delay_in_ns  = 6,
-	.tREA_in_ns               = -1,
-	.tRLOH_in_ns              = -1,
-	.tRHOH_in_ns              = -1,
-	"HY27UV08AG5M",
-	},
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0x2c,
-	.device_code              = 0xd3,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
-	.chip_size_in_bytes       = 1LL*SZ_1G,
-	.block_size_in_pages      = 128,
-	.page_total_size_in_bytes = 2*SZ_1K + 64,
-	.ecc_strength_in_bits     = 4,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 15,
-	.data_hold_in_ns          = 15,
-	.address_setup_in_ns      = 15,
-	.gpmi_sample_delay_in_ns  = 6,
-	.tREA_in_ns               = -1,
-	.tRLOH_in_ns              = -1,
-	.tRHOH_in_ns              = -1,
-	"Intel JS29F08G08AAMiB1 and Micron MT29F8G08MAA; "
-	"Intel JS29F08G08CAMiB1 and Micron MT29F16G08QAA",
-	},
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0xec,
-	.device_code              = 0xd5,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
-	.chip_size_in_bytes       = 2LL*SZ_1G,
-	.block_size_in_pages      = 128,
-	.page_total_size_in_bytes = 2*SZ_1K + 64,
-	.ecc_strength_in_bits     = 4,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 20,
-	.data_hold_in_ns          = 15,
-	.address_setup_in_ns      = 20,
-	.gpmi_sample_delay_in_ns  = 6,
-	.tREA_in_ns               = -1,
-	.tRLOH_in_ns              = -1,
-	.tRHOH_in_ns              = -1,
-	"K9LAG08U0M K9HBG08U1M K9GAG08U0M",
-	},
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0x2c,
-	.device_code              = 0xd5,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
-	.chip_size_in_bytes       = 2LL*SZ_1G,
-	.block_size_in_pages      = 128,
-	.page_total_size_in_bytes = 2*SZ_1K + 64,
-	.ecc_strength_in_bits     = 4,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 15,
-	.data_hold_in_ns          = 10,
-	.address_setup_in_ns      = 15,
-	.gpmi_sample_delay_in_ns  = 6,
-	.tREA_in_ns               = -1,
-	.tRLOH_in_ns              = -1,
-	.tRHOH_in_ns              = -1,
-	"Intel JS29F32G08FAMiB1 and Micron MT29F32G08TAA",
-	},
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0x2c,
-	.device_code              = 0xdc,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
-	.chip_size_in_bytes       = 512LL*SZ_1M,
-	.block_size_in_pages      = 128,
-	.page_total_size_in_bytes = 2*SZ_1K + 64,
-	.ecc_strength_in_bits     = 4,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 20,
-	.data_hold_in_ns          = 20,
-	.address_setup_in_ns      = 20,
-	.gpmi_sample_delay_in_ns  = 6,
-	.tREA_in_ns               = -1,
-	.tRLOH_in_ns              = -1,
-	.tRHOH_in_ns              = -1,
-	"MT29F4G08",
-	},
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0x89,
-	.device_code              = 0xd3,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
-	.chip_size_in_bytes       = 1LL*SZ_1G,
-	.block_size_in_pages      = 128,
-	.page_total_size_in_bytes = 2*SZ_1K + 64,
-	.ecc_strength_in_bits     = 4,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 15,
-	.data_hold_in_ns          = 10,
-	.address_setup_in_ns      = 15,
-	.gpmi_sample_delay_in_ns  = 6,
-	.tREA_in_ns               = -1,
-	.tRLOH_in_ns              = -1,
-	.tRHOH_in_ns              = -1,
-	"JS29F08G08AAMiB2, JS29F08G08CAMiB2",
-	},
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0x89,
-	.device_code              = 0xd5,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
-	.chip_size_in_bytes       = 2LL*SZ_1G,
-	.block_size_in_pages      = 128,
-	.page_total_size_in_bytes = 2*SZ_1K + 64,
-	.ecc_strength_in_bits     = 4,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 15,
-	.data_hold_in_ns          = 10,
-	.address_setup_in_ns      = 15,
-	.gpmi_sample_delay_in_ns  = 6,
-	.tREA_in_ns               = -1,
-	.tRLOH_in_ns              = -1,
-	.tRHOH_in_ns              = -1,
-	"JS29F32G08FAMiB2",
-	},
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0xad,
-	.device_code              = 0xd5,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
-	.chip_size_in_bytes       = 2LL*SZ_1G,
-	.block_size_in_pages      = 128,
-	.page_total_size_in_bytes = 2*SZ_1K + 64,
-	.ecc_strength_in_bits     = 4,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 15,
-	.data_hold_in_ns          = 10,
-	.address_setup_in_ns      = 20,
-	.gpmi_sample_delay_in_ns  = 6,
-	.tREA_in_ns               = -1,
-	.tRLOH_in_ns              = -1,
-	.tRHOH_in_ns              = -1,
-	"HY27UW08CGFM",
-	},
-	{true}
-};
-
-/*
- * Type 7
- */
-static struct nand_device_info nand_device_info_table_type_7[] __initdata =
-{
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0x2c,
-	.device_code              = 0xd3,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
-	.chip_size_in_bytes       = 1LL*SZ_1G,
-	.block_size_in_pages      = 64,
-	.page_total_size_in_bytes = 2*SZ_1K + 64,
-	.ecc_strength_in_bits     = 4,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 25,
-	.data_hold_in_ns          = 15,
-	.address_setup_in_ns      = 10,
-	.gpmi_sample_delay_in_ns  = 6,
-	.tREA_in_ns               = -1,
-	.tRLOH_in_ns              = -1,
-	.tRHOH_in_ns              = -1,
-	"MT29F8G08FABWG",
-	},
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0x2c,
-	.device_code              = 0xdc,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
-	.chip_size_in_bytes       = 512LL*SZ_1M,
-	.block_size_in_pages      = 64,
-	.page_total_size_in_bytes = 2*SZ_1K + 64,
-	.ecc_strength_in_bits     = 4,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 20,
-	.data_hold_in_ns          = 10,
-	.address_setup_in_ns      = 10,
-	.gpmi_sample_delay_in_ns  = 6,
-	.tREA_in_ns               = -1,
-	.tRLOH_in_ns              = -1,
-	.tRHOH_in_ns              = -1,
-	"MT29F4G08AAA",
-	},
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0xec,
-	.device_code              = 0xdc,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
-	.chip_size_in_bytes       = 512LL*SZ_1M,
-	.block_size_in_pages      = 64,
-	.page_total_size_in_bytes = 2*SZ_1K + 64,
-	.ecc_strength_in_bits     = 4,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 15,
-	.data_hold_in_ns          = 12,
-	.address_setup_in_ns      = 25,
-	.gpmi_sample_delay_in_ns  = 6,
-	.tREA_in_ns               = -1,
-	.tRLOH_in_ns              = -1,
-	.tRHOH_in_ns              = -1,
-	"K9F4G08",
-	},
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0xec,
-	.device_code              = 0xd3,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
-	.chip_size_in_bytes       = 1LL*SZ_1G,
-	.block_size_in_pages      = 64,
-	.page_total_size_in_bytes = 2*SZ_1K + 64,
-	.ecc_strength_in_bits     = 4,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 25,
-	.data_hold_in_ns          = 15,
-	.address_setup_in_ns      = 35,
-	.gpmi_sample_delay_in_ns  = 6,
-	.tREA_in_ns               = -1,
-	.tRLOH_in_ns              = -1,
-	.tRHOH_in_ns              = -1,
-	"K9K8G08UXM, K9NBG08U5A, K9WAG08U1A",
-	},
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0xec,
-	.device_code              = 0xd5,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
-	.chip_size_in_bytes       = 2LL*SZ_1G,
-	.block_size_in_pages      = 64,
-	.page_total_size_in_bytes = 2*SZ_1K + 64,
-	.ecc_strength_in_bits     = 4,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 15,
-	.data_hold_in_ns          = 12,
-	.address_setup_in_ns      = 25,
-	.gpmi_sample_delay_in_ns  = 6,
-	.tREA_in_ns               = -1,
-	.tRLOH_in_ns              = -1,
-	.tRHOH_in_ns              = -1,
-	"K9WAG08UXM",
-	},
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0xec,
-	.device_code              = 0xda,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
-	.chip_size_in_bytes       = 256LL*SZ_1M,
-	.block_size_in_pages      = 64,
-	.page_total_size_in_bytes = 2*SZ_1K + 64,
-	.ecc_strength_in_bits     = 4,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 20,
-	.data_hold_in_ns          = 10,
-	.address_setup_in_ns      = 20,
-	.gpmi_sample_delay_in_ns  = 6,
-	.tREA_in_ns               = -1,
-	.tRLOH_in_ns              = -1,
-	.tRHOH_in_ns              = -1,
-	"K9F2G08U0A",
-	},
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0xec,
-	.device_code              = 0xf1,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
-	.chip_size_in_bytes       = 128LL*SZ_1M,
-	.block_size_in_pages      = 64,
-	.page_total_size_in_bytes = 2*SZ_1K + 64,
-	.ecc_strength_in_bits     = 4,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 15,
-	.data_hold_in_ns          = 12,
-	.address_setup_in_ns      = 20,
-	.gpmi_sample_delay_in_ns  = 6,
-	.tREA_in_ns               = -1,
-	.tRLOH_in_ns              = -1,
-	.tRHOH_in_ns              = -1,
-	"K9F1F08",
-	},
-	{true}
-};
-
-/*
- * Type 8
- */
-static struct nand_device_info nand_device_info_table_type_8[] __initdata =
-{
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0xec,
-	.device_code              = 0xd5,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
-	.chip_size_in_bytes       = 2LL*SZ_1G,
-	.block_size_in_pages      = 128,
-	.page_total_size_in_bytes = 4*SZ_1K + 128,
-	.ecc_strength_in_bits     = 4,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 15,
-	.data_hold_in_ns          = 10,
-	.address_setup_in_ns      = 20,
-	.gpmi_sample_delay_in_ns  = 6,
-	.tREA_in_ns               = -1,
-	.tRLOH_in_ns              = -1,
-	.tRHOH_in_ns              = -1,
-	"K9GAG08U0M",
-	},
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0xec,
-	.device_code              = 0xd7,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
-	.chip_size_in_bytes       = 4LL*SZ_1G,
-	.block_size_in_pages      = 128,
-	.page_total_size_in_bytes = 4*SZ_1K + 128,
-	.ecc_strength_in_bits     = 4,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 15,
-	.data_hold_in_ns          = 15,
-	.address_setup_in_ns      = 25,
-	.gpmi_sample_delay_in_ns  = 6,
-	.tREA_in_ns               = -1,
-	.tRLOH_in_ns              = -1,
-	.tRHOH_in_ns              = -1,
-	"K9LBG08U0M (32Gb), K9HCG08U1M (64Gb), K9MDG08U5M (128Gb)",
-	},
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0xad,
-	.device_code              = 0xd5,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
-	.chip_size_in_bytes       = 2LL*SZ_1G,
-	.block_size_in_pages      = 128,
-	.page_total_size_in_bytes = 4*SZ_1K + 128,
-	.ecc_strength_in_bits     = 4,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 20,
-	.data_hold_in_ns          = 20,
-	.address_setup_in_ns      = 20,
-	.gpmi_sample_delay_in_ns  = 0,
-	.tREA_in_ns               = -1,
-	.tRLOH_in_ns              = -1,
-	.tRHOH_in_ns              = -1,
-	"H27UAG, H27UBG",
-	},
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0xad,
-	.device_code              = 0xd7,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
-	.chip_size_in_bytes       = 4LL*SZ_1G,
-	.block_size_in_pages      = 128,
-	.page_total_size_in_bytes = 4*SZ_1K + 128,
-	.ecc_strength_in_bits     = 4,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 23,
-	.data_hold_in_ns          = 20,
-	.address_setup_in_ns      = 25,
-	.gpmi_sample_delay_in_ns  = 0,
-	.tREA_in_ns               = -1,
-	.tRLOH_in_ns              = -1,
-	.tRHOH_in_ns              = -1,
-	"H27UCG",
-	},
-	{true}
-};
-
-/*
- * Type 9
- */
-static struct nand_device_info nand_device_info_table_type_9[] __initdata =
-{
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0x98,
-	.device_code              = 0xd3,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
-	.chip_size_in_bytes       = 1LL*SZ_1G,
-	.block_size_in_pages      = 128,
-	.page_total_size_in_bytes = 4*SZ_1K + 218,
-	.ecc_strength_in_bits     = 8,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 15,
-	.data_hold_in_ns          = 15,
-	.address_setup_in_ns      = 10,
-	.gpmi_sample_delay_in_ns  = 6,
-	.tREA_in_ns               = -1,
-	.tRLOH_in_ns              = -1,
-	.tRHOH_in_ns              = -1,
-	"TC58NVG3D1DTG00",
-	},
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0x98,
-	.device_code              = 0xd5,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
-	.chip_size_in_bytes       = 2LL*SZ_1G,
-	.block_size_in_pages      = 128,
-	.page_total_size_in_bytes = 4*SZ_1K + 218,
-	.ecc_strength_in_bits     = 8,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 15,
-	.data_hold_in_ns          = 15,
-	.address_setup_in_ns      = 10,
-	.gpmi_sample_delay_in_ns  = 6,
-	.tREA_in_ns               = -1,
-	.tRLOH_in_ns              = -1,
-	.tRHOH_in_ns              = -1,
-	"TC58NVG4D1DTG00",
-	},
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0x98,
-	.device_code              = 0xd7,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
-	.chip_size_in_bytes       = 4LL*SZ_1G,
-	.block_size_in_pages      = 128,
-	.page_total_size_in_bytes = 4*SZ_1K + 218,
-	.ecc_strength_in_bits     = 8,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 15,
-	.data_hold_in_ns          = 15,
-	.address_setup_in_ns      = 10,
-	.gpmi_sample_delay_in_ns  = 6,
-	.tREA_in_ns               = -1,
-	.tRLOH_in_ns              = -1,
-	.tRHOH_in_ns              = -1,
-	"TH58NVG6D1DTG20",
-	},
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0x89,
-	.device_code              = 0xd5,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
-	.chip_size_in_bytes       = 2LL*SZ_1G,
-	.block_size_in_pages      = 128,
-	.page_total_size_in_bytes = 4*SZ_1K + 218,
-	.ecc_strength_in_bits     = 8,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 10,
-	.data_hold_in_ns          = 10,
-	.address_setup_in_ns      = 15,
-	.gpmi_sample_delay_in_ns  = 6,
-	.tREA_in_ns               = -1,
-	.tRLOH_in_ns              = -1,
-	.tRHOH_in_ns              = -1,
-	"JS29F16G08AAMC1, JS29F32G08CAMC1",
-	},
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0x2c,
-	.device_code              = 0xd5,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
-	.chip_size_in_bytes       = 2LL*SZ_1G,
-	.block_size_in_pages      = 128,
-	.page_total_size_in_bytes = 4*SZ_1K + 218,
-	.ecc_strength_in_bits     = 8,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 15,
-	.data_hold_in_ns          = 10,
-	.address_setup_in_ns      = 15,
-	.gpmi_sample_delay_in_ns  = 6,
-	.tREA_in_ns               = -1,
-	.tRLOH_in_ns              = -1,
-	.tRHOH_in_ns              = -1,
-	"MT29F16G08MAA, MT29F32G08QAA",
-	},
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0x2c,
-	.device_code              = 0xd7,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
-	.chip_size_in_bytes       = 4LL*SZ_1G,
-	.block_size_in_pages      = 128,
-	.page_total_size_in_bytes = 4*SZ_1K + 218,
-	.ecc_strength_in_bits     = 8,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 15,
-	.data_hold_in_ns          = 10,
-	.address_setup_in_ns      = 15,
-	.gpmi_sample_delay_in_ns  = 6,
-	.tREA_in_ns               = -1,
-	.tRLOH_in_ns              = -1,
-	.tRHOH_in_ns              = -1,
-	"MT29F64G08TAA (32Gb), MT29F32G08CBAAA (32Gb) MT29F64G08CFAAA (64Gb)",
-	},
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0x2c,
-	.device_code              = 0xd9,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
-	.chip_size_in_bytes       = 8LL*SZ_1G,
-	.block_size_in_pages      = 128,
-	.page_total_size_in_bytes = 4*SZ_1K + 218,
-	.ecc_strength_in_bits     = 8,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 10,
-	.data_hold_in_ns          = 10,
-	.address_setup_in_ns      = 15,
-	.gpmi_sample_delay_in_ns  = 6,
-	.tREA_in_ns               = -1,
-	.tRLOH_in_ns              = -1,
-	.tRHOH_in_ns              = -1,
-	"MT29F128G08CJAAA",
-	},
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0x89,
-	.device_code              = 0xd7,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
-	.chip_size_in_bytes       = 4LL*SZ_1G,
-	.block_size_in_pages      = 128,
-	.page_total_size_in_bytes = 4*SZ_1K + 218,
-	.ecc_strength_in_bits     = 8,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 10,
-	.data_hold_in_ns          = 10,
-	.address_setup_in_ns      = 15,
-	.gpmi_sample_delay_in_ns  = 6,
-	.tREA_in_ns               = -1,
-	.tRLOH_in_ns              = -1,
-	.tRHOH_in_ns              = -1,
-	"JSF64G08FAMC1",
-	},
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0xec,
-	.device_code              = 0xd7,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
-	.chip_size_in_bytes       = 4LL*SZ_1G,
-	.block_size_in_pages      = 128,
-	.page_total_size_in_bytes = 4*SZ_1K + 218,
-	.ecc_strength_in_bits     = 8,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 20,
-	.data_hold_in_ns          = 10,
-	.address_setup_in_ns      = 25,
-	.gpmi_sample_delay_in_ns  = 6,
-	.tREA_in_ns               = -1,
-	.tRLOH_in_ns              = -1,
-	.tRHOH_in_ns              = -1,
-	"K9LBG08U0D",
-	},
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0xec,
-	.device_code              = 0xd5,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
-	.chip_size_in_bytes       = 2LL*SZ_1G,
-	.block_size_in_pages      = 128,
-	.page_total_size_in_bytes = 4*SZ_1K + 218,
-	.ecc_strength_in_bits     = 8,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 20,
-	.data_hold_in_ns          = 10,
-	.address_setup_in_ns      = 20,
-	.gpmi_sample_delay_in_ns  = 6,
-	.tREA_in_ns               = -1,
-	.tRLOH_in_ns              = -1,
-	.tRHOH_in_ns              = -1,
-	"K9GAG08U0D, K9LBG08U1D, K9HCG08U5D",
-	},
-	{true}
-};
-
-/*
- * Type 10
- */
-static struct nand_device_info nand_device_info_table_type_10[] __initdata =
-{
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0xec,
-	.device_code              = 0xd3,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
-	.chip_size_in_bytes       = 1LL*SZ_1G,
-	.block_size_in_pages      = 64,
-	.page_total_size_in_bytes = 4*SZ_1K + 128,
-	.ecc_strength_in_bits     = 4,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 15,
-	.data_hold_in_ns          = 10,
-	.address_setup_in_ns      = 20,
-	.gpmi_sample_delay_in_ns  = 6,
-	.tREA_in_ns               = -1,
-	.tRLOH_in_ns              = -1,
-	.tRHOH_in_ns              = -1,
-	NULL,
-	},
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0xec,
-	.device_code              = 0xd5,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
-	.chip_size_in_bytes       = 2LL*SZ_1G,
-	.block_size_in_pages      = 64,
-	.page_total_size_in_bytes = 4*SZ_1K + 128,
-	.ecc_strength_in_bits     = 4,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 25,
-	.data_hold_in_ns          = 15,
-	.address_setup_in_ns      = 30,
-	.gpmi_sample_delay_in_ns  = 6,
-	.tREA_in_ns               = -1,
-	.tRLOH_in_ns              = -1,
-	.tRHOH_in_ns              = -1,
-	"K9NCG08U5M",
-	},
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0xec,
-	.device_code              = 0xd7,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
-	.chip_size_in_bytes       = 4LL*SZ_1G,
-	.block_size_in_pages      = 64,
-	.page_total_size_in_bytes = 4*SZ_1K + 128,
-	.ecc_strength_in_bits     = 4,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 15,
-	.data_hold_in_ns          = 15,
-	.address_setup_in_ns      = 25,
-	.gpmi_sample_delay_in_ns  = 6,
-	.tREA_in_ns               = -1,
-	.tRLOH_in_ns              = -1,
-	.tRHOH_in_ns              = -1,
-	NULL,
-	},
-	{true}
-};
-
-/*
- * Type 11
- */
-static struct nand_device_info nand_device_info_table_type_11[] __initdata =
-{
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0x98,
-	.device_code              = 0xd7,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
-	.chip_size_in_bytes       = 4LL*SZ_1G,
-	.block_size_in_pages      = 128,
-	.page_total_size_in_bytes = 8*SZ_1K + 376,
-	.ecc_strength_in_bits     = 14,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 15,
-	.data_hold_in_ns          = 10,
-	.address_setup_in_ns      = 8,
-	.gpmi_sample_delay_in_ns  = 6,
-	.tREA_in_ns               = 20,
-	.tRLOH_in_ns              = 5,
-	.tRHOH_in_ns              = 25,
-	"TC58NVG5D2ELAM8 (4GB), TH58NVG6D2ELAM8 (8GB)",
-	},
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0x98,
-	.device_code              = 0xde,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
-	.chip_size_in_bytes       = 8LL*SZ_1G,
-	.block_size_in_pages      = 128,
-	.page_total_size_in_bytes = 8*SZ_1K + 376,
-	.ecc_strength_in_bits     = 14,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 15,
-	.data_hold_in_ns          = 10,
-	.address_setup_in_ns      = 8,
-	.gpmi_sample_delay_in_ns  = 6,
-	.tREA_in_ns               = 20,
-	.tRLOH_in_ns              = 5,
-	.tRHOH_in_ns              = 25,
-	"TH58NVG7D2ELAM8",
-	},
-	{true}
-};
-
-/*
- * Type 15
- */
-static struct nand_device_info nand_device_info_table_type_15[] __initdata =
-{
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0xec,
-	.device_code              = 0xd7,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
-	.chip_size_in_bytes       = 4LL*SZ_1G,
-	.block_size_in_pages      = 128,
-	.page_total_size_in_bytes = 8*SZ_1K + 436,
-	.ecc_strength_in_bits     = 16,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 20,
-	.data_hold_in_ns          = 10,
-	.address_setup_in_ns      = 25,
-	.gpmi_sample_delay_in_ns  = 6,
-	.tREA_in_ns               = 25,
-	.tRLOH_in_ns              = 5,
-	.tRHOH_in_ns              = 15,
-	"K9GBG08U0M (4GB, 1CE); K9LCG08U1M (8GB, 2CE); K9HDG08U5M (16GB, 4CE)",
-	},
-	{true}
-};
-
-/*
- * BCH ECC12
- */
-static struct nand_device_info nand_device_info_table_bch_ecc12[] __initdata =
-{
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0xad,
-	.device_code              = 0xd7,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
-	.chip_size_in_bytes       = 4LL*SZ_1G,
-	.block_size_in_pages      = 128,
-	.page_total_size_in_bytes = 4*SZ_1K + 224,
-	.ecc_strength_in_bits     = 12,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 15,
-	.data_hold_in_ns          = 10,
-	.address_setup_in_ns      = 20,
-	.gpmi_sample_delay_in_ns  = 6,
-	.tREA_in_ns               = 20,
-	.tRLOH_in_ns              = 5,
-	.tRHOH_in_ns              = 15,
-	"H27UBG8T2M (4GB, 1CE), H27UCG8UDM (8GB, 2CE), H27UDG8VEM (16GB, 4CE)",
-	},
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0xad,
-	.device_code              = 0xde,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
-	.chip_size_in_bytes       = 8LL*SZ_1G,
-	.block_size_in_pages      = 128,
-	.page_total_size_in_bytes = 4*SZ_1K + 224,
-	.ecc_strength_in_bits     = 12,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 15,
-	.data_hold_in_ns          = 10,
-	.address_setup_in_ns      = 20,
-	.gpmi_sample_delay_in_ns  = 6,
-	.tREA_in_ns               = 20,
-	.tRLOH_in_ns              = 5,
-	.tRHOH_in_ns              = 15,
-	"H27UEG8YEM (32GB, 4CE)",
-	},
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0x2c,
-	.device_code              = 0xd7,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
-	.chip_size_in_bytes       = 4LL*SZ_1G,
-	.block_size_in_pages      = 128,
-	.page_total_size_in_bytes = 4*SZ_1K + 218,
-	.ecc_strength_in_bits     = 12,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 10,
-	.data_hold_in_ns          = 10,
-	.address_setup_in_ns      = 15,
-	.gpmi_sample_delay_in_ns  = 6,
-	.tREA_in_ns               = 16,
-	.tRLOH_in_ns              = 5,
-	.tRHOH_in_ns              = 15,
-	"MT29F32G08CBAAA (4GB, 1CE), MT29F64G08CFAAA (8GB, 2CE)",
-	},
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0x2c,
-	.device_code              = 0xd9,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
-	.chip_size_in_bytes       = 8LL*SZ_1G,
-	.block_size_in_pages      = 128,
-	.page_total_size_in_bytes = 4*SZ_1K + 218,
-	.ecc_strength_in_bits     = 12,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 10,
-	.data_hold_in_ns          = 10,
-	.address_setup_in_ns      = 15,
-	.gpmi_sample_delay_in_ns  = 6,
-	.tREA_in_ns               = 16,
-	.tRLOH_in_ns              = 5,
-	.tRHOH_in_ns              = 15,
-	"MT29F128G08CJAAA (16GB, 2CE)",
-	},
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0x2c,
-	.device_code              = 0x48,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
-	.chip_size_in_bytes       = 2LL*SZ_1G,
-	.block_size_in_pages      = 256,
-	.page_total_size_in_bytes = 4*SZ_1K + 224,
-	.ecc_strength_in_bits     = 12,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 15,
-	.data_hold_in_ns          = 10,
-	.address_setup_in_ns      = 20,
-	.gpmi_sample_delay_in_ns  = 6,
-	.tREA_in_ns               = 20,
-	.tRLOH_in_ns              = 5,
-	.tRHOH_in_ns              = 15,
-	"MT29F16G08CBABA (2GB, 1CE)",
-	},
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0x2c,
-	.device_code              = 0x68,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
-	.chip_size_in_bytes       = 4LL*SZ_1G,
-	.block_size_in_pages      = 256,
-	.page_total_size_in_bytes = 4*SZ_1K + 224,
-	.ecc_strength_in_bits     = 12,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 15,
-	.data_hold_in_ns          = 10,
-	.address_setup_in_ns      = 20,
-	.gpmi_sample_delay_in_ns  = 6,
-	.tREA_in_ns               = 20,
-	.tRLOH_in_ns              = 5,
-	.tRHOH_in_ns              = 15,
-	"MT29F32G08CBABA (4GB, 1CE); "
-	"MT29F64G08CEABA (8GB, 2CE); "
-	"MT29F64G08CFABA (8GB, 2CE)",
-	},
-	{
-	.end_of_table             = false,
-	.manufacturer_code        = 0x2c,
-	.device_code              = 0x88,
-	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
-	.chip_size_in_bytes       = 8LL*SZ_1G,
-	.block_size_in_pages      = 256,
-	.page_total_size_in_bytes = 4*SZ_1K + 224,
-	.ecc_strength_in_bits     = 12,
-	.ecc_size_in_bytes        = 512,
-	.data_setup_in_ns         = 15,
-	.data_hold_in_ns          = 10,
-	.address_setup_in_ns      = 20,
-	.gpmi_sample_delay_in_ns  = 6,
-	.tREA_in_ns               = 20,
-	.tRLOH_in_ns              = 5,
-	.tRHOH_in_ns              = 15,
-	"MT29F128G08CJABA (16GB, 2CE); "
-	"MT29F128G08CKABA (16GB, 2CE); "
-	"MT29F256G08CUABA (32GB, 4CE)",
-	},
-	{true}
-};
-
-/*
- * The following macros make it convenient to extract information from an ID
- * byte array. All these macros begin with the prefix "ID_".
- *
- * Macros of the form:
- *
- *         ID_GET_[<manufacturer>_[<modifier>_]]<field>
- *
- * extract the given field from an ID byte array. Macros of the form:
- *
- *         ID_[<manufacturer>_[<modifier>_]]<field>_<meaning>
- *
- * contain the value for the given field that has the given meaning.
- *
- * If the <manufacturer> appears, it means this macro represents a view of this
- * field that is specific to the given manufacturer.
- *
- * If the <modifier> appears, it means this macro represents a view of this
- * field that the given manufacturer applies only under specific conditions.
- *
- * Here is a simple example:
- *
- *         ID_PAGE_SIZE_CODE_2K
- *
- * This macro has the value of the "Page Size" field that indicates the page
- * size is 2K.
- *
- * A more complicated example:
- *
- *         ID_SAMSUNG_6_BYTE_PAGE_SIZE_CODE_8K  (0x2)
- *
- * This macro has the value of the "Page Size" field for Samsung parts that
- * indicates the page size is 8K. However, this interpretation is only correct
- * for devices that return 6 ID bytes.
- */
-
-/* Byte 1 ------------------------------------------------------------------- */
-
-#define ID_GET_BYTE_1(id)    ((id)[0])
-
-#define ID_GET_MFR_CODE(id)  ID_GET_BYTE_1(id)
-
-/* Byte 2 ------------------------------------------------------------------- */
-
-#define ID_GET_BYTE_2(id)                           ((id)[1])
-
-#define ID_GET_DEVICE_CODE(id)                      ID_GET_BYTE_2(id)
-    #define ID_SAMSUNG_DEVICE_CODE_1_GBIT           (0xf1)
-    #define ID_SAMSUNG_DEVICE_CODE_2_GBIT           (0xda)
-    #define ID_HYNIX_DEVICE_CODE_ECC12              (0xd7)
-    #define ID_HYNIX_DEVICE_CODE_ECC12_LARGE        (0xde)
-    #define ID_MICRON_DEVICE_CODE_ECC12             (0xd7) /* ECC12        */
-    #define ID_MICRON_DEVICE_CODE_ECC12_LARGE       (0xd9) /* ECC12 8GB/CE */
-    #define ID_MICRON_DEVICE_CODE_ECC12_2GB_PER_CE  (0x48) /* L63B  2GB/CE */
-    #define ID_MICRON_DEVICE_CODE_ECC12_4GB_PER_CE  (0x68) /* L63B  4GB/CE */
-    #define ID_MICRON_DEVICE_CODE_ECC12_8GB_PER_CE  (0x88) /* L63B  8GB/CE */
-
-/* Byte 3 ------------------------------------------------------------------- */
-
-#define ID_GET_BYTE_3(id)               ((id)[2])
-
-#define ID_GET_DIE_COUNT_CODE(id)       ((ID_GET_BYTE_3(id) >> 0) & 0x3)
-
-#define ID_GET_CELL_TYPE_CODE(id)       ((ID_GET_BYTE_3(id) >> 2) & 0x3)
-    #define ID_CELL_TYPE_CODE_SLC       (0x0) /* All others => MLC. */
-
-#define ID_GET_SAMSUNG_SIMUL_PROG(id)   ((ID_GET_BYTE_3(id) >> 4) & 0x3)
-
-#define ID_GET_MICRON_SIMUL_PROG(id)    ((ID_GET_BYTE_3(id) >> 4) & 0x3)
-
-#define ID_GET_CACHE_PROGRAM(id)        ((ID_GET_BYTE_3(id) >> 7) & 0x1)
-
-/* Byte 4 ------------------------------------------------------------------- */
-
-#define ID_GET_BYTE_4(id)                       ((id)[3])
-    #define ID_HYNIX_BYTE_4_ECC12_DEVICE        (0x25)
-
-#define ID_GET_PAGE_SIZE_CODE(id)               ((ID_GET_BYTE_4(id) >> 0) & 0x3)
-    #define ID_PAGE_SIZE_CODE_1K                (0x0)
-    #define ID_PAGE_SIZE_CODE_2K                (0x1)
-    #define ID_PAGE_SIZE_CODE_4K                (0x2)
-    #define ID_PAGE_SIZE_CODE_8K                (0x3)
-    #define ID_SAMSUNG_6_BYTE_PAGE_SIZE_CODE_8K (0x2)
-
-#define ID_GET_OOB_SIZE_CODE(id)                ((ID_GET_BYTE_4(id) >> 2) & 0x1)
-
-#define ID_GET_BLOCK_SIZE_CODE(id)              ((ID_GET_BYTE_4(id) >> 4) & 0x3)
-
-/* Byte 5 ------------------------------------------------------------------- */
-
-#define ID_GET_BYTE_5(id)                  ((id)[4])
-    #define ID_MICRON_BYTE_5_ECC12         (0x84)
-
-#define ID_GET_SAMSUNG_ECC_LEVEL_CODE(id)  ((ID_GET_BYTE_5(id) >> 4) & 0x7)
-    #define ID_SAMSUNG_ECC_LEVEL_CODE_8    (0x03)
-    #define ID_SAMSUNG_ECC_LEVEL_CODE_24   (0x05)
-
-#define ID_GET_PLANE_COUNT_CODE(id)        ((ID_GET_BYTE_5(id) >> 2) & 0x3)
-
-/* Byte 6 ------------------------------------------------------------------- */
-
-#define ID_GET_BYTE_6(id)                        ((id)[5])
-    #define ID_TOSHIBA_BYTE_6_PAGE_SIZE_CODE_8K  (0x54)
-    #define ID_TOSHIBA_BYTE_6_PAGE_SIZE_CODE_4K  (0x13)
-
-#define ID_GET_SAMSUNG_DEVICE_VERSION_CODE(id)   ((ID_GET_BYTE_6(id)>>0) & 0x7)
-    #define ID_SAMSUNG_DEVICE_VERSION_CODE_40NM  (0x01)
-
-/* -------------------------------------------------------------------------- */
-
-void nand_device_print_info(struct nand_device_info *info)
-{
-	unsigned    i;
-	const char  *mfr_name;
-	const char  *cell_technology_name;
-	uint64_t    chip_size;
-	const char  *chip_size_units;
-	unsigned    page_data_size_in_bytes;
-	unsigned    page_oob_size_in_bytes;
-
-	/* Check for nonsense. */
-
-	if (!info)
-		return;
-
-	/* Prepare the manufacturer name. */
-
-	mfr_name = "Unknown";
-
-	for (i = 0; nand_manuf_ids[i].id; i++) {
-		if (nand_manuf_ids[i].id == info->manufacturer_code) {
-			mfr_name = nand_manuf_ids[i].name;
-			break;
-		}
-	}
-
-	/* Prepare the name of the cell technology. */
-
-	switch (info->cell_technology) {
-	case NAND_DEVICE_CELL_TECH_SLC:
-		cell_technology_name = "SLC";
-		break;
-	case NAND_DEVICE_CELL_TECH_MLC:
-		cell_technology_name = "MLC";
-		break;
-	default:
-		cell_technology_name = "Unknown";
-		break;
-	}
-
-	/* Prepare the chip size. */
-
-	if ((info->chip_size_in_bytes >= SZ_1G) &&
-					!(info->chip_size_in_bytes % SZ_1G)) {
-		chip_size       = info->chip_size_in_bytes / ((uint64_t) SZ_1G);
-		chip_size_units = "GiB";
-	} else if ((info->chip_size_in_bytes >= SZ_1M) &&
-					!(info->chip_size_in_bytes % SZ_1M)) {
-		chip_size       = info->chip_size_in_bytes / ((uint64_t) SZ_1M);
-		chip_size_units = "MiB";
-	} else {
-		chip_size       = info->chip_size_in_bytes;
-		chip_size_units = "B";
-	}
-
-	/* Prepare the page geometry. */
-
-	page_data_size_in_bytes = (1<<(fls(info->page_total_size_in_bytes)-1));
-	page_oob_size_in_bytes  = info->page_total_size_in_bytes -
-							page_data_size_in_bytes;
-
-	/* Print the information. */
-
-	printk(KERN_INFO "Manufacturer      : %s (0x%02x)\n",  mfr_name,
-						info->manufacturer_code);
-	printk(KERN_INFO "Device Code       : 0x%02x\n", info->device_code);
-	printk(KERN_INFO "Cell Technology   : %s\n", cell_technology_name);
-	printk(KERN_INFO "Chip Size         : %llu %s\n", chip_size,
-							chip_size_units);
-	printk(KERN_INFO "Pages per Block   : %u\n",
-						info->block_size_in_pages);
-	printk(KERN_INFO "Page Geometry     : %u+%u\n", page_data_size_in_bytes,
-						page_oob_size_in_bytes);
-	printk(KERN_INFO "ECC Strength      : %u bits\n",
-						info->ecc_strength_in_bits);
-	printk(KERN_INFO "ECC Size          : %u B\n", info->ecc_size_in_bytes);
-	printk(KERN_INFO "Data Setup Time   : %u ns\n", info->data_setup_in_ns);
-	printk(KERN_INFO "Data Hold Time    : %u ns\n", info->data_hold_in_ns);
-	printk(KERN_INFO "Address Setup Time: %u ns\n",
-						info->address_setup_in_ns);
-	printk(KERN_INFO "GPMI Sample Delay : %u ns\n",
-						info->gpmi_sample_delay_in_ns);
-	if (info->tREA_in_ns >= 0)
-		printk(KERN_INFO "tREA              : %u ns\n",
-							info->tREA_in_ns);
-	else
-		printk(KERN_INFO "tREA              : Unknown\n");
-	if (info->tREA_in_ns >= 0)
-		printk(KERN_INFO "tRLOH             : %u ns\n",
-							info->tRLOH_in_ns);
-	else
-		printk(KERN_INFO "tRLOH             : Unknown\n");
-	if (info->tREA_in_ns >= 0)
-		printk(KERN_INFO "tRHOH             : %u ns\n",
-							info->tRHOH_in_ns);
-	else
-		printk(KERN_INFO "tRHOH             : Unknown\n");
-	if (info->description)
-		printk(KERN_INFO "Description       : %s\n", info->description);
-	else
-		printk(KERN_INFO "Description       : <None>\n");
-
-}
-
-static struct nand_device_info *nand_device_info_search(
-	struct nand_device_info *table, uint8_t mfr_code, uint8_t device_code)
-{
-
-	for (; !table->end_of_table; table++) {
-		if (table->manufacturer_code != mfr_code)
-			continue;
-		if (table->device_code != device_code)
-			continue;
-		return table;
-	}
-
-	return 0;
-
-}
-
-static struct nand_device_info *nand_device_info_fn_toshiba(const uint8_t id[])
-{
-	struct nand_device_info  *table;
-
-	/* Check for an SLC device. */
-
-	if (ID_GET_CELL_TYPE_CODE(id) == ID_CELL_TYPE_CODE_SLC) {
-		/* Type 2 */
-		return nand_device_info_search(nand_device_info_table_type_2,
-				ID_GET_MFR_CODE(id), ID_GET_DEVICE_CODE(id));
-	}
-
-	/*
-	 * Look for 8K page Toshiba MLC devices.
-	 *
-	 * The page size field in byte 4 can't be used because the field was
-	 * redefined in the 8K parts so the value meaning "8K page" is the same
-	 * as the value meaning "4K page" on the 4K page devices.
-	 *
-	 * The only identifiable difference between the 4K and 8K page Toshiba
-	 * devices with a device code of 0xd7 is the undocumented 6th ID byte.
-	 * The 4K device returns a value of 0x13 and the 8K a value of 0x54.
-	 * Toshiba has verified that this is an acceptable method to distinguish
-	 * the two device families.
-	 */
-
-	if (ID_GET_BYTE_6(id) == ID_TOSHIBA_BYTE_6_PAGE_SIZE_CODE_8K) {
-		/* Type 11 */
-		table = nand_device_info_table_type_11;
-	} else if (ID_GET_PAGE_SIZE_CODE(id) == ID_PAGE_SIZE_CODE_4K) {
-		/* Type 9 */
-		table = nand_device_info_table_type_9;
-	} else {
-		/* Large MLC */
-		table = nand_device_info_table_large_mlc;
-	}
-
-	return nand_device_info_search(table, ID_GET_MFR_CODE(id),
-							ID_GET_DEVICE_CODE(id));
-
-}
-
-static struct nand_device_info *nand_device_info_fn_samsung(const uint8_t id[])
-{
-	struct nand_device_info  *table;
-
-	/* Check for an MLC device. */
-
-	if (ID_GET_CELL_TYPE_CODE(id) != ID_CELL_TYPE_CODE_SLC) {
-
-		/* Is this a Samsung 8K Page MLC device with 16 bit ECC? */
-		if ((ID_GET_SAMSUNG_ECC_LEVEL_CODE(id) ==
-					ID_SAMSUNG_ECC_LEVEL_CODE_24) &&
-		    (ID_GET_PAGE_SIZE_CODE(id) ==
-					ID_SAMSUNG_6_BYTE_PAGE_SIZE_CODE_8K)) {
-			/* Type 15 */
-			table = nand_device_info_table_type_15;
-		}
-		/* Is this a Samsung 42nm ECC8 device with a 6 byte ID? */
-		else if ((ID_GET_SAMSUNG_ECC_LEVEL_CODE(id) ==
-					ID_SAMSUNG_ECC_LEVEL_CODE_8) &&
-			(ID_GET_SAMSUNG_DEVICE_VERSION_CODE(id) ==
-					ID_SAMSUNG_DEVICE_VERSION_CODE_40NM)) {
-			/* Type 9 */
-			table = nand_device_info_table_type_9;
-		} else if (ID_GET_PAGE_SIZE_CODE(id) == ID_PAGE_SIZE_CODE_4K) {
-			/* Type 8 */
-			table = nand_device_info_table_type_8;
-		} else {
-			/* Large MLC */
-			table = nand_device_info_table_large_mlc;
-		}
-
-	} else {
-
-		/* Check the page size first. */
-		if (ID_GET_PAGE_SIZE_CODE(id) == ID_PAGE_SIZE_CODE_4K) {
-			/* Type 10 */
-			table = nand_device_info_table_type_10;
-		}
-		/* Check the chip size. */
-		else if (ID_GET_DEVICE_CODE(id) ==
-						ID_SAMSUNG_DEVICE_CODE_1_GBIT) {
-			if (!ID_GET_CACHE_PROGRAM(id)) {
-				/*
-				 * 128 MiB Samsung chips without cache program
-				 * are Type 7.
-				 *
-				 * The K9F1G08U0B does not support multi-plane
-				 * program, so the if statement below cannot be
-				 * used to identify it.
-				 */
-				table = nand_device_info_table_type_7;
-
-			} else {
-				/* Smaller sizes are Type 2 by default. */
-				table = nand_device_info_table_type_2;
-			}
-		} else {
-			/* Check number of simultaneously programmed pages. */
-			if (ID_GET_SAMSUNG_SIMUL_PROG(id) &&
-						ID_GET_PLANE_COUNT_CODE(id)) {
-				/* Type 7 */
-				table = nand_device_info_table_type_7;
-			} else {
-				/* Type 2 */
-				table = nand_device_info_table_type_2;
-			}
-
-		}
-
-	}
-
-	return nand_device_info_search(table, ID_GET_MFR_CODE(id),
-							ID_GET_DEVICE_CODE(id));
-
-}
-
-static struct nand_device_info *nand_device_info_fn_stmicro(const uint8_t id[])
-{
-	struct nand_device_info  *table;
-
-	/* Check for an SLC device. */
-
-	if (ID_GET_CELL_TYPE_CODE(id) == ID_CELL_TYPE_CODE_SLC)
-		/* Type 2 */
-		table = nand_device_info_table_type_2;
-	else
-		/* Large MLC */
-		table = nand_device_info_table_large_mlc;
-
-	return nand_device_info_search(table, ID_GET_MFR_CODE(id),
-							ID_GET_DEVICE_CODE(id));
-
-}
-
-static struct nand_device_info *nand_device_info_fn_hynix(const uint8_t id[])
-{
-	struct nand_device_info  *table;
-
-	/* Check for an SLC device. */
-
-	if (ID_GET_CELL_TYPE_CODE(id) == ID_CELL_TYPE_CODE_SLC) {
-		/* Type 2 */
-		return nand_device_info_search(nand_device_info_table_type_2,
-				ID_GET_MFR_CODE(id), ID_GET_DEVICE_CODE(id));
-	}
-
-	/*
-	 * Check for ECC12 devices.
-	 *
-	 * We look at the 4th ID byte to distinguish some Hynix ECC12 devices
-	 * from the similar ECC8 part. For example H27UBG8T2M (ECC12) 4th byte
-	 * is 0x25, whereas H27UDG8WFM (ECC8) 4th byte is 0xB6.
-	 */
-
-	if ((ID_GET_DEVICE_CODE(id) == ID_HYNIX_DEVICE_CODE_ECC12 &&
-			ID_GET_BYTE_4(id) == ID_HYNIX_BYTE_4_ECC12_DEVICE) ||
-	    (ID_GET_DEVICE_CODE(id) == ID_HYNIX_DEVICE_CODE_ECC12_LARGE)) {
-		/* BCH ECC 12 */
-		table = nand_device_info_table_bch_ecc12;
-	} else if (ID_GET_PAGE_SIZE_CODE(id) == ID_PAGE_SIZE_CODE_4K) {
-		/*
-		 * So far, all other Samsung and Hynix 4K page devices are
-		 * Type 8.
-		 */
-		table = nand_device_info_table_type_8;
-	} else
-		/* Large MLC */
-		table = nand_device_info_table_large_mlc;
-
-	return nand_device_info_search(table, ID_GET_MFR_CODE(id),
-							ID_GET_DEVICE_CODE(id));
-
-}
-
-static struct nand_device_info *nand_device_info_fn_micron(const uint8_t id[])
-{
-	struct nand_device_info  *table;
-
-	/* Check for an SLC device. */
-
-	if (ID_GET_CELL_TYPE_CODE(id) == ID_CELL_TYPE_CODE_SLC) {
-
-		/* Check number of simultaneously programmed pages. */
-
-		if (ID_GET_MICRON_SIMUL_PROG(id)) {
-			/* Type 7 */
-			table = nand_device_info_table_type_7;
-		} else {
-			/* Zero simultaneously programmed pages means Type 2. */
-			table = nand_device_info_table_type_2;
-		}
-
-		return nand_device_info_search(table, ID_GET_MFR_CODE(id),
-							ID_GET_DEVICE_CODE(id));
-
-	}
-
-	/*
-	 * We look at the 5th ID byte to distinguish some Micron ECC12 NANDs
-	 * from the similar ECC8 part.
-	 *
-	 * For example MT29F64G08CFAAA (ECC12) 5th byte is 0x84, whereas
-	 * MT29F64G08TAA (ECC8) 5th byte is 0x78.
-	 *
-	 * We also have a special case for the Micron L63B family
-	 * (256 page/block), which has unique device codes but no ID fields that
-	 * can easily be used to distinguish the family.
-	 */
-
-	if ((ID_GET_DEVICE_CODE(id) == ID_MICRON_DEVICE_CODE_ECC12 &&
-				ID_GET_BYTE_5(id) == ID_MICRON_BYTE_5_ECC12)  ||
-	   (ID_GET_DEVICE_CODE(id) == ID_MICRON_DEVICE_CODE_ECC12_LARGE)      ||
-	   (ID_GET_DEVICE_CODE(id) == ID_MICRON_DEVICE_CODE_ECC12_2GB_PER_CE) ||
-	   (ID_GET_DEVICE_CODE(id) == ID_MICRON_DEVICE_CODE_ECC12_4GB_PER_CE) ||
-	   (ID_GET_DEVICE_CODE(id) == ID_MICRON_DEVICE_CODE_ECC12_8GB_PER_CE)) {
-		/* BCH ECC 12 */
-		table = nand_device_info_table_bch_ecc12;
-	} else if (ID_GET_PAGE_SIZE_CODE(id) == ID_PAGE_SIZE_CODE_4K) {
-		/* Toshiba devices with 4K pages are Type 9. */
-		table = nand_device_info_table_type_9;
-	} else {
-		/* Large MLC */
-		table = nand_device_info_table_large_mlc;
-	}
-
-	return nand_device_info_search(table, ID_GET_MFR_CODE(id),
-							ID_GET_DEVICE_CODE(id));
-
-}
-
-static struct nand_device_info *nand_device_info_fn_sandisk(const uint8_t id[])
-{
-	struct nand_device_info  *table;
-
-	if (ID_GET_CELL_TYPE_CODE(id) != ID_CELL_TYPE_CODE_SLC) {
-		/* Large MLC */
-		table = nand_device_info_table_large_mlc;
-	} else {
-		/* Type 2 */
-		table = nand_device_info_table_type_2;
-	}
-
-	return nand_device_info_search(table, ID_GET_MFR_CODE(id),
-							ID_GET_DEVICE_CODE(id));
-
-}
-
-static struct nand_device_info *nand_device_info_fn_intel(const uint8_t id[])
-{
-	struct nand_device_info  *table;
-
-	/* Check for an SLC device. */
-
-	if (ID_GET_CELL_TYPE_CODE(id) == ID_CELL_TYPE_CODE_SLC) {
-		/* Type 2 */
-		return nand_device_info_search(nand_device_info_table_type_2,
-				ID_GET_MFR_CODE(id), ID_GET_DEVICE_CODE(id));
-	}
-
-	if (ID_GET_PAGE_SIZE_CODE(id) == ID_PAGE_SIZE_CODE_4K) {
-		/* Type 9 */
-		table = nand_device_info_table_type_9;
-	} else {
-		/* Large MLC */
-		table = nand_device_info_table_large_mlc;
-	}
-
-	return nand_device_info_search(table, ID_GET_MFR_CODE(id),
-							ID_GET_DEVICE_CODE(id));
-
-}
-
-/**
- * struct nand_device_type_info - Information about a NAND Flash type.
- *
- * @name:   A human-readable name for this type.
- * @table:  The device info table for this type.
- */
-
-struct nand_device_type_info {
-	struct nand_device_info  *table;
-	const char               *name;
-};
-
-/*
- * A table that maps manufacturer IDs to device information tables.
- */
-
-static struct nand_device_type_info  nand_device_type_directory[] __initdata =
-{
-	{nand_device_info_table_type_2,    "Type 2"   },
-	{nand_device_info_table_large_mlc, "Large MLC"},
-	{nand_device_info_table_type_7,    "Type 7"   },
-	{nand_device_info_table_type_8,    "Type 8"   },
-	{nand_device_info_table_type_9,    "Type 9"   },
-	{nand_device_info_table_type_10,   "Type 10"  },
-	{nand_device_info_table_type_11,   "Type 11"  },
-	{nand_device_info_table_type_15,   "Type 15"  },
-	{nand_device_info_table_bch_ecc12, "BCH ECC12"},
-	{0, 0},
-};
-
-/**
- * struct nand_device_mfr_info - Information about a NAND Flash manufacturer.
- *
- * @id:     The value of the first NAND Flash ID byte, which identifies the
- *          manufacturer.
- * @fn:     A pointer to a function to use for identifying devices from the
- *          given manufacturer.
- */
-
-struct nand_device_mfr_info {
-	uint8_t                  id;
-	struct nand_device_info  *(*fn)(const uint8_t id[]);
-};
-
-/*
- * A table that maps manufacturer IDs to device information tables.
- */
-
-static struct nand_device_mfr_info  nand_device_mfr_directory[] __initdata =
-{
-	{
-	.id = NAND_MFR_TOSHIBA,
-	.fn = nand_device_info_fn_toshiba,
-	},
-	{
-	.id = NAND_MFR_SAMSUNG,
-	.fn = nand_device_info_fn_samsung,
-	},
-	{
-	.id = NAND_MFR_FUJITSU,
-	.fn = 0,
-	},
-	{
-	.id = NAND_MFR_NATIONAL,
-	.fn = 0,
-	},
-	{
-	.id = NAND_MFR_RENESAS,
-	.fn = 0,
-	},
-	{
-	.id = NAND_MFR_STMICRO,
-	.fn = nand_device_info_fn_stmicro,
-	},
-	{
-	.id = NAND_MFR_HYNIX,
-	.fn = nand_device_info_fn_hynix,
-	},
-	{
-	.id = NAND_MFR_MICRON,
-	.fn = nand_device_info_fn_micron,
-	},
-	{
-	.id = NAND_MFR_AMD,
-	.fn = 0,
-	},
-	{
-	.id = NAND_MFR_SANDISK,
-	.fn = nand_device_info_fn_sandisk,
-	},
-	{
-	.id = NAND_MFR_INTEL,
-	.fn = nand_device_info_fn_intel,
-	},
-	{0, 0}
-};
-
-/**
- * nand_device_info_test_table - Validate a device info table.
- *
- * This function runs tests on the given device info table to check that it
- * meets the current assumptions.
- */
-
-static void __init nand_device_info_test_table(
-			struct nand_device_info *table, const char * name)
-{
-	unsigned  i;
-	unsigned  j;
-	uint8_t   mfr_code;
-	uint8_t   device_code;
-
-	/* Loop over entries in this table. */
-
-	for (i = 0; !table[i].end_of_table; i++) {
-
-		/* Get discriminating attributes of the current device. */
-
-		mfr_code    = table[i].manufacturer_code;
-		device_code = table[i].device_code;
-
-		/* Compare with the remaining devices in this table. */
-
-		for (j = i + 1; !table[j].end_of_table; j++) {
-			if ((mfr_code    == table[j].manufacturer_code) &&
-			    (device_code == table[j].device_code))
-				goto error;
-		}
-
-	}
-
-	return;
-
-error:
-
-	printk(KERN_EMERG
-		"\n== NAND Flash device info table failed validity check ==\n");
-
-	printk(KERN_EMERG "\nDevice Info Table: %s\n", name);
-	printk(KERN_EMERG "\nTable Index %u\n", i);
-	nand_device_print_info(table + i);
-	printk(KERN_EMERG "\nTable Index %u\n", j);
-	nand_device_print_info(table + j);
-	printk(KERN_EMERG "\n");
-
-	BUG();
-
-}
-
-/**
- * nand_device_info_test_data - Test the NAND Flash device data.
- */
-
-static void __init nand_device_info_test_data(void)
-{
-
-	unsigned  i;
-
-	for (i = 0; nand_device_type_directory[i].name; i++) {
-		nand_device_info_test_table(
-					nand_device_type_directory[i].table,
-					nand_device_type_directory[i].name);
-	}
-
-}
-
-struct nand_device_info * __init nand_device_get_info(const uint8_t id[])
-{
-	unsigned                 i;
-	uint8_t                  mfr_id = ID_GET_MFR_CODE(id);
-	struct nand_device_info  *(*fn)(const uint8_t id[]) = 0;
-
-	/* Test the data. */
-
-	nand_device_info_test_data();
-
-	/* Look for information about this manufacturer. */
-
-	for (i = 0; nand_device_mfr_directory[i].id; i++) {
-		if (nand_device_mfr_directory[i].id == mfr_id) {
-			fn = nand_device_mfr_directory[i].fn;
-			break;
-		}
-	}
-
-	if (!fn)
-		return 0;
-
-	/*
-	 * If control arrives here, we found both a table of device information,
-	 * and a function we can use to identify the current device. Attempt to
-	 * identify the device and return the result.
-	 */
-
-	return fn(id);
-
-}
diff -urNBb -x linux-2.6.31.9-ER1-efikamx/Documentation/dontdiff linux-2.6.31.9-ER1-efikamx.orig/drivers/mtd/nand/gpmi/nand_device_info.h linux-2.6.31.9-ER1-efikamx/drivers/mtd/nand/gpmi/nand_device_info.h
--- linux-2.6.31.9-ER1-efikamx.orig/drivers/mtd/nand/gpmi/nand_device_info.h	2009-12-12 13:16:56.000000000 -0600
+++ linux-2.6.31.9-ER1-efikamx/drivers/mtd/nand/gpmi/nand_device_info.h	1969-12-31 18:00:00.000000000 -0600
@@ -1,140 +0,0 @@
-/*
- * Copyright 2009 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-
-/*
- * The code contained herein is licensed under the GNU General Public
- * License. You may obtain a copy of the GNU General Public License
- * Version 2 or later at the following locations:
- *
- * http://www.opensource.org/licenses/gpl-license.html
- * http://www.gnu.org/copyleft/gpl.html
- */
-#ifndef __DRIVERS_NAND_DEVICE_INFO_H
-#define __DRIVERS_NAND_DEVICE_INFO_H
-
- /*
-  * The number of ID bytes to read from the NAND Flash device and hand over to
-  * the identification system.
-  */
-
-#define NAND_DEVICE_ID_BYTE_COUNT  (6)
-
- /*
-  * The number of ID bytes to read from the NAND Flash device and hand over to
-  * the identification system.
-  */
-
-enum nand_device_cell_technology {
-	NAND_DEVICE_CELL_TECH_SLC = 0,
-	NAND_DEVICE_CELL_TECH_MLC = 1,
-};
-
-/**
- * struct nand_device_info - Information about a single NAND Flash device.
- *
- * This structure contains all the *essential* information about a NAND Flash
- * device, derived from the device's data sheet. For each manufacturer, we have
- * an array of these structures.
- *
- * @end_of_table:              If true, marks the end of a table of device
- *                             information.
- * @manufacturer_code:         The manufacturer code (1st ID byte) reported by
- *                             the device.
- * @device_code:               The device code (2nd ID byte) reported by the
- *                             device.
- * @cell_technology:           The storage cell technology.
- * @chip_size_in_bytes:        The total size of the storage behind a single
- *                             chip select, in bytes. Notice that this is *not*
- *                             necessarily the total size of the storage in a
- *                             *package*, which may contain several chips.
- * @block_size_in_pages:       The number of pages in a block.
- * @page_total_size_in_bytes:  The total size of a page, in bytes, including
- *                             both the data and the OOB.
- * @ecc_strength_in_bits:      The strength of the ECC called for by the
- *                             manufacturer, in number of correctable bits.
- * @ecc_size_in_bytes:         The size of the data block over which the
- *                             manufacturer calls for the given ECC algorithm
- *                             and strength.
- * @data_setup_in_ns:          The data setup time, in nanoseconds. Usually the
- *                             maximum of tDS and tWP. A negative value
- *                             indicates this characteristic isn't known.
- * @data_hold_in_ns:           The data hold time, in nanoseconds. Usually the
- *                             maximum of tDH, tWH and tREH. A negative value
- *                             indicates this characteristic isn't known.
- * @address_setup_in_ns:       The address setup time, in nanoseconds. Usually
- *                             the maximum of tCLS, tCS and tALS. A negative
- *                             value indicates this characteristic isn't known.
- * @gpmi_sample_delay_in_ns:   A GPMI-specific timing parameter. A negative
- *                             value indicates this characteristic isn't known.
- * @tREA_in_ns:                tREA, in nanoseconds, from the data sheet. A
- *                             negative value indicates this characteristic
- *                             isn't known.
- * @tRLOH_in_ns:               tRLOH, in nanoseconds, from the data sheet. A
- *                             negative value indicates this characteristic
- *                             isn't known.
- * @tRHOH_in_ns:               tRHOH, in nanoseconds, from the data sheet. A
- *                             negative value indicates this characteristic
- *                             isn't known.
- */
-
-struct nand_device_info {
-
-	/* End of table marker */
-
-	bool      end_of_table;
-
-	/* Manufacturer and Device codes */
-
-	uint8_t   manufacturer_code;
-	uint8_t   device_code;
-
-	/* Technology */
-
-	enum nand_device_cell_technology  cell_technology;
-
-	/* Geometry */
-
-	uint64_t  chip_size_in_bytes;
-	uint32_t  block_size_in_pages;
-	uint16_t  page_total_size_in_bytes;
-
-	/* ECC */
-
-	uint8_t   ecc_strength_in_bits;
-	uint16_t  ecc_size_in_bytes;
-
-	/* Timing */
-
-	int8_t    data_setup_in_ns;
-	int8_t    data_hold_in_ns;
-	int8_t    address_setup_in_ns;
-	int8_t    gpmi_sample_delay_in_ns;
-	int8_t    tREA_in_ns;
-	int8_t    tRLOH_in_ns;
-	int8_t    tRHOH_in_ns;
-
-	/* Description */
-
-	const char  *description;
-
-};
-
-/**
- * nand_device_get_info - Get info about a device based on ID bytes.
- *
- * @id_bytes:  An array of NAND_DEVICE_ID_BYTE_COUNT ID bytes retrieved from the
- *             NAND Flash device.
- */
-
-struct nand_device_info *nand_device_get_info(const uint8_t id_bytes[]);
-
-/**
- * nand_device_print_info - Prints information about a NAND Flash device.
- *
- * @info  A pointer to a NAND Flash device information structure.
- */
-
-void nand_device_print_info(struct nand_device_info *info);
-
-#endif
diff -urNBb -x linux-2.6.31.9-ER1-efikamx/Documentation/dontdiff linux-2.6.31.9-ER1-efikamx.orig/drivers/mtd/nand/Makefile linux-2.6.31.9-ER1-efikamx/drivers/mtd/nand/Makefile
--- linux-2.6.31.9-ER1-efikamx.orig/drivers/mtd/nand/Makefile	2009-12-12 13:16:52.000000000 -0600
+++ linux-2.6.31.9-ER1-efikamx/drivers/mtd/nand/Makefile	2010-01-07 22:20:55.309713641 -0600
@@ -39,9 +39,9 @@
 obj-$(CONFIG_MTD_NAND_SH_FLCTL)		+= sh_flctl.o
 obj-$(CONFIG_MTD_NAND_IMX_NFC)		+= imx_nfc.o
 obj-$(CONFIG_MTD_NAND_MXC)		+= mxc_nand.o
-obj-$(CONFIG_MTD_NAND_MXC_V2)		+= mxc_nd2.o
-obj-$(CONFIG_MTD_NAND_MXC_V3)		+= mxc_nd2.o
-obj-$(CONFIG_MTD_NAND_GPMI)		+= gpmi/
+obj-$(CONFIG_MTD_NAND_MXC_V2)		+= mxc_nd2.o nand_device_info.o
+obj-$(CONFIG_MTD_NAND_MXC_V3)		+= mxc_nd2.o nand_device_info.o
+obj-$(CONFIG_MTD_NAND_GPMI)		+= gpmi/ nand_device_info.o
 obj-$(CONFIG_MTD_NAND_GPMI_LBA)		+= lba/
 obj-$(CONFIG_MTD_NAND_SOCRATES)		+= socrates_nand.o
 obj-$(CONFIG_MTD_NAND_TXX9NDFMC)	+= txx9ndfmc.o
diff -urNBb -x linux-2.6.31.9-ER1-efikamx/Documentation/dontdiff linux-2.6.31.9-ER1-efikamx.orig/drivers/mtd/nand/mxc_nd2.c linux-2.6.31.9-ER1-efikamx/drivers/mtd/nand/mxc_nd2.c
--- linux-2.6.31.9-ER1-efikamx.orig/drivers/mtd/nand/mxc_nd2.c	2009-12-12 13:16:57.000000000 -0600
+++ linux-2.6.31.9-ER1-efikamx/drivers/mtd/nand/mxc_nd2.c	2010-01-07 22:20:55.755185068 -0600
@@ -26,6 +26,7 @@
 #include <asm/mach/flash.h>
 #include <asm/io.h>
 #include "mxc_nd2.h"
+#include "nand_device_info.h"
 
 #define DVR_VER "2.5"
 
@@ -42,9 +43,9 @@
 static struct mxc_mtd_s *mxc_nand_data;
 
 /*
- * Define delays in microsec for NAND device operations
+ * Define delay timeout value
  */
-#define TROP_US_DELAY   2000
+#define TROP_US_DELAY   (1000 * 1000)
 
 struct nand_info {
 	bool bStatusRequest;
@@ -189,8 +190,13 @@
 			/* Enable Interuupt */
 			raw_write(raw_read(REG_NFC_INTRRUPT) & ~NFC_INT_MSK,
 				  REG_NFC_INTRRUPT);
-			wait_event(irq_waitq,
-				   (raw_read(REG_NFC_OPS_STAT) & NFC_OPS_STAT));
+			if (!wait_event_timeout(irq_waitq,
+				(raw_read(REG_NFC_OPS_STAT) & NFC_OPS_STAT),
+				msecs_to_jiffies(TROP_US_DELAY / 1000)) > 0) {
+				printk(KERN_WARNING "%s(%d): INT not set\n",
+						__func__, __LINE__);
+				return;
+			}
 		}
 		WRITE_NFC_IP_REG((raw_read(REG_NFC_OPS_STAT) &
 				  ~NFC_OPS_STAT), REG_NFC_OPS_STAT);
@@ -205,8 +211,9 @@
 			}
 			udelay(1);
 			if (maxRetries <= 0) {
-				DEBUG(MTD_DEBUG_LEVEL0, "%s(%d): INT not set\n",
+				printk(KERN_WARNING "%s(%d): INT not set\n",
 				      __func__, __LINE__);
+				break;
 			}
 		}
 	}
@@ -287,7 +294,7 @@
 			while (!(raw_read(REG_NFC_OPS_STAT) & NFC_OP_DONE)) ;
 		}
 
-		wait_op_done(TROP_US_DELAY, false);
+		wait_op_done(TROP_US_DELAY, true);
 		while (!(raw_read(REG_NFC_OPS_STAT) & NFC_RB)) ;
 
 		break;
@@ -299,7 +306,7 @@
 			NFC_SET_RBA(0);
 			ACK_OPS;
 			raw_write(NFC_AUTO_READ, REG_NFC_OPS);
-			wait_op_done(TROP_US_DELAY, false);
+			wait_op_done(TROP_US_DELAY, true);
 
 			/* check ecc error */
 			mxc_check_ecc_status(mtd);
@@ -428,7 +435,7 @@
 	raw_write(NFC_INPUT, REG_NFC_OPS);
 
 	/* Wait for operation to complete */
-	wait_op_done(TROP_US_DELAY, false);
+	wait_op_done(TROP_US_DELAY, true);
 #endif
 }
 
@@ -453,7 +460,7 @@
 	raw_write(NFC_OUTPUT, REG_NFC_OPS);
 
 	/* Wait for operation to complete */
-	wait_op_done(TROP_US_DELAY, false);
+	wait_op_done(TROP_US_DELAY, true);
 #endif
 }
 
@@ -492,7 +499,7 @@
 	*/
 	raw_write(NFC_STATUS, REG_NFC_OPS);
 
-	wait_op_done(TROP_US_DELAY, false);
+	wait_op_done(TROP_US_DELAY, true);
 
 	*status = (raw_read(NFC_CONFIG1) & mask) >> 16;
 
@@ -541,7 +548,7 @@
 	raw_write(NFC_STATUS, REG_NFC_OPS);
 
 	/* Wait for operation to complete */
-	wait_op_done(TROP_US_DELAY, false);
+	wait_op_done(TROP_US_DELAY, true);
 
 	/* Status is placed in first word of main buffer */
 	/* get status, then recovery area 1 data */
@@ -839,18 +846,18 @@
 	u32 page_mask = g_page_mask;
 
 	if (column != -1) {
-		send_addr(column & 0xFF, false);
+		send_addr(column & 0xFF, true);
 		if (IS_2K_PAGE_NAND) {
 			/* another col addr cycle for 2k page */
-			send_addr((column >> 8) & 0xF, false);
+			send_addr((column >> 8) & 0xF, true);
 		} else if (IS_4K_PAGE_NAND) {
 			/* another col addr cycle for 4k page */
-			send_addr((column >> 8) & 0x1F, false);
+			send_addr((column >> 8) & 0x1F, true);
 		}
 	}
 	if (page_addr != -1) {
 		do {
-			send_addr((page_addr & 0xff), false);
+			send_addr((page_addr & 0xff), true);
 			page_mask >>= 8;
 			page_addr >>= 8;
 		} while (page_mask != 0);
@@ -870,7 +877,7 @@
 static void mxc_nand_command(struct mtd_info *mtd, unsigned command,
 			     int column, int page_addr)
 {
-	bool useirq = false;
+	bool useirq = true;
 
 	DEBUG(MTD_DEBUG_LEVEL3,
 	      "mxc_nand_command (cmd = 0x%x, col = 0x%x, page = 0x%x)\n",
@@ -946,15 +953,11 @@
 		else
 			send_prog_page(0);
 
-		useirq = true;
-
 		break;
 
 	case NAND_CMD_ERASE1:
 		break;
 	case NAND_CMD_ERASE2:
-		useirq = true;
-
 		break;
 	}
 
@@ -974,7 +977,7 @@
 	case NAND_CMD_READ0:
 		if (IS_LARGE_PAGE_NAND) {
 			/* send read confirm command */
-			send_cmd(mtd, NAND_CMD_READSTART, false);
+			send_cmd(mtd, NAND_CMD_READSTART, true);
 			/* read for each AREA */
 			READ_PAGE();
 		} else {
@@ -1093,16 +1096,6 @@
 
 	g_page_mask = this->pagemask;
 
-	/* limit to 2G size due to Kernel
-	 * larger 4G space support,need fix
-	 * it later
-	 */
-	if (mtd->size == 0) {
-		mtd->size = 1 << 31;
-		this->numchips = 1;
-		this->chipsize = mtd->size;
-	}
-
 	if (IS_2K_PAGE_NAND) {
 		NFC_SET_NFMS(1 << NFMS_NF_PG_SZ);
 		this->ecc.layout = &nand_hw_eccoob_2k;
@@ -1185,6 +1178,63 @@
 	kfree(oob_buf);
 }
 
+int nand_scan_mid(struct mtd_info *mtd)
+{
+	int i;
+	uint8_t id_bytes[NAND_DEVICE_ID_BYTE_COUNT];
+	struct nand_chip *this = mtd->priv;
+	struct nand_device_info  *dev_info;
+
+	if (!IS_LARGE_PAGE_NAND)
+		return 0;
+
+	/* Read ID bytes from the first NAND Flash chip. */
+	this->select_chip(mtd, 0);
+
+	this->cmdfunc(mtd, NAND_CMD_READID, 0x00, -1);
+
+	for (i = 0; i < NAND_DEVICE_ID_BYTE_COUNT; i++)
+		id_bytes[i] = this->read_byte(mtd);
+
+	/* Get information about this device, based on the ID bytes. */
+	dev_info = nand_device_get_info(id_bytes);
+
+	/* Check if we understand this device. */
+	if (!dev_info) {
+		printk(KERN_ERR "Unrecognized NAND Flash device.\n");
+		return !0;
+	}
+
+	/* Correct mtd setting */
+	this->chipsize = dev_info->chip_size_in_bytes;
+	mtd->size = dev_info->chip_size_in_bytes * this->numchips;
+	mtd->writesize = dev_info->page_total_size_in_bytes & ~0x3ff;
+	mtd->oobsize = dev_info->page_total_size_in_bytes & 0x3ff;
+	mtd->erasesize = dev_info->block_size_in_pages * mtd->writesize;
+
+	/* limit to 2G size due to Kernel
+	 * larger 4G space support,need fix
+	 * it later
+	 */
+	if ((u32)mtd->size == 0) {
+		mtd->size = (u32)(1 << 31);
+		this->numchips = 1;
+		this->chipsize = mtd->size;
+	}
+
+	/* Calculate the address shift from the page size */
+	this->page_shift = ffs(mtd->writesize) - 1;
+	/* Convert chipsize to number of pages per chip -1. */
+	this->pagemask = (this->chipsize >> this->page_shift) - 1;
+
+	this->bbt_erase_shift = this->phys_erase_shift =
+		ffs(mtd->erasesize) - 1;
+	this->chip_shift = ffs(this->chipsize) - 1;
+
+	return 0;
+}
+
+
 /*!
  * This function is called during the driver binding process.
  *
@@ -1284,7 +1334,9 @@
 	this->cmdfunc(mtd, NAND_CMD_RESET, -1, -1);
 
 	/* Scan to find existence of the device */
-	if (nand_scan(mtd, NFC_GET_MAXCHIP_SP())) {
+	if (nand_scan_ident(mtd, NFC_GET_MAXCHIP_SP())
+		|| nand_scan_mid(mtd)
+		|| nand_scan_tail(mtd)) {
 		DEBUG(MTD_DEBUG_LEVEL0,
 		      "MXC_ND2: Unable to find any NAND device.\n");
 		err = -ENXIO;
@@ -1363,8 +1415,6 @@
 
 static int mxcnd_suspend(struct platform_device *pdev, pm_message_t state)
 {
-	struct mtd_info *info = platform_get_drvdata(pdev);
-
 	DEBUG(MTD_DEBUG_LEVEL0, "MXC_ND2 : NAND suspend\n");
 
 	/* Disable the NFC clock */
@@ -1384,8 +1434,6 @@
  */
 static int mxcnd_resume(struct platform_device *pdev)
 {
-	struct mtd_info *info = platform_get_drvdata(pdev);
-
 	DEBUG(MTD_DEBUG_LEVEL0, "MXC_ND2 : NAND resume\n");
 
 	/* Enable the NFC clock */
diff -urNBb -x linux-2.6.31.9-ER1-efikamx/Documentation/dontdiff linux-2.6.31.9-ER1-efikamx.orig/drivers/mtd/nand/mxc_nd2.h linux-2.6.31.9-ER1-efikamx/drivers/mtd/nand/mxc_nd2.h
--- linux-2.6.31.9-ER1-efikamx.orig/drivers/mtd/nand/mxc_nd2.h	2009-12-12 13:16:54.000000000 -0600
+++ linux-2.6.31.9-ER1-efikamx/drivers/mtd/nand/mxc_nd2.h	2010-01-07 22:20:54.656037575 -0600
@@ -564,9 +564,20 @@
 #define GET_ECC_STATUS()  __raw_readl(REG_NFC_ECC_STATUS_RESULT);
 #define NFC_SET_NFMS(v)	\
 do {	\
-	(NFMS |= (v));	\
 	if (((v) & (1 << NFMS_NF_PG_SZ))) {	\
-		NFC_SET_SPAS(GET_NAND_OOB_SIZE >> 1);	\
+		if (IS_2K_PAGE_NAND) { \
+			(NFMS |= 0x00000100); \
+			(NFMS &= ~0x00000200); \
+			NFC_SET_SPAS(NFC_SPAS_64); \
+		} else if (IS_4K_PAGE_NAND) { \
+			(NFMS &= ~0x00000100); \
+			(NFMS |= 0x00000200); \
+			GET_NAND_OOB_SIZE == 128 ? \
+			NFC_SET_SPAS(NFC_SPAS_128) : \
+			NFC_SET_SPAS(NFC_SPAS_218); \
+		} else { \
+			printk(KERN_ERR "Err for setting page/oob size"); \
+		} \
 		NFC_SET_ECC_MODE(GET_NAND_OOB_SIZE >> 1); \
 	} \
 } while (0)
diff -urNBb -x linux-2.6.31.9-ER1-efikamx/Documentation/dontdiff linux-2.6.31.9-ER1-efikamx.orig/drivers/mtd/nand/nand_device_info.c linux-2.6.31.9-ER1-efikamx/drivers/mtd/nand/nand_device_info.c
--- linux-2.6.31.9-ER1-efikamx.orig/drivers/mtd/nand/nand_device_info.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.31.9-ER1-efikamx/drivers/mtd/nand/nand_device_info.c	2010-01-07 22:20:55.377559413 -0600
@@ -0,0 +1,2297 @@
+/*
+ * Copyright 2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <asm/sizes.h>
+#include <linux/mtd/nand.h>
+
+#include "nand_device_info.h"
+
+/*
+ * Type 2
+ */
+static struct nand_device_info nand_device_info_table_type_2[] __initdata =
+{
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x20,
+	.device_code              = 0xf1,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
+	.chip_size_in_bytes       = 128LL*SZ_1M,
+	.block_size_in_pages      = 64,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 30,
+	.data_hold_in_ns          = 20,
+	.address_setup_in_ns      = 25,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"NAND01GW3",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0xad,
+	.device_code              = 0xf1,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
+	.chip_size_in_bytes       = 128LL*SZ_1M,
+	.block_size_in_pages      = 64,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 45,
+	.data_hold_in_ns          = 30,
+	.address_setup_in_ns      = 25,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	NULL,
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x2c,
+	.device_code              = 0xf1,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
+	.chip_size_in_bytes       = 128LL*SZ_1M,
+	.block_size_in_pages      = 64,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 30,
+	.data_hold_in_ns          = 20,
+	.address_setup_in_ns      = 10,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	NULL,
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0xec,
+	.device_code              = 0xf1,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
+	.chip_size_in_bytes       = 128LL*SZ_1M,
+	.block_size_in_pages      = 64,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 35,
+	.data_hold_in_ns          = 25,
+	.address_setup_in_ns      = 0,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"K9F1F08",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x98,
+	.device_code              = 0xf1,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
+	.chip_size_in_bytes       = 128LL*SZ_1M,
+	.block_size_in_pages      = 64,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 30,
+	.data_hold_in_ns          = 20,
+	.address_setup_in_ns      = 0,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"TC58NVG0S3",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x45,
+	.device_code              = 0xf1,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
+	.chip_size_in_bytes       = 128LL*SZ_1M,
+	.block_size_in_pages      = 64,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 45,
+	.data_hold_in_ns          = 32,
+	.address_setup_in_ns      = 0,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	NULL,
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x20,
+	.device_code              = 0xda,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
+	.chip_size_in_bytes       = 256LL*SZ_1M,
+	.block_size_in_pages      = 64,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 20,
+	.data_hold_in_ns          = 30,
+	.address_setup_in_ns      = 0,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"NAND02GW3",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0xad,
+	.device_code              = 0xda,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
+	.chip_size_in_bytes       = 256LL*SZ_1M,
+	.block_size_in_pages      = 64,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 30,
+	.data_hold_in_ns          = 25,
+	.address_setup_in_ns      = 10,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"HY27UF082G2M, HY27UG082G2M, HY27UG082G1M",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x2c,
+	.device_code              = 0xda,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
+	.chip_size_in_bytes       = 256LL*SZ_1M,
+	.block_size_in_pages      = 64,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 20,
+	.data_hold_in_ns          = 10,
+	.address_setup_in_ns      = 10,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"MT29F2G08",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0xec,
+	.device_code              = 0xda,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
+	.chip_size_in_bytes       = 256LL*SZ_1M,
+	.block_size_in_pages      = 64,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 20,
+	.data_hold_in_ns          = 10,
+	.address_setup_in_ns      = 20,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"K9F2G08U0M",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x98,
+	.device_code              = 0xda,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
+	.chip_size_in_bytes       = 256LL*SZ_1M,
+	.block_size_in_pages      = 64,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 20,
+	.data_hold_in_ns          = 30,
+	.address_setup_in_ns      = 0,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"TC58NVG1S3",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x45,
+	.device_code              = 0xda,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
+	.chip_size_in_bytes       = 256LL*SZ_1M,
+	.block_size_in_pages      = 64,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 45,
+	.data_hold_in_ns          = 32,
+	.address_setup_in_ns      = 0,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	NULL,
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x20,
+	.device_code              = 0xdc,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
+	.chip_size_in_bytes       = 512LL*SZ_1M,
+	.block_size_in_pages      = 64,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 45,
+	.data_hold_in_ns          = 30,
+	.address_setup_in_ns      = 10,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	NULL,
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0xad,
+	.device_code              = 0xdc,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
+	.chip_size_in_bytes       = 512LL*SZ_1M,
+	.block_size_in_pages      = 64,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 45,
+	.data_hold_in_ns          = 30,
+	.address_setup_in_ns      = 10,
+	.gpmi_sample_delay_in_ns  = 10,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"HY27UH084G2M, HY27UG084G2M, HY27UH084G1M",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x2c,
+	.device_code              = 0xdc,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
+	.chip_size_in_bytes       = 512LL*SZ_1M,
+	.block_size_in_pages      = 64,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 20,
+	.data_hold_in_ns          = 10,
+	.address_setup_in_ns      = 10,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"MT29F4G08",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0xec,
+	.device_code              = 0xdc,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
+	.chip_size_in_bytes       = 512LL*SZ_1M,
+	.block_size_in_pages      = 64,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 25,
+	.data_hold_in_ns          = 25,
+	.address_setup_in_ns      = 20,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	NULL,
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x98,
+	.device_code              = 0xdc,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
+	.chip_size_in_bytes       = 512LL*SZ_1M,
+	.block_size_in_pages      = 64,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 25,
+	.data_hold_in_ns          = 25,
+	.address_setup_in_ns      = 0,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"TH58NVG2S3",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x45,
+	.device_code              = 0xdc,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
+	.chip_size_in_bytes       = 512LL*SZ_1M,
+	.block_size_in_pages      = 64,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 45,
+	.data_hold_in_ns          = 32,
+	.address_setup_in_ns      = 0,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	NULL,
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0xad,
+	.device_code              = 0xd3,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
+	.chip_size_in_bytes       = 1LL*SZ_1G,
+	.block_size_in_pages      = 64,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 30,
+	.data_hold_in_ns          = 25,
+	.address_setup_in_ns      = 20,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"HY27UH088G2M",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x20,
+	.device_code              = 0xd3,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
+	.chip_size_in_bytes       = 1LL*SZ_1G,
+	.block_size_in_pages      = 64,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 45,
+	.data_hold_in_ns          = 30,
+	.address_setup_in_ns      = 10,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"NAND08GW3BxANx",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x2c,
+	.device_code              = 0xd3,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
+	.chip_size_in_bytes       = 1LL*SZ_1G,
+	.block_size_in_pages      = 64,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 25,
+	.data_hold_in_ns          = 15,
+	.address_setup_in_ns      = 10,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"MT29F8G08FABWG",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x98,
+	.device_code              = 0xd3,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
+	.chip_size_in_bytes       = 1LL*SZ_1G,
+	.block_size_in_pages      = 64,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 45,
+	.data_hold_in_ns          = 32,
+	.address_setup_in_ns      = 0,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	NULL,
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x20,
+	.device_code              = 0xd5,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
+	.chip_size_in_bytes       = 2LL*SZ_1G,
+	.block_size_in_pages      = 64,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 45,
+	.data_hold_in_ns          = 30,
+	.address_setup_in_ns      = 10,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	NULL,
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0xad,
+	.device_code              = 0xd5,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
+	.chip_size_in_bytes       = 2LL*SZ_1G,
+	.block_size_in_pages      = 64,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 25,
+	.data_hold_in_ns          = 30,
+	.address_setup_in_ns      = 10,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	NULL,
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x2c,
+	.device_code              = 0xd5,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
+	.chip_size_in_bytes       = 2LL*SZ_1G,
+	.block_size_in_pages      = 64,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 45,
+	.data_hold_in_ns          = 32,
+	.address_setup_in_ns      = 0,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	NULL,
+	},
+	{true}
+};
+
+/*
+ * Large MLC
+ */
+static struct nand_device_info nand_device_info_table_large_mlc[] __initdata =
+{
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x98,
+	.device_code              = 0xda,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 256LL*SZ_1M,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 20,
+	.data_hold_in_ns          = 30,
+	.address_setup_in_ns      = 0,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"TC58NVG1D4BFT00",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x45,
+	.device_code              = 0xda,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 256LL*SZ_1M,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 20,
+	.data_hold_in_ns          = 30,
+	.address_setup_in_ns      = 0,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	NULL,
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x45,
+	.device_code              = 0xdc,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 512LL*SZ_1M,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 20,
+	.data_hold_in_ns          = 30,
+	.address_setup_in_ns      = 0,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	NULL,
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x98,
+	.device_code              = 0xd3,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 1LL*SZ_1G,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 35,
+	.data_hold_in_ns          = 30,
+	.address_setup_in_ns      = 0,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"TH58NVG3D4xFT00",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x45,
+	.device_code              = 0xd3,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 1LL*SZ_1G,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 35,
+	.data_hold_in_ns          = 20,
+	.address_setup_in_ns      = 0,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	NULL,
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x98,
+	.device_code              = 0xd5,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 2LL*SZ_1G,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 35,
+	.data_hold_in_ns          = 15,
+	.address_setup_in_ns      = 0,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"TH58NVG4D4xFT00",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x45,
+	.device_code              = 0xd5,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 2LL*SZ_1G,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 35,
+	.data_hold_in_ns          = 15,
+	.address_setup_in_ns      = 0,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	NULL,
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x98,
+	.device_code              = 0xdc,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 512LL*SZ_1M,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 20,
+	.data_hold_in_ns          = 30,
+	.address_setup_in_ns      = 0,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"TC58NVG2D4BFT00",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0xec,
+	.device_code              = 0xdc,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 512LL*SZ_1M,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 25,
+	.data_hold_in_ns          = 15,
+	.address_setup_in_ns      = 25,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"K9G4G08U0M",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0xad,
+	.device_code              = 0xdc,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 512LL*SZ_1M,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 45,
+	.data_hold_in_ns          = 25,
+	.address_setup_in_ns      = 50,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"HY27UT084G2M, HY27UU088G5M",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x20,
+	.device_code              = 0xdc,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 512LL*SZ_1M,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 40,
+	.data_hold_in_ns          = 20,
+	.address_setup_in_ns      = 30,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"NAND04GW3C2AN1E",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0xec,
+	.device_code              = 0xd3,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 1LL*SZ_1G,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 20,
+	.data_hold_in_ns          = 15,
+	.address_setup_in_ns      = 20,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"K9G8G08U0M, K9HAG08U1M",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0xad,
+	.device_code              = 0xd3,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 1LL*SZ_1G,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 60,
+	.data_hold_in_ns          = 30,
+	.address_setup_in_ns      = 50,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"HY27UV08AG5M",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x2c,
+	.device_code              = 0xd3,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 1LL*SZ_1G,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 15,
+	.data_hold_in_ns          = 15,
+	.address_setup_in_ns      = 15,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"Intel JS29F08G08AAMiB1 and Micron MT29F8G08MAA; "
+	"Intel JS29F08G08CAMiB1 and Micron MT29F16G08QAA",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0xec,
+	.device_code              = 0xd5,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 2LL*SZ_1G,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 20,
+	.data_hold_in_ns          = 15,
+	.address_setup_in_ns      = 20,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"K9LAG08U0M K9HBG08U1M K9GAG08U0M",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x2c,
+	.device_code              = 0xd5,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 2LL*SZ_1G,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 15,
+	.data_hold_in_ns          = 10,
+	.address_setup_in_ns      = 15,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"Intel JS29F32G08FAMiB1 and Micron MT29F32G08TAA",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x2c,
+	.device_code              = 0xdc,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 512LL*SZ_1M,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 20,
+	.data_hold_in_ns          = 20,
+	.address_setup_in_ns      = 20,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"MT29F4G08",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x89,
+	.device_code              = 0xd3,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 1LL*SZ_1G,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 15,
+	.data_hold_in_ns          = 10,
+	.address_setup_in_ns      = 15,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"JS29F08G08AAMiB2, JS29F08G08CAMiB2",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x89,
+	.device_code              = 0xd5,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 2LL*SZ_1G,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 15,
+	.data_hold_in_ns          = 10,
+	.address_setup_in_ns      = 15,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"JS29F32G08FAMiB2",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0xad,
+	.device_code              = 0xd5,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 2LL*SZ_1G,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 15,
+	.data_hold_in_ns          = 10,
+	.address_setup_in_ns      = 20,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"HY27UW08CGFM",
+	},
+	{true}
+};
+
+/*
+ * Type 7
+ */
+static struct nand_device_info nand_device_info_table_type_7[] __initdata =
+{
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x2c,
+	.device_code              = 0xd3,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
+	.chip_size_in_bytes       = 1LL*SZ_1G,
+	.block_size_in_pages      = 64,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 25,
+	.data_hold_in_ns          = 15,
+	.address_setup_in_ns      = 10,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"MT29F8G08FABWG",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x2c,
+	.device_code              = 0xdc,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
+	.chip_size_in_bytes       = 512LL*SZ_1M,
+	.block_size_in_pages      = 64,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 20,
+	.data_hold_in_ns          = 10,
+	.address_setup_in_ns      = 10,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"MT29F4G08AAA",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0xec,
+	.device_code              = 0xdc,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
+	.chip_size_in_bytes       = 512LL*SZ_1M,
+	.block_size_in_pages      = 64,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 15,
+	.data_hold_in_ns          = 12,
+	.address_setup_in_ns      = 25,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"K9F4G08",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0xec,
+	.device_code              = 0xd3,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
+	.chip_size_in_bytes       = 1LL*SZ_1G,
+	.block_size_in_pages      = 64,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 25,
+	.data_hold_in_ns          = 15,
+	.address_setup_in_ns      = 35,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"K9K8G08UXM, K9NBG08U5A, K9WAG08U1A",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0xec,
+	.device_code              = 0xd5,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
+	.chip_size_in_bytes       = 2LL*SZ_1G,
+	.block_size_in_pages      = 64,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 15,
+	.data_hold_in_ns          = 12,
+	.address_setup_in_ns      = 25,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"K9WAG08UXM",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0xec,
+	.device_code              = 0xda,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
+	.chip_size_in_bytes       = 256LL*SZ_1M,
+	.block_size_in_pages      = 64,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 20,
+	.data_hold_in_ns          = 10,
+	.address_setup_in_ns      = 20,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"K9F2G08U0A",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0xec,
+	.device_code              = 0xf1,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
+	.chip_size_in_bytes       = 128LL*SZ_1M,
+	.block_size_in_pages      = 64,
+	.page_total_size_in_bytes = 2*SZ_1K + 64,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 15,
+	.data_hold_in_ns          = 12,
+	.address_setup_in_ns      = 20,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"K9F1F08",
+	},
+	{true}
+};
+
+/*
+ * Type 8
+ */
+static struct nand_device_info nand_device_info_table_type_8[] __initdata =
+{
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0xec,
+	.device_code              = 0xd5,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 2LL*SZ_1G,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 4*SZ_1K + 128,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 15,
+	.data_hold_in_ns          = 10,
+	.address_setup_in_ns      = 20,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"K9GAG08U0M",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0xec,
+	.device_code              = 0xd7,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 4LL*SZ_1G,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 4*SZ_1K + 128,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 15,
+	.data_hold_in_ns          = 15,
+	.address_setup_in_ns      = 25,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"K9LBG08U0M (32Gb), K9HCG08U1M (64Gb), K9MDG08U5M (128Gb)",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0xad,
+	.device_code              = 0xd5,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 2LL*SZ_1G,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 4*SZ_1K + 128,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 20,
+	.data_hold_in_ns          = 20,
+	.address_setup_in_ns      = 20,
+	.gpmi_sample_delay_in_ns  = 0,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"H27UAG, H27UBG",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0xad,
+	.device_code              = 0xd7,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 4LL*SZ_1G,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 4*SZ_1K + 128,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 23,
+	.data_hold_in_ns          = 20,
+	.address_setup_in_ns      = 25,
+	.gpmi_sample_delay_in_ns  = 0,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"H27UCG",
+	},
+	{true}
+};
+
+/*
+ * Type 9
+ */
+static struct nand_device_info nand_device_info_table_type_9[] __initdata =
+{
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x98,
+	.device_code              = 0xd3,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 1LL*SZ_1G,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 4*SZ_1K + 218,
+	.ecc_strength_in_bits     = 8,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 15,
+	.data_hold_in_ns          = 15,
+	.address_setup_in_ns      = 10,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"TC58NVG3D1DTG00",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x98,
+	.device_code              = 0xd5,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 2LL*SZ_1G,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 4*SZ_1K + 218,
+	.ecc_strength_in_bits     = 8,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 15,
+	.data_hold_in_ns          = 15,
+	.address_setup_in_ns      = 10,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"TC58NVG4D1DTG00",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x98,
+	.device_code              = 0xd7,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 4LL*SZ_1G,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 4*SZ_1K + 218,
+	.ecc_strength_in_bits     = 8,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 15,
+	.data_hold_in_ns          = 15,
+	.address_setup_in_ns      = 10,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"TH58NVG6D1DTG20",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x89,
+	.device_code              = 0xd5,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 2LL*SZ_1G,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 4*SZ_1K + 218,
+	.ecc_strength_in_bits     = 8,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 10,
+	.data_hold_in_ns          = 10,
+	.address_setup_in_ns      = 15,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"JS29F16G08AAMC1, JS29F32G08CAMC1",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x2c,
+	.device_code              = 0xd5,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 2LL*SZ_1G,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 4*SZ_1K + 218,
+	.ecc_strength_in_bits     = 8,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 15,
+	.data_hold_in_ns          = 10,
+	.address_setup_in_ns      = 15,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"MT29F16G08MAA, MT29F32G08QAA",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x2c,
+	.device_code              = 0xd7,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 4LL*SZ_1G,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 4*SZ_1K + 218,
+	.ecc_strength_in_bits     = 8,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 15,
+	.data_hold_in_ns          = 10,
+	.address_setup_in_ns      = 15,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"MT29F64G08TAA (32Gb), MT29F32G08CBAAA (32Gb) MT29F64G08CFAAA (64Gb)",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x2c,
+	.device_code              = 0xd9,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 8LL*SZ_1G,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 4*SZ_1K + 218,
+	.ecc_strength_in_bits     = 8,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 10,
+	.data_hold_in_ns          = 10,
+	.address_setup_in_ns      = 15,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"MT29F128G08CJAAA",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x89,
+	.device_code              = 0xd7,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 4LL*SZ_1G,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 4*SZ_1K + 218,
+	.ecc_strength_in_bits     = 8,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 10,
+	.data_hold_in_ns          = 10,
+	.address_setup_in_ns      = 15,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"JSF64G08FAMC1",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0xec,
+	.device_code              = 0xd7,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 4LL*SZ_1G,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 4*SZ_1K + 218,
+	.ecc_strength_in_bits     = 8,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 20,
+	.data_hold_in_ns          = 10,
+	.address_setup_in_ns      = 25,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"K9LBG08U0D",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0xec,
+	.device_code              = 0xd5,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 2LL*SZ_1G,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 4*SZ_1K + 218,
+	.ecc_strength_in_bits     = 8,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 20,
+	.data_hold_in_ns          = 10,
+	.address_setup_in_ns      = 20,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"K9GAG08U0D, K9LBG08U1D, K9HCG08U5D",
+	},
+	{true}
+};
+
+/*
+ * Type 10
+ */
+static struct nand_device_info nand_device_info_table_type_10[] __initdata =
+{
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0xec,
+	.device_code              = 0xd3,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
+	.chip_size_in_bytes       = 1LL*SZ_1G,
+	.block_size_in_pages      = 64,
+	.page_total_size_in_bytes = 4*SZ_1K + 128,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 15,
+	.data_hold_in_ns          = 10,
+	.address_setup_in_ns      = 20,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	NULL,
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0xec,
+	.device_code              = 0xd5,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
+	.chip_size_in_bytes       = 2LL*SZ_1G,
+	.block_size_in_pages      = 64,
+	.page_total_size_in_bytes = 4*SZ_1K + 128,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 25,
+	.data_hold_in_ns          = 15,
+	.address_setup_in_ns      = 30,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	"K9NCG08U5M",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0xec,
+	.device_code              = 0xd7,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_SLC,
+	.chip_size_in_bytes       = 4LL*SZ_1G,
+	.block_size_in_pages      = 64,
+	.page_total_size_in_bytes = 4*SZ_1K + 128,
+	.ecc_strength_in_bits     = 4,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 15,
+	.data_hold_in_ns          = 15,
+	.address_setup_in_ns      = 25,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = -1,
+	.tRLOH_in_ns              = -1,
+	.tRHOH_in_ns              = -1,
+	NULL,
+	},
+	{true}
+};
+
+/*
+ * Type 11
+ */
+static struct nand_device_info nand_device_info_table_type_11[] __initdata =
+{
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x98,
+	.device_code              = 0xd7,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 4LL*SZ_1G,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 8*SZ_1K + 376,
+	.ecc_strength_in_bits     = 14,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 15,
+	.data_hold_in_ns          = 10,
+	.address_setup_in_ns      = 8,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = 20,
+	.tRLOH_in_ns              = 5,
+	.tRHOH_in_ns              = 25,
+	"TC58NVG5D2ELAM8 (4GB), TH58NVG6D2ELAM8 (8GB)",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x98,
+	.device_code              = 0xde,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 8LL*SZ_1G,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 8*SZ_1K + 376,
+	.ecc_strength_in_bits     = 14,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 15,
+	.data_hold_in_ns          = 10,
+	.address_setup_in_ns      = 8,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = 20,
+	.tRLOH_in_ns              = 5,
+	.tRHOH_in_ns              = 25,
+	"TH58NVG7D2ELAM8",
+	},
+	{true}
+};
+
+/*
+ * Type 15
+ */
+static struct nand_device_info nand_device_info_table_type_15[] __initdata =
+{
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0xec,
+	.device_code              = 0xd7,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 4LL*SZ_1G,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 8*SZ_1K + 436,
+	.ecc_strength_in_bits     = 16,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 20,
+	.data_hold_in_ns          = 10,
+	.address_setup_in_ns      = 25,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = 25,
+	.tRLOH_in_ns              = 5,
+	.tRHOH_in_ns              = 15,
+	"K9GBG08U0M (4GB, 1CE); K9LCG08U1M (8GB, 2CE); K9HDG08U5M (16GB, 4CE)",
+	},
+	{true}
+};
+
+/*
+ * BCH ECC12
+ */
+static struct nand_device_info nand_device_info_table_bch_ecc12[] __initdata =
+{
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0xad,
+	.device_code              = 0xd7,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 4LL*SZ_1G,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 4*SZ_1K + 224,
+	.ecc_strength_in_bits     = 12,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 15,
+	.data_hold_in_ns          = 10,
+	.address_setup_in_ns      = 20,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = 20,
+	.tRLOH_in_ns              = 5,
+	.tRHOH_in_ns              = 15,
+	"H27UBG8T2M (4GB, 1CE), H27UCG8UDM (8GB, 2CE), H27UDG8VEM (16GB, 4CE)",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0xad,
+	.device_code              = 0xde,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 8LL*SZ_1G,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 4*SZ_1K + 224,
+	.ecc_strength_in_bits     = 12,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 15,
+	.data_hold_in_ns          = 10,
+	.address_setup_in_ns      = 20,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = 20,
+	.tRLOH_in_ns              = 5,
+	.tRHOH_in_ns              = 15,
+	"H27UEG8YEM (32GB, 4CE)",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x2c,
+	.device_code              = 0xd7,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 4LL*SZ_1G,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 4*SZ_1K + 218,
+	.ecc_strength_in_bits     = 12,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 10,
+	.data_hold_in_ns          = 10,
+	.address_setup_in_ns      = 15,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = 16,
+	.tRLOH_in_ns              = 5,
+	.tRHOH_in_ns              = 15,
+	"MT29F32G08CBAAA (4GB, 1CE), MT29F64G08CFAAA (8GB, 2CE)",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x2c,
+	.device_code              = 0xd9,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 8LL*SZ_1G,
+	.block_size_in_pages      = 128,
+	.page_total_size_in_bytes = 4*SZ_1K + 218,
+	.ecc_strength_in_bits     = 12,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 10,
+	.data_hold_in_ns          = 10,
+	.address_setup_in_ns      = 15,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = 16,
+	.tRLOH_in_ns              = 5,
+	.tRHOH_in_ns              = 15,
+	"MT29F128G08CJAAA (16GB, 2CE)",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x2c,
+	.device_code              = 0x48,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 2LL*SZ_1G,
+	.block_size_in_pages      = 256,
+	.page_total_size_in_bytes = 4*SZ_1K + 224,
+	.ecc_strength_in_bits     = 12,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 15,
+	.data_hold_in_ns          = 10,
+	.address_setup_in_ns      = 20,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = 20,
+	.tRLOH_in_ns              = 5,
+	.tRHOH_in_ns              = 15,
+	"MT29F16G08CBABA (2GB, 1CE)",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x2c,
+	.device_code              = 0x68,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 4LL*SZ_1G,
+	.block_size_in_pages      = 256,
+	.page_total_size_in_bytes = 4*SZ_1K + 224,
+	.ecc_strength_in_bits     = 12,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 15,
+	.data_hold_in_ns          = 10,
+	.address_setup_in_ns      = 20,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = 20,
+	.tRLOH_in_ns              = 5,
+	.tRHOH_in_ns              = 15,
+	"MT29F32G08CBABA (4GB, 1CE); "
+	"MT29F64G08CEABA (8GB, 2CE); "
+	"MT29F64G08CFABA (8GB, 2CE)",
+	},
+	{
+	.end_of_table             = false,
+	.manufacturer_code        = 0x2c,
+	.device_code              = 0x88,
+	.cell_technology          = NAND_DEVICE_CELL_TECH_MLC,
+	.chip_size_in_bytes       = 8LL*SZ_1G,
+	.block_size_in_pages      = 256,
+	.page_total_size_in_bytes = 4*SZ_1K + 224,
+	.ecc_strength_in_bits     = 12,
+	.ecc_size_in_bytes        = 512,
+	.data_setup_in_ns         = 15,
+	.data_hold_in_ns          = 10,
+	.address_setup_in_ns      = 20,
+	.gpmi_sample_delay_in_ns  = 6,
+	.tREA_in_ns               = 20,
+	.tRLOH_in_ns              = 5,
+	.tRHOH_in_ns              = 15,
+	"MT29F128G08CJABA (16GB, 2CE); "
+	"MT29F128G08CKABA (16GB, 2CE); "
+	"MT29F256G08CUABA (32GB, 4CE)",
+	},
+	{true}
+};
+
+/*
+ * The following macros make it convenient to extract information from an ID
+ * byte array. All these macros begin with the prefix "ID_".
+ *
+ * Macros of the form:
+ *
+ *         ID_GET_[<manufacturer>_[<modifier>_]]<field>
+ *
+ * extract the given field from an ID byte array. Macros of the form:
+ *
+ *         ID_[<manufacturer>_[<modifier>_]]<field>_<meaning>
+ *
+ * contain the value for the given field that has the given meaning.
+ *
+ * If the <manufacturer> appears, it means this macro represents a view of this
+ * field that is specific to the given manufacturer.
+ *
+ * If the <modifier> appears, it means this macro represents a view of this
+ * field that the given manufacturer applies only under specific conditions.
+ *
+ * Here is a simple example:
+ *
+ *         ID_PAGE_SIZE_CODE_2K
+ *
+ * This macro has the value of the "Page Size" field that indicates the page
+ * size is 2K.
+ *
+ * A more complicated example:
+ *
+ *         ID_SAMSUNG_6_BYTE_PAGE_SIZE_CODE_8K  (0x2)
+ *
+ * This macro has the value of the "Page Size" field for Samsung parts that
+ * indicates the page size is 8K. However, this interpretation is only correct
+ * for devices that return 6 ID bytes.
+ */
+
+/* Byte 1 ------------------------------------------------------------------- */
+
+#define ID_GET_BYTE_1(id)    ((id)[0])
+
+#define ID_GET_MFR_CODE(id)  ID_GET_BYTE_1(id)
+
+/* Byte 2 ------------------------------------------------------------------- */
+
+#define ID_GET_BYTE_2(id)                           ((id)[1])
+
+#define ID_GET_DEVICE_CODE(id)                      ID_GET_BYTE_2(id)
+    #define ID_SAMSUNG_DEVICE_CODE_1_GBIT           (0xf1)
+    #define ID_SAMSUNG_DEVICE_CODE_2_GBIT           (0xda)
+    #define ID_HYNIX_DEVICE_CODE_ECC12              (0xd7)
+    #define ID_HYNIX_DEVICE_CODE_ECC12_LARGE        (0xde)
+    #define ID_MICRON_DEVICE_CODE_ECC12             (0xd7) /* ECC12        */
+    #define ID_MICRON_DEVICE_CODE_ECC12_LARGE       (0xd9) /* ECC12 8GB/CE */
+    #define ID_MICRON_DEVICE_CODE_ECC12_2GB_PER_CE  (0x48) /* L63B  2GB/CE */
+    #define ID_MICRON_DEVICE_CODE_ECC12_4GB_PER_CE  (0x68) /* L63B  4GB/CE */
+    #define ID_MICRON_DEVICE_CODE_ECC12_8GB_PER_CE  (0x88) /* L63B  8GB/CE */
+
+/* Byte 3 ------------------------------------------------------------------- */
+
+#define ID_GET_BYTE_3(id)               ((id)[2])
+
+#define ID_GET_DIE_COUNT_CODE(id)       ((ID_GET_BYTE_3(id) >> 0) & 0x3)
+
+#define ID_GET_CELL_TYPE_CODE(id)       ((ID_GET_BYTE_3(id) >> 2) & 0x3)
+    #define ID_CELL_TYPE_CODE_SLC       (0x0) /* All others => MLC. */
+
+#define ID_GET_SAMSUNG_SIMUL_PROG(id)   ((ID_GET_BYTE_3(id) >> 4) & 0x3)
+
+#define ID_GET_MICRON_SIMUL_PROG(id)    ((ID_GET_BYTE_3(id) >> 4) & 0x3)
+
+#define ID_GET_CACHE_PROGRAM(id)        ((ID_GET_BYTE_3(id) >> 7) & 0x1)
+
+/* Byte 4 ------------------------------------------------------------------- */
+
+#define ID_GET_BYTE_4(id)                       ((id)[3])
+    #define ID_HYNIX_BYTE_4_ECC12_DEVICE        (0x25)
+
+#define ID_GET_PAGE_SIZE_CODE(id)               ((ID_GET_BYTE_4(id) >> 0) & 0x3)
+    #define ID_PAGE_SIZE_CODE_1K                (0x0)
+    #define ID_PAGE_SIZE_CODE_2K                (0x1)
+    #define ID_PAGE_SIZE_CODE_4K                (0x2)
+    #define ID_PAGE_SIZE_CODE_8K                (0x3)
+    #define ID_SAMSUNG_6_BYTE_PAGE_SIZE_CODE_8K (0x2)
+
+#define ID_GET_OOB_SIZE_CODE(id)                ((ID_GET_BYTE_4(id) >> 2) & 0x1)
+
+#define ID_GET_BLOCK_SIZE_CODE(id)              ((ID_GET_BYTE_4(id) >> 4) & 0x3)
+
+/* Byte 5 ------------------------------------------------------------------- */
+
+#define ID_GET_BYTE_5(id)                  ((id)[4])
+    #define ID_MICRON_BYTE_5_ECC12         (0x84)
+
+#define ID_GET_SAMSUNG_ECC_LEVEL_CODE(id)  ((ID_GET_BYTE_5(id) >> 4) & 0x7)
+    #define ID_SAMSUNG_ECC_LEVEL_CODE_8    (0x03)
+    #define ID_SAMSUNG_ECC_LEVEL_CODE_24   (0x05)
+
+#define ID_GET_PLANE_COUNT_CODE(id)        ((ID_GET_BYTE_5(id) >> 2) & 0x3)
+
+/* Byte 6 ------------------------------------------------------------------- */
+
+#define ID_GET_BYTE_6(id)                        ((id)[5])
+    #define ID_TOSHIBA_BYTE_6_PAGE_SIZE_CODE_8K  (0x54)
+    #define ID_TOSHIBA_BYTE_6_PAGE_SIZE_CODE_4K  (0x13)
+
+#define ID_GET_SAMSUNG_DEVICE_VERSION_CODE(id)   ((ID_GET_BYTE_6(id)>>0) & 0x7)
+    #define ID_SAMSUNG_DEVICE_VERSION_CODE_40NM  (0x01)
+
+/* -------------------------------------------------------------------------- */
+
+void nand_device_print_info(struct nand_device_info *info)
+{
+	unsigned    i;
+	const char  *mfr_name;
+	const char  *cell_technology_name;
+	uint64_t    chip_size;
+	const char  *chip_size_units;
+	unsigned    page_data_size_in_bytes;
+	unsigned    page_oob_size_in_bytes;
+
+	/* Check for nonsense. */
+
+	if (!info)
+		return;
+
+	/* Prepare the manufacturer name. */
+
+	mfr_name = "Unknown";
+
+	for (i = 0; nand_manuf_ids[i].id; i++) {
+		if (nand_manuf_ids[i].id == info->manufacturer_code) {
+			mfr_name = nand_manuf_ids[i].name;
+			break;
+		}
+	}
+
+	/* Prepare the name of the cell technology. */
+
+	switch (info->cell_technology) {
+	case NAND_DEVICE_CELL_TECH_SLC:
+		cell_technology_name = "SLC";
+		break;
+	case NAND_DEVICE_CELL_TECH_MLC:
+		cell_technology_name = "MLC";
+		break;
+	default:
+		cell_technology_name = "Unknown";
+		break;
+	}
+
+	/* Prepare the chip size. */
+
+	if ((info->chip_size_in_bytes >= SZ_1G) &&
+					!(info->chip_size_in_bytes % SZ_1G)) {
+		chip_size       = info->chip_size_in_bytes / ((uint64_t) SZ_1G);
+		chip_size_units = "GiB";
+	} else if ((info->chip_size_in_bytes >= SZ_1M) &&
+					!(info->chip_size_in_bytes % SZ_1M)) {
+		chip_size       = info->chip_size_in_bytes / ((uint64_t) SZ_1M);
+		chip_size_units = "MiB";
+	} else {
+		chip_size       = info->chip_size_in_bytes;
+		chip_size_units = "B";
+	}
+
+	/* Prepare the page geometry. */
+
+	page_data_size_in_bytes = (1<<(fls(info->page_total_size_in_bytes)-1));
+	page_oob_size_in_bytes  = info->page_total_size_in_bytes -
+							page_data_size_in_bytes;
+
+	/* Print the information. */
+
+	printk(KERN_INFO "Manufacturer      : %s (0x%02x)\n",  mfr_name,
+						info->manufacturer_code);
+	printk(KERN_INFO "Device Code       : 0x%02x\n", info->device_code);
+	printk(KERN_INFO "Cell Technology   : %s\n", cell_technology_name);
+	printk(KERN_INFO "Chip Size         : %llu %s\n", chip_size,
+							chip_size_units);
+	printk(KERN_INFO "Pages per Block   : %u\n",
+						info->block_size_in_pages);
+	printk(KERN_INFO "Page Geometry     : %u+%u\n", page_data_size_in_bytes,
+						page_oob_size_in_bytes);
+	printk(KERN_INFO "ECC Strength      : %u bits\n",
+						info->ecc_strength_in_bits);
+	printk(KERN_INFO "ECC Size          : %u B\n", info->ecc_size_in_bytes);
+	printk(KERN_INFO "Data Setup Time   : %u ns\n", info->data_setup_in_ns);
+	printk(KERN_INFO "Data Hold Time    : %u ns\n", info->data_hold_in_ns);
+	printk(KERN_INFO "Address Setup Time: %u ns\n",
+						info->address_setup_in_ns);
+	printk(KERN_INFO "GPMI Sample Delay : %u ns\n",
+						info->gpmi_sample_delay_in_ns);
+	if (info->tREA_in_ns >= 0)
+		printk(KERN_INFO "tREA              : %u ns\n",
+							info->tREA_in_ns);
+	else
+		printk(KERN_INFO "tREA              : Unknown\n");
+	if (info->tREA_in_ns >= 0)
+		printk(KERN_INFO "tRLOH             : %u ns\n",
+							info->tRLOH_in_ns);
+	else
+		printk(KERN_INFO "tRLOH             : Unknown\n");
+	if (info->tREA_in_ns >= 0)
+		printk(KERN_INFO "tRHOH             : %u ns\n",
+							info->tRHOH_in_ns);
+	else
+		printk(KERN_INFO "tRHOH             : Unknown\n");
+	if (info->description)
+		printk(KERN_INFO "Description       : %s\n", info->description);
+	else
+		printk(KERN_INFO "Description       : <None>\n");
+
+}
+
+static struct nand_device_info *nand_device_info_search(
+	struct nand_device_info *table, uint8_t mfr_code, uint8_t device_code)
+{
+
+	for (; !table->end_of_table; table++) {
+		if (table->manufacturer_code != mfr_code)
+			continue;
+		if (table->device_code != device_code)
+			continue;
+		return table;
+	}
+
+	return 0;
+
+}
+
+static struct nand_device_info * __init nand_device_info_fn_toshiba(const uint8_t id[])
+{
+	struct nand_device_info  *table;
+
+	/* Check for an SLC device. */
+
+	if (ID_GET_CELL_TYPE_CODE(id) == ID_CELL_TYPE_CODE_SLC) {
+		/* Type 2 */
+		return nand_device_info_search(nand_device_info_table_type_2,
+				ID_GET_MFR_CODE(id), ID_GET_DEVICE_CODE(id));
+	}
+
+	/*
+	 * Look for 8K page Toshiba MLC devices.
+	 *
+	 * The page size field in byte 4 can't be used because the field was
+	 * redefined in the 8K parts so the value meaning "8K page" is the same
+	 * as the value meaning "4K page" on the 4K page devices.
+	 *
+	 * The only identifiable difference between the 4K and 8K page Toshiba
+	 * devices with a device code of 0xd7 is the undocumented 6th ID byte.
+	 * The 4K device returns a value of 0x13 and the 8K a value of 0x54.
+	 * Toshiba has verified that this is an acceptable method to distinguish
+	 * the two device families.
+	 */
+
+	if (ID_GET_BYTE_6(id) == ID_TOSHIBA_BYTE_6_PAGE_SIZE_CODE_8K) {
+		/* Type 11 */
+		table = nand_device_info_table_type_11;
+	} else if (ID_GET_PAGE_SIZE_CODE(id) == ID_PAGE_SIZE_CODE_4K) {
+		/* Type 9 */
+		table = nand_device_info_table_type_9;
+	} else {
+		/* Large MLC */
+		table = nand_device_info_table_large_mlc;
+	}
+
+	return nand_device_info_search(table, ID_GET_MFR_CODE(id),
+							ID_GET_DEVICE_CODE(id));
+
+}
+
+static struct nand_device_info * __init nand_device_info_fn_samsung(const uint8_t id[])
+{
+	struct nand_device_info  *table;
+
+	/* Check for an MLC device. */
+
+	if (ID_GET_CELL_TYPE_CODE(id) != ID_CELL_TYPE_CODE_SLC) {
+
+		/* Is this a Samsung 8K Page MLC device with 16 bit ECC? */
+		if ((ID_GET_SAMSUNG_ECC_LEVEL_CODE(id) ==
+					ID_SAMSUNG_ECC_LEVEL_CODE_24) &&
+		    (ID_GET_PAGE_SIZE_CODE(id) ==
+					ID_SAMSUNG_6_BYTE_PAGE_SIZE_CODE_8K)) {
+			/* Type 15 */
+			table = nand_device_info_table_type_15;
+		}
+		/* Is this a Samsung 42nm ECC8 device with a 6 byte ID? */
+		else if ((ID_GET_SAMSUNG_ECC_LEVEL_CODE(id) ==
+					ID_SAMSUNG_ECC_LEVEL_CODE_8) &&
+			(ID_GET_SAMSUNG_DEVICE_VERSION_CODE(id) ==
+					ID_SAMSUNG_DEVICE_VERSION_CODE_40NM)) {
+			/* Type 9 */
+			table = nand_device_info_table_type_9;
+		} else if (ID_GET_PAGE_SIZE_CODE(id) == ID_PAGE_SIZE_CODE_4K) {
+			/* Type 8 */
+			table = nand_device_info_table_type_8;
+		} else {
+			/* Large MLC */
+			table = nand_device_info_table_large_mlc;
+		}
+
+	} else {
+
+		/* Check the page size first. */
+		if (ID_GET_PAGE_SIZE_CODE(id) == ID_PAGE_SIZE_CODE_4K) {
+			/* Type 10 */
+			table = nand_device_info_table_type_10;
+		}
+		/* Check the chip size. */
+		else if (ID_GET_DEVICE_CODE(id) ==
+						ID_SAMSUNG_DEVICE_CODE_1_GBIT) {
+			if (!ID_GET_CACHE_PROGRAM(id)) {
+				/*
+				 * 128 MiB Samsung chips without cache program
+				 * are Type 7.
+				 *
+				 * The K9F1G08U0B does not support multi-plane
+				 * program, so the if statement below cannot be
+				 * used to identify it.
+				 */
+				table = nand_device_info_table_type_7;
+
+			} else {
+				/* Smaller sizes are Type 2 by default. */
+				table = nand_device_info_table_type_2;
+			}
+		} else {
+			/* Check number of simultaneously programmed pages. */
+			if (ID_GET_SAMSUNG_SIMUL_PROG(id) &&
+						ID_GET_PLANE_COUNT_CODE(id)) {
+				/* Type 7 */
+				table = nand_device_info_table_type_7;
+			} else {
+				/* Type 2 */
+				table = nand_device_info_table_type_2;
+			}
+
+		}
+
+	}
+
+	return nand_device_info_search(table, ID_GET_MFR_CODE(id),
+							ID_GET_DEVICE_CODE(id));
+
+}
+
+static struct nand_device_info * __init nand_device_info_fn_stmicro(const uint8_t id[])
+{
+	struct nand_device_info  *table;
+
+	/* Check for an SLC device. */
+
+	if (ID_GET_CELL_TYPE_CODE(id) == ID_CELL_TYPE_CODE_SLC)
+		/* Type 2 */
+		table = nand_device_info_table_type_2;
+	else
+		/* Large MLC */
+		table = nand_device_info_table_large_mlc;
+
+	return nand_device_info_search(table, ID_GET_MFR_CODE(id),
+							ID_GET_DEVICE_CODE(id));
+
+}
+
+static struct nand_device_info * __init nand_device_info_fn_hynix(const uint8_t id[])
+{
+	struct nand_device_info  *table;
+
+	/* Check for an SLC device. */
+
+	if (ID_GET_CELL_TYPE_CODE(id) == ID_CELL_TYPE_CODE_SLC) {
+		/* Type 2 */
+		return nand_device_info_search(nand_device_info_table_type_2,
+				ID_GET_MFR_CODE(id), ID_GET_DEVICE_CODE(id));
+	}
+
+	/*
+	 * Check for ECC12 devices.
+	 *
+	 * We look at the 4th ID byte to distinguish some Hynix ECC12 devices
+	 * from the similar ECC8 part. For example H27UBG8T2M (ECC12) 4th byte
+	 * is 0x25, whereas H27UDG8WFM (ECC8) 4th byte is 0xB6.
+	 */
+
+	if ((ID_GET_DEVICE_CODE(id) == ID_HYNIX_DEVICE_CODE_ECC12 &&
+			ID_GET_BYTE_4(id) == ID_HYNIX_BYTE_4_ECC12_DEVICE) ||
+	    (ID_GET_DEVICE_CODE(id) == ID_HYNIX_DEVICE_CODE_ECC12_LARGE)) {
+		/* BCH ECC 12 */
+		table = nand_device_info_table_bch_ecc12;
+	} else if (ID_GET_PAGE_SIZE_CODE(id) == ID_PAGE_SIZE_CODE_4K) {
+		/*
+		 * So far, all other Samsung and Hynix 4K page devices are
+		 * Type 8.
+		 */
+		table = nand_device_info_table_type_8;
+	} else
+		/* Large MLC */
+		table = nand_device_info_table_large_mlc;
+
+	return nand_device_info_search(table, ID_GET_MFR_CODE(id),
+							ID_GET_DEVICE_CODE(id));
+
+}
+
+static struct nand_device_info * __init nand_device_info_fn_micron(const uint8_t id[])
+{
+	struct nand_device_info  *table;
+
+	/* Check for an SLC device. */
+
+	if (ID_GET_CELL_TYPE_CODE(id) == ID_CELL_TYPE_CODE_SLC) {
+
+		/* Check number of simultaneously programmed pages. */
+
+		if (ID_GET_MICRON_SIMUL_PROG(id)) {
+			/* Type 7 */
+			table = nand_device_info_table_type_7;
+		} else {
+			/* Zero simultaneously programmed pages means Type 2. */
+			table = nand_device_info_table_type_2;
+		}
+
+		return nand_device_info_search(table, ID_GET_MFR_CODE(id),
+							ID_GET_DEVICE_CODE(id));
+
+	}
+
+	/*
+	 * We look at the 5th ID byte to distinguish some Micron ECC12 NANDs
+	 * from the similar ECC8 part.
+	 *
+	 * For example MT29F64G08CFAAA (ECC12) 5th byte is 0x84, whereas
+	 * MT29F64G08TAA (ECC8) 5th byte is 0x78.
+	 *
+	 * We also have a special case for the Micron L63B family
+	 * (256 page/block), which has unique device codes but no ID fields that
+	 * can easily be used to distinguish the family.
+	 */
+
+	if ((ID_GET_DEVICE_CODE(id) == ID_MICRON_DEVICE_CODE_ECC12 &&
+				ID_GET_BYTE_5(id) == ID_MICRON_BYTE_5_ECC12)  ||
+	   (ID_GET_DEVICE_CODE(id) == ID_MICRON_DEVICE_CODE_ECC12_LARGE)      ||
+	   (ID_GET_DEVICE_CODE(id) == ID_MICRON_DEVICE_CODE_ECC12_2GB_PER_CE) ||
+	   (ID_GET_DEVICE_CODE(id) == ID_MICRON_DEVICE_CODE_ECC12_4GB_PER_CE) ||
+	   (ID_GET_DEVICE_CODE(id) == ID_MICRON_DEVICE_CODE_ECC12_8GB_PER_CE)) {
+		/* BCH ECC 12 */
+		table = nand_device_info_table_bch_ecc12;
+	} else if (ID_GET_PAGE_SIZE_CODE(id) == ID_PAGE_SIZE_CODE_4K) {
+		/* Toshiba devices with 4K pages are Type 9. */
+		table = nand_device_info_table_type_9;
+	} else {
+		/* Large MLC */
+		table = nand_device_info_table_large_mlc;
+	}
+
+	return nand_device_info_search(table, ID_GET_MFR_CODE(id),
+							ID_GET_DEVICE_CODE(id));
+
+}
+
+static struct nand_device_info * __init nand_device_info_fn_sandisk(const uint8_t id[])
+{
+	struct nand_device_info  *table;
+
+	if (ID_GET_CELL_TYPE_CODE(id) != ID_CELL_TYPE_CODE_SLC) {
+		/* Large MLC */
+		table = nand_device_info_table_large_mlc;
+	} else {
+		/* Type 2 */
+		table = nand_device_info_table_type_2;
+	}
+
+	return nand_device_info_search(table, ID_GET_MFR_CODE(id),
+							ID_GET_DEVICE_CODE(id));
+
+}
+
+static struct nand_device_info * __init nand_device_info_fn_intel(const uint8_t id[])
+{
+	struct nand_device_info  *table;
+
+	/* Check for an SLC device. */
+
+	if (ID_GET_CELL_TYPE_CODE(id) == ID_CELL_TYPE_CODE_SLC) {
+		/* Type 2 */
+		return nand_device_info_search(nand_device_info_table_type_2,
+				ID_GET_MFR_CODE(id), ID_GET_DEVICE_CODE(id));
+	}
+
+	if (ID_GET_PAGE_SIZE_CODE(id) == ID_PAGE_SIZE_CODE_4K) {
+		/* Type 9 */
+		table = nand_device_info_table_type_9;
+	} else {
+		/* Large MLC */
+		table = nand_device_info_table_large_mlc;
+	}
+
+	return nand_device_info_search(table, ID_GET_MFR_CODE(id),
+							ID_GET_DEVICE_CODE(id));
+
+}
+
+/**
+ * struct nand_device_type_info - Information about a NAND Flash type.
+ *
+ * @name:   A human-readable name for this type.
+ * @table:  The device info table for this type.
+ */
+
+struct nand_device_type_info {
+	struct nand_device_info  *table;
+	const char               *name;
+};
+
+/*
+ * A table that maps manufacturer IDs to device information tables.
+ */
+
+static struct nand_device_type_info  nand_device_type_directory[] __initdata =
+{
+	{nand_device_info_table_type_2,    "Type 2"   },
+	{nand_device_info_table_large_mlc, "Large MLC"},
+	{nand_device_info_table_type_7,    "Type 7"   },
+	{nand_device_info_table_type_8,    "Type 8"   },
+	{nand_device_info_table_type_9,    "Type 9"   },
+	{nand_device_info_table_type_10,   "Type 10"  },
+	{nand_device_info_table_type_11,   "Type 11"  },
+	{nand_device_info_table_type_15,   "Type 15"  },
+	{nand_device_info_table_bch_ecc12, "BCH ECC12"},
+	{0, 0},
+};
+
+/**
+ * struct nand_device_mfr_info - Information about a NAND Flash manufacturer.
+ *
+ * @id:     The value of the first NAND Flash ID byte, which identifies the
+ *          manufacturer.
+ * @fn:     A pointer to a function to use for identifying devices from the
+ *          given manufacturer.
+ */
+
+struct nand_device_mfr_info {
+	uint8_t                  id;
+	struct nand_device_info  *(*fn)(const uint8_t id[]);
+};
+
+/*
+ * A table that maps manufacturer IDs to device information tables.
+ */
+
+static struct nand_device_mfr_info  nand_device_mfr_directory[] __initdata =
+{
+	{
+	.id = NAND_MFR_TOSHIBA,
+	.fn = nand_device_info_fn_toshiba,
+	},
+	{
+	.id = NAND_MFR_SAMSUNG,
+	.fn = nand_device_info_fn_samsung,
+	},
+	{
+	.id = NAND_MFR_FUJITSU,
+	.fn = 0,
+	},
+	{
+	.id = NAND_MFR_NATIONAL,
+	.fn = 0,
+	},
+	{
+	.id = NAND_MFR_RENESAS,
+	.fn = 0,
+	},
+	{
+	.id = NAND_MFR_STMICRO,
+	.fn = nand_device_info_fn_stmicro,
+	},
+	{
+	.id = NAND_MFR_HYNIX,
+	.fn = nand_device_info_fn_hynix,
+	},
+	{
+	.id = NAND_MFR_MICRON,
+	.fn = nand_device_info_fn_micron,
+	},
+	{
+	.id = NAND_MFR_AMD,
+	.fn = 0,
+	},
+	{
+	.id = NAND_MFR_SANDISK,
+	.fn = nand_device_info_fn_sandisk,
+	},
+	{
+	.id = NAND_MFR_INTEL,
+	.fn = nand_device_info_fn_intel,
+	},
+	{0, 0}
+};
+
+/**
+ * nand_device_info_test_table - Validate a device info table.
+ *
+ * This function runs tests on the given device info table to check that it
+ * meets the current assumptions.
+ */
+
+static void __init nand_device_info_test_table(
+			struct nand_device_info *table, const char * name)
+{
+	unsigned  i;
+	unsigned  j;
+	uint8_t   mfr_code;
+	uint8_t   device_code;
+
+	/* Loop over entries in this table. */
+
+	for (i = 0; !table[i].end_of_table; i++) {
+
+		/* Get discriminating attributes of the current device. */
+
+		mfr_code    = table[i].manufacturer_code;
+		device_code = table[i].device_code;
+
+		/* Compare with the remaining devices in this table. */
+
+		for (j = i + 1; !table[j].end_of_table; j++) {
+			if ((mfr_code    == table[j].manufacturer_code) &&
+			    (device_code == table[j].device_code))
+				goto error;
+		}
+
+	}
+
+	return;
+
+error:
+
+	printk(KERN_EMERG
+		"\n== NAND Flash device info table failed validity check ==\n");
+
+	printk(KERN_EMERG "\nDevice Info Table: %s\n", name);
+	printk(KERN_EMERG "\nTable Index %u\n", i);
+	nand_device_print_info(table + i);
+	printk(KERN_EMERG "\nTable Index %u\n", j);
+	nand_device_print_info(table + j);
+	printk(KERN_EMERG "\n");
+
+	BUG();
+
+}
+
+/**
+ * nand_device_info_test_data - Test the NAND Flash device data.
+ */
+
+static void __init nand_device_info_test_data(void)
+{
+
+	unsigned  i;
+
+	for (i = 0; nand_device_type_directory[i].name; i++) {
+		nand_device_info_test_table(
+					nand_device_type_directory[i].table,
+					nand_device_type_directory[i].name);
+	}
+
+}
+
+struct nand_device_info * __init nand_device_get_info(const uint8_t id[])
+{
+	unsigned                 i;
+	uint8_t                  mfr_id = ID_GET_MFR_CODE(id);
+	struct nand_device_info  *(*fn)(const uint8_t id[]) = 0;
+
+	/* Test the data. */
+
+	nand_device_info_test_data();
+
+	/* Look for information about this manufacturer. */
+
+	for (i = 0; nand_device_mfr_directory[i].id; i++) {
+		if (nand_device_mfr_directory[i].id == mfr_id) {
+			fn = nand_device_mfr_directory[i].fn;
+			break;
+		}
+	}
+
+	if (!fn)
+		return 0;
+
+	/*
+	 * If control arrives here, we found both a table of device information,
+	 * and a function we can use to identify the current device. Attempt to
+	 * identify the device and return the result.
+	 */
+
+	return fn(id);
+
+}
diff -urNBb -x linux-2.6.31.9-ER1-efikamx/Documentation/dontdiff linux-2.6.31.9-ER1-efikamx.orig/drivers/mtd/nand/nand_device_info.h linux-2.6.31.9-ER1-efikamx/drivers/mtd/nand/nand_device_info.h
--- linux-2.6.31.9-ER1-efikamx.orig/drivers/mtd/nand/nand_device_info.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.31.9-ER1-efikamx/drivers/mtd/nand/nand_device_info.h	2010-01-07 22:20:55.379808292 -0600
@@ -0,0 +1,140 @@
+/*
+ * Copyright 2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __DRIVERS_NAND_DEVICE_INFO_H
+#define __DRIVERS_NAND_DEVICE_INFO_H
+
+ /*
+  * The number of ID bytes to read from the NAND Flash device and hand over to
+  * the identification system.
+  */
+
+#define NAND_DEVICE_ID_BYTE_COUNT  (6)
+
+ /*
+  * The number of ID bytes to read from the NAND Flash device and hand over to
+  * the identification system.
+  */
+
+enum nand_device_cell_technology {
+	NAND_DEVICE_CELL_TECH_SLC = 0,
+	NAND_DEVICE_CELL_TECH_MLC = 1,
+};
+
+/**
+ * struct nand_device_info - Information about a single NAND Flash device.
+ *
+ * This structure contains all the *essential* information about a NAND Flash
+ * device, derived from the device's data sheet. For each manufacturer, we have
+ * an array of these structures.
+ *
+ * @end_of_table:              If true, marks the end of a table of device
+ *                             information.
+ * @manufacturer_code:         The manufacturer code (1st ID byte) reported by
+ *                             the device.
+ * @device_code:               The device code (2nd ID byte) reported by the
+ *                             device.
+ * @cell_technology:           The storage cell technology.
+ * @chip_size_in_bytes:        The total size of the storage behind a single
+ *                             chip select, in bytes. Notice that this is *not*
+ *                             necessarily the total size of the storage in a
+ *                             *package*, which may contain several chips.
+ * @block_size_in_pages:       The number of pages in a block.
+ * @page_total_size_in_bytes:  The total size of a page, in bytes, including
+ *                             both the data and the OOB.
+ * @ecc_strength_in_bits:      The strength of the ECC called for by the
+ *                             manufacturer, in number of correctable bits.
+ * @ecc_size_in_bytes:         The size of the data block over which the
+ *                             manufacturer calls for the given ECC algorithm
+ *                             and strength.
+ * @data_setup_in_ns:          The data setup time, in nanoseconds. Usually the
+ *                             maximum of tDS and tWP. A negative value
+ *                             indicates this characteristic isn't known.
+ * @data_hold_in_ns:           The data hold time, in nanoseconds. Usually the
+ *                             maximum of tDH, tWH and tREH. A negative value
+ *                             indicates this characteristic isn't known.
+ * @address_setup_in_ns:       The address setup time, in nanoseconds. Usually
+ *                             the maximum of tCLS, tCS and tALS. A negative
+ *                             value indicates this characteristic isn't known.
+ * @gpmi_sample_delay_in_ns:   A GPMI-specific timing parameter. A negative
+ *                             value indicates this characteristic isn't known.
+ * @tREA_in_ns:                tREA, in nanoseconds, from the data sheet. A
+ *                             negative value indicates this characteristic
+ *                             isn't known.
+ * @tRLOH_in_ns:               tRLOH, in nanoseconds, from the data sheet. A
+ *                             negative value indicates this characteristic
+ *                             isn't known.
+ * @tRHOH_in_ns:               tRHOH, in nanoseconds, from the data sheet. A
+ *                             negative value indicates this characteristic
+ *                             isn't known.
+ */
+
+struct nand_device_info {
+
+	/* End of table marker */
+
+	bool      end_of_table;
+
+	/* Manufacturer and Device codes */
+
+	uint8_t   manufacturer_code;
+	uint8_t   device_code;
+
+	/* Technology */
+
+	enum nand_device_cell_technology  cell_technology;
+
+	/* Geometry */
+
+	uint64_t  chip_size_in_bytes;
+	uint32_t  block_size_in_pages;
+	uint16_t  page_total_size_in_bytes;
+
+	/* ECC */
+
+	uint8_t   ecc_strength_in_bits;
+	uint16_t  ecc_size_in_bytes;
+
+	/* Timing */
+
+	int8_t    data_setup_in_ns;
+	int8_t    data_hold_in_ns;
+	int8_t    address_setup_in_ns;
+	int8_t    gpmi_sample_delay_in_ns;
+	int8_t    tREA_in_ns;
+	int8_t    tRLOH_in_ns;
+	int8_t    tRHOH_in_ns;
+
+	/* Description */
+
+	const char  *description;
+
+};
+
+/**
+ * nand_device_get_info - Get info about a device based on ID bytes.
+ *
+ * @id_bytes:  An array of NAND_DEVICE_ID_BYTE_COUNT ID bytes retrieved from the
+ *             NAND Flash device.
+ */
+
+struct nand_device_info *nand_device_get_info(const uint8_t id_bytes[]);
+
+/**
+ * nand_device_print_info - Prints information about a NAND Flash device.
+ *
+ * @info  A pointer to a NAND Flash device information structure.
+ */
+
+void nand_device_print_info(struct nand_device_info *info);
+
+#endif
diff -urNBb -x linux-2.6.31.9-ER1-efikamx/Documentation/dontdiff linux-2.6.31.9-ER1-efikamx.orig/drivers/mxc/ipu3/ipu_common.c linux-2.6.31.9-ER1-efikamx/drivers/mxc/ipu3/ipu_common.c
--- linux-2.6.31.9-ER1-efikamx.orig/drivers/mxc/ipu3/ipu_common.c	2009-12-12 13:16:57.000000000 -0600
+++ linux-2.6.31.9-ER1-efikamx/drivers/mxc/ipu3/ipu_common.c	2010-01-07 22:20:55.421524653 -0600
@@ -28,6 +28,8 @@
 #include <linux/io.h>
 #include <linux/ipu.h>
 #include <linux/clk.h>
+#include <mach/clock.h>
+#include <mach/mxc_dvfs.h>
 
 #include "ipu_prv.h"
 #include "ipu_regs.h"
@@ -44,6 +46,7 @@
 struct clk *g_ipu_clk;
 bool g_ipu_clk_enabled;
 struct clk *g_di_clk[2];
+struct clk *g_pixel_clk[2];
 struct clk *g_csi_clk[2];
 unsigned char g_dc_di_assignment[10];
 ipu_channel_t g_ipu_csi_channel[2];
@@ -137,6 +140,115 @@
 #define idma_mask(ch)		(idma_is_valid(ch) ? (1UL << (ch & 0x1F)) : 0)
 #define idma_is_set(reg, dma)	(__raw_readl(reg(dma)) & idma_mask(dma))
 
+static void _ipu_pixel_clk_recalc(struct clk *clk)
+{
+	u32 div = __raw_readl(DI_BS_CLKGEN0(clk->id));
+	if (div == 0)
+		clk->rate = 0;
+	else
+		clk->rate = (clk->parent->rate * 16) / div;
+}
+
+static unsigned long _ipu_pixel_clk_round_rate(struct clk *clk, unsigned long rate)
+{
+	u32 div, div1;
+	u32 tmp;
+	/*
+	 * Calculate divider
+	 * Fractional part is 4 bits,
+	 * so simply multiply by 2^4 to get fractional part.
+	 */
+	tmp = (clk->parent->rate * 16);
+	div = tmp / rate;
+
+	if (div < 0x10)            /* Min DI disp clock divider is 1 */
+		div = 0x10;
+	if (div & ~0xFEF)
+		div &= 0xFF8;
+	else {
+		div1 = div & 0xFE0;
+		if ((tmp/div1 - tmp/div) < rate / 4)
+			div = div1;
+		else
+			div &= 0xFF8;
+	}
+	return (clk->parent->rate * 16) / div;
+}
+
+static int _ipu_pixel_clk_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 div = (clk->parent->rate * 16) / rate;
+
+	__raw_writel(div, DI_BS_CLKGEN0(clk->id));
+
+	/* Setup pixel clock timing */
+	/* FIXME: needs to be more flexible */
+	/* Down time is half of period */
+	__raw_writel((div / 16) << 16, DI_BS_CLKGEN1(clk->id));
+
+	clk->rate = (clk->parent->rate * 16) / div;
+	return 0;
+}
+
+static int _ipu_pixel_clk_enable(struct clk *clk)
+{
+	u32 disp_gen = __raw_readl(IPU_DISP_GEN);
+	disp_gen |= clk->id ? DI1_COUNTER_RELEASE : DI0_COUNTER_RELEASE;
+	__raw_writel(disp_gen, IPU_DISP_GEN);
+
+	start_dvfs_per();
+
+	return 0;
+}
+
+static void _ipu_pixel_clk_disable(struct clk *clk)
+{
+	u32 disp_gen = __raw_readl(IPU_DISP_GEN);
+	disp_gen &= clk->id ? ~DI1_COUNTER_RELEASE : ~DI0_COUNTER_RELEASE;
+	__raw_writel(disp_gen, IPU_DISP_GEN);
+
+	start_dvfs_per();
+}
+
+static int _ipu_pixel_clk_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 di_gen = __raw_readl(DI_GENERAL(clk->id));
+
+	if (parent == g_ipu_clk)
+		di_gen &= ~DI_GEN_DI_CLK_EXT;
+	else if (!IS_ERR(g_di_clk[clk->id]) && parent == g_di_clk[clk->id])
+		di_gen |= DI_GEN_DI_CLK_EXT;
+	else
+		return -EINVAL;
+
+	__raw_writel(di_gen, DI_GENERAL(clk->id));
+	_ipu_pixel_clk_recalc(clk);
+	return 0;
+}
+
+static struct clk pixel_clk[] = {
+	{
+	.name = "pixel_clk",
+	.id = 0,
+	.recalc = _ipu_pixel_clk_recalc,
+	.set_rate = _ipu_pixel_clk_set_rate,
+	.round_rate = _ipu_pixel_clk_round_rate,
+	.set_parent = _ipu_pixel_clk_set_parent,
+	.enable = _ipu_pixel_clk_enable,
+	.disable = _ipu_pixel_clk_disable,
+	},
+	{
+	.name = "pixel_clk",
+	.id = 1,
+	.recalc = _ipu_pixel_clk_recalc,
+	.set_rate = _ipu_pixel_clk_set_rate,
+	.round_rate = _ipu_pixel_clk_round_rate,
+	.set_parent = _ipu_pixel_clk_set_parent,
+	.enable = _ipu_pixel_clk_enable,
+	.disable = _ipu_pixel_clk_disable,
+	},
+};
+
 /*!
  * This function resets IPU
  */
@@ -166,7 +278,6 @@
 	struct resource *res;
 	struct mxc_ipu_config *plat_data = pdev->dev.platform_data;
 	unsigned long ipu_base;
-	u32 reg;
 
 	spin_lock_init(&ipu_lock);
 
@@ -233,6 +344,11 @@
 	dev_dbg(g_ipu_dev, "IPU DC Template Mem = %p\n", ipu_dc_tmpl_reg);
 	dev_dbg(g_ipu_dev, "IPU Display Region 1 Mem = %p\n", ipu_disp_base[1]);
 
+	g_pixel_clk[0] = &pixel_clk[0];
+	clk_register(g_pixel_clk[0]);
+	g_pixel_clk[1] = &pixel_clk[1];
+	clk_register(g_pixel_clk[1]);
+
 	/* Enable IPU and CSI clocks */
 	/* Get IPU clock freq */
 	g_ipu_clk = clk_get(&pdev->dev, "ipu_clk");
@@ -240,6 +356,8 @@
 
 	ipu_reset();
 
+	clk_set_parent(g_pixel_clk[0], g_ipu_clk);
+	clk_set_parent(g_pixel_clk[1], g_ipu_clk);
 	clk_enable(g_ipu_clk);
 
 	g_di_clk[0] = plat_data->di_clk[0];
@@ -260,7 +378,7 @@
 	__raw_writel(0xFFFFFFFF, IPU_INT_CTRL(10));
 
 	/* DMFC Init */
-	_ipu_dmfc_init();
+	_ipu_dmfc_init(DMFC_NORMAL, 1);
 
 	/* Set sync refresh channels as high priority */
 	__raw_writel(0x18800000L, IDMAC_CHA_PRI(0));
@@ -268,12 +386,6 @@
 	/* Set MCU_T to divide MCU access window into 2 */
 	__raw_writel(0x00400000L | (IPU_MCU_T_DEFAULT << 18), IPU_DISP_GEN);
 
-	/* Enable for a divide by 2 clock change. */
-	reg = __raw_readl(IPU_PM);
-	reg &= ~(0x7f << 7);
-	reg |= 0x20 << 7;
-	__raw_writel(reg, IPU_PM);
-
 	clk_disable(g_ipu_clk);
 
 	register_ipu_device();
@@ -376,6 +488,7 @@
 	__raw_writel(0xFFFFFFFF, IPU_INT_CTRL(10));
 
 	if (g_ipu_clk_enabled == false) {
+		stop_dvfs_per();
 		g_ipu_clk_enabled = true;
 		clk_enable(g_ipu_clk);
 	}
@@ -639,11 +752,9 @@
 		ipu_conf |= IPU_CONF_DMFC_EN;
 	if (ipu_di_use_count[0] == 1) {
 		ipu_conf |= IPU_CONF_DI0_EN;
-		clk_enable(g_di_clk[0]);
 	}
 	if (ipu_di_use_count[1] == 1) {
 		ipu_conf |= IPU_CONF_DI1_EN;
-		clk_enable(g_di_clk[1]);
 	}
 	if (ipu_smfc_use_count == 1)
 		ipu_conf |= IPU_CONF_SMFC_EN;
@@ -837,11 +948,9 @@
 		ipu_conf &= ~IPU_CONF_DMFC_EN;
 	if (ipu_di_use_count[0] == 0) {
 		ipu_conf &= ~IPU_CONF_DI0_EN;
-		clk_disable(g_di_clk[0]);
 	}
 	if (ipu_di_use_count[1] == 0) {
 		ipu_conf &= ~IPU_CONF_DI1_EN;
-		clk_disable(g_di_clk[1]);
 	}
 	if (ipu_smfc_use_count == 0)
 		ipu_conf &= ~IPU_CONF_SMFC_EN;
@@ -2297,7 +2406,7 @@
 		__raw_writel(idma_enable_reg[1], IDMAC_CHA_EN(32));
 	} else {
 		clk_enable(g_ipu_clk);
-		_ipu_dmfc_init();
+		_ipu_dmfc_init(DMFC_NORMAL, 0);
 		_ipu_init_dc_mappings();
 
 		/* Set sync refresh channels as high priority */
diff -urNBb -x linux-2.6.31.9-ER1-efikamx/Documentation/dontdiff linux-2.6.31.9-ER1-efikamx.orig/drivers/mxc/ipu3/ipu_device.c linux-2.6.31.9-ER1-efikamx/drivers/mxc/ipu3/ipu_device.c
--- linux-2.6.31.9-ER1-efikamx.orig/drivers/mxc/ipu3/ipu_device.c	2009-12-12 13:16:52.000000000 -0600
+++ linux-2.6.31.9-ER1-efikamx/drivers/mxc/ipu3/ipu_device.c	2010-01-07 22:20:55.467433487 -0600
@@ -374,6 +374,46 @@
 				ret = 0;
 		}
 		break;
+	case IPU_CALC_STRIPES_SIZE:
+		{
+			ipu_stripe_parm stripe_parm;
+
+			if (copy_from_user (&stripe_parm, (ipu_stripe_parm *)arg,
+					 sizeof(ipu_stripe_parm)))
+				return -EFAULT;
+			ipu_calc_stripes_sizes(stripe_parm.input_width,
+						stripe_parm.output_width,
+						stripe_parm.maximal_stripe_width,
+						stripe_parm.cirr,
+						stripe_parm.equal_stripes,
+						stripe_parm.input_pixelformat,
+						stripe_parm.output_pixelformat,
+						&stripe_parm.left,
+						&stripe_parm.right);
+			if (copy_to_user((ipu_stripe_parm *) arg, &stripe_parm,
+					sizeof(ipu_stripe_parm)) > 0)
+				return -EFAULT;
+		}
+		break;
+	case IPU_UPDATE_BUF_OFFSET:
+		{
+			ipu_buf_offset_parm offset_parm;
+
+			if (copy_from_user (&offset_parm, (ipu_buf_offset_parm *)arg,
+					 sizeof(ipu_buf_offset_parm)))
+				return -EFAULT;
+			ret = ipu_update_channel_offset(offset_parm.channel,
+							offset_parm.type,
+							offset_parm.pixel_fmt,
+							offset_parm.width,
+							offset_parm.height,
+							offset_parm.stride,
+							offset_parm.u_offset,
+							offset_parm.v_offset,
+							offset_parm.vertical_offset,
+							offset_parm.horizontal_offset);
+		}
+		break;
 	default:
 		break;
 	}
diff -urNBb -x linux-2.6.31.9-ER1-efikamx/Documentation/dontdiff linux-2.6.31.9-ER1-efikamx.orig/drivers/mxc/ipu3/ipu_disp.c linux-2.6.31.9-ER1-efikamx/drivers/mxc/ipu3/ipu_disp.c
--- linux-2.6.31.9-ER1-efikamx.orig/drivers/mxc/ipu3/ipu_disp.c	2009-12-12 13:16:57.000000000 -0600
+++ linux-2.6.31.9-ER1-efikamx/drivers/mxc/ipu3/ipu_disp.c	2010-01-15 13:45:50.000000000 -0600
@@ -24,8 +24,10 @@
 #include <linux/spinlock.h>
 #include <linux/io.h>
 #include <linux/ipu.h>
+#include <linux/clk.h>
 #include <asm/atomic.h>
 #include <mach/mxc_dvfs.h>
+#include <mach/clock.h>
 #include "ipu_prv.h"
 #include "ipu_regs.h"
 #include "ipu_param_mem.h"
@@ -52,54 +54,135 @@
 #define DC_DISP_ID_SERIAL	2
 #define DC_DISP_ID_ASYNC	3
 
+int dmfc_type_setup;
+static int dmfc_size_28, dmfc_size_29, dmfc_size_24, dmfc_size_27, dmfc_size_23;
+int g_di1_tvout;
 
-/* all value below is determined by fix reg setting in _ipu_dmfc_init*/
-#define DMFC_FIFO_SIZE_28	(128*4)
-#define DMFC_FIFO_SIZE_29	(64*4)
-#define DMFC_FIFO_SIZE_24	(64*4)
-#define DMFC_FIFO_SIZE_27	(128*4)
-#define DMFC_FIFO_SIZE_23	(128*4)
-
-void _ipu_dmfc_init(void)
+void _ipu_dmfc_init(int dmfc_type, int first)
 {
+	u32 dmfc_wr_chan, dmfc_dp_chan;
+
+	if (first) {
+		if (dmfc_type_setup > dmfc_type)
+			dmfc_type = dmfc_type_setup;
+		else
+			dmfc_type_setup = dmfc_type;
+
 	/* disable DMFC-IC channel*/
 	__raw_writel(0x2, DMFC_IC_CTRL);
-	/* 1 - segment 0 and 1; 2, 1C and 2C unused */
-	__raw_writel(0x00000088, DMFC_WR_CHAN);
+	} else if (dmfc_type_setup >= DMFC_HIGH_RESOLUTION_DC) {
+		printk(KERN_DEBUG "DMFC high resolution has set, will not change\n");
+		return;
+	} else
+		dmfc_type_setup = dmfc_type;
+
+	if (dmfc_type == DMFC_HIGH_RESOLUTION_DC) {
+		/* 1 - segment 0~3;
+		 * 5B - segement 4, 5;
+		 * 5F - segement 6, 7;
+		 * 1C, 2C and 6B, 6F unused;
+		 */
+		printk(KERN_INFO "IPU DMFC DC HIGH RESOLUTION: 1(0~3), 5B(4,5), 5F(6,7)\n");
+		dmfc_wr_chan = 0x00000088;
+		dmfc_dp_chan = 0x00009694;
+		dmfc_size_28 = 256*4;
+		dmfc_size_29 = 0;
+		dmfc_size_24 = 0;
+		dmfc_size_27 = 128*4;
+		dmfc_size_23 = 128*4;
+	} else if (dmfc_type == DMFC_HIGH_RESOLUTION_DP) {
+		/* 1 - segment 0, 1;
+		 * 5B - segement 2~5;
+		 * 5F - segement 6,7;
+		 * 1C, 2C and 6B, 6F unused;
+		 */
+		printk(KERN_INFO "IPU DMFC DP HIGH RESOLUTION: 1(0,1), 5B(2~5), 5F(6,7)\n");
+		dmfc_wr_chan = 0x00000090;
+		dmfc_dp_chan = 0x0000968a;
+		dmfc_size_28 = 128*4;
+		dmfc_size_29 = 0;
+		dmfc_size_24 = 0;
+		dmfc_size_27 = 128*4;
+		dmfc_size_23 = 256*4;
+	} else if (dmfc_type == DMFC_HIGH_RESOLUTION_ONLY_DP) {
+		/* 5B - segement 0~3;
+		 * 5F - segement 4~7;
+		 * 1, 1C, 2C and 6B, 6F unused;
+		 */
+		printk(KERN_INFO "IPU DMFC ONLY-DP HIGH RESOLUTION: 5B(0~3), 5F(4~7)\n");
+		dmfc_wr_chan = 0x00000000;
+		dmfc_dp_chan = 0x00008c88;
+		dmfc_size_28 = 0;
+		dmfc_size_29 = 0;
+		dmfc_size_24 = 0;
+		dmfc_size_27 = 256*4;
+		dmfc_size_23 = 256*4;
+	} else {
+		/* 1 - segment 0, 1;
+		 * 5B - segement 4, 5;
+		 * 5F - segement 6, 7;
+		 * 1C, 2C and 6B, 6F unused;
+		 */
+		printk(KERN_INFO "IPU DMFC NORMAL mode: 1(0~1), 5B(4,5), 5F(6,7)\n");
+		dmfc_wr_chan = 0x00000090;
+		dmfc_dp_chan = 0x00009694;
+		dmfc_size_28 = 128*4;
+		dmfc_size_29 = 0;
+		dmfc_size_24 = 0;
+		dmfc_size_27 = 128*4;
+		dmfc_size_23 = 128*4;
+	}
+	__raw_writel(dmfc_wr_chan, DMFC_WR_CHAN);
 	__raw_writel(0x202020F6, DMFC_WR_CHAN_DEF);
-	/* 5B - segment 2 and 3; 5F - segment 4 and 5; */
-	/* 6B - segment 6; 6F - segment 7 */
-	__raw_writel(0x1F1E9694, DMFC_DP_CHAN);
+	__raw_writel(dmfc_dp_chan, DMFC_DP_CHAN);
 	/* Enable chan 5 watermark set at 5 bursts and clear at 7 bursts */
 	__raw_writel(0x2020F6F6, DMFC_DP_CHAN_DEF);
 }
 
+static int __init dmfc_setup(char *options)
+{
+	get_option(&options, &dmfc_type_setup);
+	if (dmfc_type_setup > DMFC_HIGH_RESOLUTION_ONLY_DP)
+		dmfc_type_setup = DMFC_HIGH_RESOLUTION_ONLY_DP;
+	return 1;
+}
+__setup("dmfc=", dmfc_setup);
+
 void _ipu_dmfc_set_wait4eot(int dma_chan, int width)
 {
 	u32 dmfc_gen1 = __raw_readl(DMFC_GENERAL1);
 
+#if !defined(CONFIG_MACH_MX51_EFIKAMX)
+	if (width >= HIGH_RESOLUTION_WIDTH) {
+		if (dma_chan == 23)
+			_ipu_dmfc_init(DMFC_HIGH_RESOLUTION_DP, 0);
+		else if (dma_chan == 28)
+			_ipu_dmfc_init(DMFC_HIGH_RESOLUTION_DC, 0);
+	}
+#endif
+
 	if (dma_chan == 23) { /*5B*/
-		if (DMFC_FIFO_SIZE_23/width > 3)
+		if (dmfc_size_23/width > 3)
 			dmfc_gen1 |= 1UL << 20;
 		else
 			dmfc_gen1 &= ~(1UL << 20);
 	} else if (dma_chan == 24) { /*6B*/
-		if (DMFC_FIFO_SIZE_24/width > 1)
+		if (dmfc_size_24/width > 1)
 			dmfc_gen1 |= 1UL << 22;
 		else
 			dmfc_gen1 &= ~(1UL << 22);
 	} else if (dma_chan == 27) { /*5F*/
-		if (DMFC_FIFO_SIZE_27/width > 2)
+		if (dmfc_size_27/width > 2)
 			dmfc_gen1 |= 1UL << 21;
 		else
 			dmfc_gen1 &= ~(1UL << 21);
 	} else if (dma_chan == 28) { /*1*/
-		if (DMFC_FIFO_SIZE_28/width > 2)
+		if (dmfc_size_28/width > 2)
 			dmfc_gen1 |= 1UL << 16;
 		else
 			dmfc_gen1 &= ~(1UL << 16);
 	} else if (dma_chan == 29) { /*6F*/
-		if (DMFC_FIFO_SIZE_29/width > 1)
+		if (dmfc_size_29/width > 1)
 			dmfc_gen1 |= 1UL << 23;
 		else
 			dmfc_gen1 &= ~(1UL << 23);
@@ -549,12 +632,7 @@
 	reg |= 4 << DC_WR_CH_CONF_PROG_TYPE_OFFSET;
 	__raw_writel(reg, DC_WR_CH_CONF(dc_chan));
 
-	reg = __raw_readl(IPU_DISP_GEN);
-	if (di)
-		reg |= DI1_COUNTER_RELEASE;
-	else
-		reg |= DI0_COUNTER_RELEASE;
-	__raw_writel(reg, IPU_DISP_GEN);
+	clk_enable(g_pixel_clk[di]);
 }
 
 static bool dc_swap;
@@ -701,6 +779,9 @@
 		__raw_writel(reg, IPU_DISP_GEN);
 
 		spin_unlock_irqrestore(&ipu_lock, lock_flags);
+		/* Clock is already off because it must be done quickly, but
+		   we need to fix the ref count */
+		clk_disable(g_pixel_clk[g_dc_di_assignment[dc_chan]]);
 
 		if (__raw_readl(IPUIRQ_2_STATREG(IPU_IRQ_VSYNC_PRE_0
 			+ g_dc_di_assignment[dc_chan])) &
@@ -795,6 +876,28 @@
 }
 
 /*!
+ * This function is called to adapt synchronous LCD panel to IPU restriction.
+ *
+ */
+void adapt_panel_to_ipu_restricitions(uint16_t *pixel_clk,
+				      uint16_t width, uint16_t height,
+				      uint16_t h_start_width,
+				      uint16_t h_end_width,
+				      uint16_t v_start_width,
+				      uint16_t *v_end_width)
+{
+	if (*v_end_width < 2) {
+		uint16_t total_width = width + h_start_width + h_end_width;
+		uint16_t total_height_old = height + v_start_width + (*v_end_width);
+		uint16_t total_height_new = height + v_start_width + 2;
+		*v_end_width = 2;
+		*pixel_clk = (*pixel_clk) * total_width * total_height_new /
+			(total_width * total_height_old);
+		dev_err(g_ipu_dev, "WARNING: adapt panel end blank lines\n");
+	}
+}
+
+/*!
  * This function is called to initialize a synchronous LCD panel.
  *
  * @param       disp            The DI the panel is attached to.
@@ -843,74 +946,77 @@
 	uint32_t field0_offset = 0;
 	uint32_t field1_offset;
 	uint32_t reg;
-	uint32_t disp_gen, di_gen, vsync_cnt;
-	uint32_t div;
+	uint32_t di_gen, vsync_cnt;
+	uint32_t div, rounded_pixel_clk;
 	uint32_t h_total, v_total;
 	int map;
-	struct clk *di_clk;
-	int ipu_freq_scaling_enabled;
+	int ipu_freq_scaling_enabled = 0;
+	struct clk *di_parent;
 
 	dev_dbg(g_ipu_dev, "panel size = %d x %d\n", width, height);
 
 	if ((v_sync_width == 0) || (h_sync_width == 0))
 		return EINVAL;
 
+	adapt_panel_to_ipu_restricitions(&pixel_clk, width, height,
+					 h_start_width, h_end_width,
+					 v_start_width, &v_end_width);
 	h_total = width + h_sync_width + h_start_width + h_end_width;
 	v_total = height + v_sync_width + v_start_width + v_end_width;
 
 	/* Init clocking */
 	dev_dbg(g_ipu_dev, "pixel clk = %d\n", pixel_clk);
 
-	if (sig.ext_clk)
-		di_clk = g_di_clk[disp];
-	else
-		di_clk = g_ipu_clk;
-
-	ipu_freq_scaling_enabled = dvfs_per_pixel_clk_limit(pixel_clk);
-
-	stop_dvfs_per();
-
-	/*
-	 * Calculate divider
-	 * Fractional part is 4 bits,
-	 * so simply multiply by 2^4 to get fractional part.
+	if (sig.ext_clk) {
+#if !defined(CONFIG_MACH_MX51_EFIKAMX)
+		/* not on EfikaMX workaround for monitor become blank when width > 1024 (such as 1280x720)
+		  * possible due to g_di_clk[disp] > ipu clk 133MHz
 	 */
-	div = (clk_get_rate(di_clk) * 16) / pixel_clk;
-	if (div < 0x10)            /* Min DI disp clock divider is 1 */
-		div = 0x10;
-	/* Need an even integer divder for DVFS-PER to work */
-	if (ipu_freq_scaling_enabled) {
-		if (div & 0x10)
-			div += 0x10;
-		/* Fractional part is rounded off to 0. */
-		div &= 0xFF0;
-	} else
-		/* Only MSB fractional bit is supported. */
-		div &= 0xFF8;
+		if (!(g_di1_tvout && (disp == 1))) { /* not round div for tvout*/
+			/* Set the  PLL to be an even multiple of the pixel clock. */
+			if ((clk_get_usecount(g_pixel_clk[0]) == 0) &&
+					(clk_get_usecount(g_pixel_clk[1]) == 0)) {
+				di_parent = clk_get_parent(g_di_clk[disp]);
+				rounded_pixel_clk =
+					clk_round_rate(g_pixel_clk[disp], pixel_clk);
+				div  = clk_get_rate(di_parent) / rounded_pixel_clk;
+				if (div % 2)
+					div++;
+
+				if (clk_get_rate(di_parent) != div * rounded_pixel_clk)
+					clk_set_rate(di_parent, div * rounded_pixel_clk);
+				msleep(10);
+				clk_set_rate(g_di_clk[disp], 2 * rounded_pixel_clk);
+				msleep(10);
+			}
+		}
+#endif
+		clk_set_parent(g_pixel_clk[disp], g_di_clk[disp]);
+	} else {
+		if (clk_get_usecount(g_pixel_clk[disp]) != 0)
+			clk_set_parent(g_pixel_clk[disp], g_ipu_clk);
+	}
+	rounded_pixel_clk = clk_round_rate(g_pixel_clk[disp], pixel_clk);
+	clk_set_rate(g_pixel_clk[disp], rounded_pixel_clk);
+	msleep(5);
+	/* Get integer portion of divider */
+	div = clk_get_rate(clk_get_parent(g_pixel_clk[disp])) / rounded_pixel_clk;
 
-	reg = __raw_readl(DI_GENERAL(disp));
-	if (sig.ext_clk)
-		__raw_writel(reg | DI_GEN_DI_CLK_EXT, DI_GENERAL(disp));
-	else
-		__raw_writel(reg & ~DI_GEN_DI_CLK_EXT, DI_GENERAL(disp));
+	ipu_freq_scaling_enabled = dvfs_per_pixel_clk_limit();
 
+	if (ipu_freq_scaling_enabled) {
+		/* Enable for a divide by 2 clock change. */
+		reg = __raw_readl(IPU_PM);
+		reg &= ~(0x7f << 7);
+		reg |= 0x20 << 7;
+		reg &= ~(0x7f << 23);
+		reg |= 0x20 << 23;
+		__raw_writel(reg, IPU_PM);
+	}
 	spin_lock_irqsave(&ipu_lock, lock_flags);
 
-	disp_gen = __raw_readl(IPU_DISP_GEN);
-	disp_gen &= disp ? ~DI1_COUNTER_RELEASE : ~DI0_COUNTER_RELEASE;
-	__raw_writel(disp_gen, IPU_DISP_GEN);
-
-	__raw_writel(div, DI_BS_CLKGEN0(disp));
-
-	/* Setup pixel clock timing */
-	/* FIXME: needs to be more flexible */
-	/* Down time is half of period */
-	__raw_writel((div / 16) << 16, DI_BS_CLKGEN1(disp));
-
-	_ipu_di_data_wave_config(disp, SYNC_WAVE, div / 16 - 1, div / 16 - 1);
-	_ipu_di_data_pin_config(disp, SYNC_WAVE, DI_PIN15, 3, 0, div / 16 * 2);
-
-	div = div / 16;		/* Now divider is integer portion */
+	_ipu_di_data_wave_config(disp, SYNC_WAVE, div - 1, div - 1);
+	_ipu_di_data_pin_config(disp, SYNC_WAVE, DI_PIN15, 3, 0, div * 2);
 
 	map = _ipu_pixfmt_to_map(pixel_fmt);
 	if (map < 0) {
@@ -919,9 +1025,7 @@
 		return -EINVAL;
 	}
 
-	di_gen = 0;
-	if (sig.ext_clk)
-		di_gen |= DI_GEN_DI_CLK_EXT;
+	di_gen = __raw_readl(DI_GENERAL(disp));
 
 	if (sig.interlaced) {
 		if (cpu_is_mx51_rev(CHIP_REV_2_0)) {
@@ -1272,8 +1376,6 @@
 
 	spin_unlock_irqrestore(&ipu_lock, lock_flags);
 
-	start_dvfs_per();
-
 	return 0;
 }
 EXPORT_SYMBOL(ipu_init_sync_panel);
@@ -1517,8 +1619,8 @@
 		__raw_writel((slopek[4*i] & 0xff) | ((slopek[4*i+1] & 0xff) << 8) |
 			((slopek[4*i+2] & 0xff) << 16) | ((slopek[4*i+3] & 0xff) << 24), DP_GAMMA_S(flow, i));
 
-	if (enable) {
 		reg = __raw_readl(DP_COM_CONF(flow));
+	if (enable) {
 		if ((bg_csc_type == RGB2YUV) || (bg_csc_type == YUV2YUV))
 			reg |= DP_COM_CONF_GAMMA_YUV_EN;
 		else
diff -urNBb -x linux-2.6.31.9-ER1-efikamx/Documentation/dontdiff linux-2.6.31.9-ER1-efikamx.orig/drivers/mxc/ipu3/ipu_ic.c linux-2.6.31.9-ER1-efikamx/drivers/mxc/ipu3/ipu_ic.c
--- linux-2.6.31.9-ER1-efikamx.orig/drivers/mxc/ipu3/ipu_ic.c	2009-12-12 13:16:54.000000000 -0600
+++ linux-2.6.31.9-ER1-efikamx/drivers/mxc/ipu3/ipu_ic.c	2010-01-07 22:20:55.469239247 -0600
@@ -226,10 +226,14 @@
 	reg = (downsizeCoeff << 30) | (resizeCoeff << 16);
 
 	/* Setup horizontal resizing */
+	/* Upadeted for IC split case */
+	if (!(params->mem_prp_vf_mem.out_resize_ratio)) {
 	_calc_resize_coeffs(params->mem_prp_vf_mem.in_width,
 			    params->mem_prp_vf_mem.out_width,
 			    &resizeCoeff, &downsizeCoeff);
 	reg |= (downsizeCoeff << 14) | resizeCoeff;
+	} else
+		reg |= params->mem_prp_vf_mem.out_resize_ratio;
 
 	__raw_writel(reg, IC_PRP_VF_RSC);
 
@@ -344,10 +348,14 @@
 	reg = (downsizeCoeff << 30) | (resizeCoeff << 16);
 
 	/* Setup horizontal resizing */
+	/* Upadeted for IC split case */
+	if (!(params->mem_prp_enc_mem.out_resize_ratio)) {
 	_calc_resize_coeffs(params->mem_prp_enc_mem.in_width,
 			    params->mem_prp_enc_mem.out_width,
 			    &resizeCoeff, &downsizeCoeff);
 	reg |= (downsizeCoeff << 14) | resizeCoeff;
+	} else
+		reg |= params->mem_prp_enc_mem.out_resize_ratio;
 
 	__raw_writel(reg, IC_PRP_ENC_RSC);
 
@@ -422,8 +430,9 @@
 							params->mem_pp_mem.out_width,
 							&resizeCoeff, &downsizeCoeff);
 		reg |= (downsizeCoeff << 14) | resizeCoeff;
-	} else
+	} else {
 		reg |= params->mem_pp_mem.out_resize_ratio;
+	}
 
 	__raw_writel(reg, IC_PP_RSC);
 
diff -urNBb -x linux-2.6.31.9-ER1-efikamx/Documentation/dontdiff linux-2.6.31.9-ER1-efikamx.orig/drivers/mxc/ipu3/ipu_prv.h linux-2.6.31.9-ER1-efikamx/drivers/mxc/ipu3/ipu_prv.h
--- linux-2.6.31.9-ER1-efikamx.orig/drivers/mxc/ipu3/ipu_prv.h	2009-12-12 13:16:52.000000000 -0600
+++ linux-2.6.31.9-ER1-efikamx/drivers/mxc/ipu3/ipu_prv.h	2010-01-07 22:20:55.425512223 -0600
@@ -25,11 +25,13 @@
 extern bool g_ipu_clk_enabled;
 extern struct clk *g_ipu_clk;
 extern struct clk *g_di_clk[2];
+extern struct clk *g_pixel_clk[2];
 extern struct clk *g_csi_clk[2];
 extern unsigned char g_dc_di_assignment[];
 extern int g_ipu_hw_rev;
 
 #define IDMA_CHAN_INVALID	0xFF
+#define HIGH_RESOLUTION_WIDTH	1024
 
 struct ipu_channel {
 	u8 video_in_dma;
@@ -38,6 +40,13 @@
 	u8 out_dma;
 };
 
+enum ipu_dmfc_type {
+	DMFC_NORMAL = 0,
+	DMFC_HIGH_RESOLUTION_DC,
+	DMFC_HIGH_RESOLUTION_DP,
+	DMFC_HIGH_RESOLUTION_ONLY_DP,
+};
+
 int register_ipu_device(void);
 ipu_color_space_t format_to_colorspace(uint32_t fmt);
 bool ipu_pixel_format_has_alpha(uint32_t fmt);
@@ -54,7 +63,7 @@
 void _ipu_dc_uninit(int dc_chan);
 void _ipu_dp_dc_enable(ipu_channel_t channel);
 void _ipu_dp_dc_disable(ipu_channel_t channel, bool swap);
-void _ipu_dmfc_init(void);
+void _ipu_dmfc_init(int dmfc_type, int first);
 void _ipu_dmfc_set_wait4eot(int dma_chan, int width);
 int _ipu_chan_is_interlaced(ipu_channel_t channel);
 
diff -urNBb -x linux-2.6.31.9-ER1-efikamx/Documentation/dontdiff linux-2.6.31.9-ER1-efikamx.orig/drivers/power/stmp37xx/linux.c linux-2.6.31.9-ER1-efikamx/drivers/power/stmp37xx/linux.c
--- linux-2.6.31.9-ER1-efikamx.orig/drivers/power/stmp37xx/linux.c	2009-12-12 13:16:58.000000000 -0600
+++ linux-2.6.31.9-ER1-efikamx/drivers/power/stmp37xx/linux.c	2010-01-07 22:20:54.688723014 -0600
@@ -959,9 +959,7 @@
 
 	mutex_lock(&info->sm_lock);
 
-	/* disable 5v irq */
-	__raw_writel(BM_POWER_CTRL_ENIRQ_VDD5V_GT_VDDIO,
-		REGS_POWER_BASE + HW_POWER_CTRL_CLR);
+	/* enable USB 5v wake up so don't disable irq here*/
 
 	ddi_bc_SetDisable();
 	/* cancel state machine timer */
diff -urNBb -x linux-2.6.31.9-ER1-efikamx/Documentation/dontdiff linux-2.6.31.9-ER1-efikamx.orig/drivers/rtc/rtc-stmp3xxx.c linux-2.6.31.9-ER1-efikamx/drivers/rtc/rtc-stmp3xxx.c
--- linux-2.6.31.9-ER1-efikamx.orig/drivers/rtc/rtc-stmp3xxx.c	2009-12-12 13:16:57.000000000 -0600
+++ linux-2.6.31.9-ER1-efikamx/drivers/rtc/rtc-stmp3xxx.c	2010-01-07 22:20:55.293032163 -0600
@@ -223,6 +223,8 @@
 			BM_RTC_PERSISTENT0_ALARM_WAKE_EN |
 			BM_RTC_PERSISTENT0_ALARM_WAKE,
 		     REGS_RTC_BASE + HW_RTC_PERSISTENT0_CLR);
+	__raw_writel(BM_RTC_PERSISTENT0_AUTO_RESTART,
+		     REGS_RTC_BASE + HW_RTC_PERSISTENT0_SET);
 
 	printk(KERN_INFO "STMP3xxx RTC driver v1.0 hardware v%u.%u.%u\n",
 	       (hwversion >> 24),
diff -urNBb -x linux-2.6.31.9-ER1-efikamx/Documentation/dontdiff linux-2.6.31.9-ER1-efikamx.orig/drivers/staging/Kconfig linux-2.6.31.9-ER1-efikamx/drivers/staging/Kconfig
--- linux-2.6.31.9-ER1-efikamx.orig/drivers/staging/Kconfig	2009-09-09 17:13:59.000000000 -0500
+++ linux-2.6.31.9-ER1-efikamx/drivers/staging/Kconfig	2010-01-09 14:43:55.827345010 -0600
@@ -127,5 +127,7 @@
 
 source "drivers/staging/udlfb/Kconfig"
 
+source "drivers/staging/ramzswap/Kconfig"
+
 endif # !STAGING_EXCLUDE_BUILD
 endif # STAGING
diff -urNBb -x linux-2.6.31.9-ER1-efikamx/Documentation/dontdiff linux-2.6.31.9-ER1-efikamx.orig/drivers/staging/ramzswap/Kconfig linux-2.6.31.9-ER1-efikamx/drivers/staging/ramzswap/Kconfig
--- linux-2.6.31.9-ER1-efikamx.orig/drivers/staging/ramzswap/Kconfig	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.31.9-ER1-efikamx/drivers/staging/ramzswap/Kconfig	2010-01-09 14:42:53.493300697 -0600
@@ -0,0 +1,21 @@
+config RAMZSWAP
+	tristate "Compressed in-memory swap device (ramzswap)"
+	depends on SWAP
+	select LZO_COMPRESS
+	select LZO_DECOMPRESS
+	default n
+	help
+	  Creates virtual block devices which can be used (only) as a swap
+	  disks. Pages swapped to these disks are compressed and stored in
+	  memory itself.
+
+	  See ramzswap.txt for more information.
+	  Project home: http://compcache.googlecode.com/
+
+config RAMZSWAP_STATS
+	bool "Enable ramzswap stats"
+	depends on RAMZSWAP
+	default y
+	help
+	  Enable statistics collection for ramzswap. This adds only a minimal
+	  overhead. In unsure, say Y.
diff -urNBb -x linux-2.6.31.9-ER1-efikamx/Documentation/dontdiff linux-2.6.31.9-ER1-efikamx.orig/drivers/staging/ramzswap/Makefile linux-2.6.31.9-ER1-efikamx/drivers/staging/ramzswap/Makefile
--- linux-2.6.31.9-ER1-efikamx.orig/drivers/staging/ramzswap/Makefile	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.31.9-ER1-efikamx/drivers/staging/ramzswap/Makefile	2010-01-09 14:42:53.493300697 -0600
@@ -0,0 +1,3 @@
+ramzswap-objs	:=	ramzswap_drv.o xvmalloc.o
+
+obj-$(CONFIG_RAMZSWAP)	+=	ramzswap.o
diff -urNBb -x linux-2.6.31.9-ER1-efikamx/Documentation/dontdiff linux-2.6.31.9-ER1-efikamx.orig/drivers/staging/ramzswap/ramzswap_drv.c linux-2.6.31.9-ER1-efikamx/drivers/staging/ramzswap/ramzswap_drv.c
--- linux-2.6.31.9-ER1-efikamx.orig/drivers/staging/ramzswap/ramzswap_drv.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.31.9-ER1-efikamx/drivers/staging/ramzswap/ramzswap_drv.c	2010-01-09 14:42:53.494301580 -0600
@@ -0,0 +1,1413 @@
+/*
+ * Compressed RAM based swap device
+ *
+ * Copyright (C) 2008, 2009  Nitin Gupta
+ *
+ * This code is released using a dual license strategy: BSD/GPL
+ * You can choose the licence that better fits your requirements.
+ *
+ * Released under the terms of 3-clause BSD License
+ * Released under the terms of GNU General Public License Version 2.0
+ *
+ * Project home: http://compcache.googlecode.com
+ */
+
+#define KMSG_COMPONENT "ramzswap"
+#define pr_fmt(fmt) KMSG_COMPONENT ": " fmt
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/bitops.h>
+#include <linux/blkdev.h>
+#include <linux/buffer_head.h>
+#include <linux/device.h>
+#include <linux/genhd.h>
+#include <linux/highmem.h>
+#include <linux/lzo.h>
+#include <linux/mutex.h>
+#include <linux/string.h>
+#include <linux/swap.h>
+#include <linux/swapops.h>
+#include <linux/vmalloc.h>
+#include <linux/version.h>
+
+#include "ramzswap_drv.h"
+
+/* Globals */
+static int ramzswap_major;
+static struct ramzswap *devices;
+
+/*
+ * Pages that compress to larger than this size are
+ * forwarded to backing swap, if present or stored
+ * uncompressed in memory otherwise.
+ */
+static unsigned int max_zpage_size;
+
+/* Module params (documentation at end) */
+static unsigned int num_devices;
+
+static int rzs_test_flag(struct ramzswap *rzs, u32 index,
+			enum rzs_pageflags flag)
+{
+	return rzs->table[index].flags & BIT(flag);
+}
+
+static void rzs_set_flag(struct ramzswap *rzs, u32 index,
+			enum rzs_pageflags flag)
+{
+	rzs->table[index].flags |= BIT(flag);
+}
+
+static void rzs_clear_flag(struct ramzswap *rzs, u32 index,
+			enum rzs_pageflags flag)
+{
+	rzs->table[index].flags &= ~BIT(flag);
+}
+
+static int page_zero_filled(void *ptr)
+{
+	unsigned int pos;
+	unsigned long *page;
+
+	page = (unsigned long *)ptr;
+
+	for (pos = 0; pos != PAGE_SIZE / sizeof(*page); pos++) {
+		if (page[pos])
+			return 0;
+	}
+
+	return 1;
+}
+
+/*
+ * memlimit cannot be greater than backing disk size.
+ */
+static void ramzswap_set_memlimit(struct ramzswap *rzs, size_t totalram_bytes)
+{
+	int memlimit_valid = 1;
+
+	if (!rzs->memlimit) {
+		pr_info("Memory limit not set.\n");
+		memlimit_valid = 0;
+	}
+
+	if (rzs->memlimit > rzs->disksize) {
+		pr_info("Memory limit cannot be greater than "
+			"disksize: limit=%zu, disksize=%zu\n",
+			rzs->memlimit, rzs->disksize);
+		memlimit_valid = 0;
+	}
+
+	if (!memlimit_valid) {
+		size_t mempart, disksize;
+		pr_info("Using default: smaller of (%u%% of RAM) and "
+			"(backing disk size).\n",
+			default_memlimit_perc_ram);
+		mempart = default_memlimit_perc_ram * (totalram_bytes / 100);
+		disksize = rzs->disksize;
+		rzs->memlimit = mempart > disksize ? disksize : mempart;
+	}
+
+	if (rzs->memlimit > totalram_bytes / 2) {
+		pr_info(
+		"Its not advisable setting limit more than half of "
+		"size of memory since we expect a 2:1 compression ratio. "
+		"Limit represents amount of *compressed* data we can keep "
+		"in memory!\n"
+		"\tMemory Size: %zu kB\n"
+		"\tLimit you selected: %zu kB\n"
+		"Continuing anyway ...\n",
+		totalram_bytes >> 10, rzs->memlimit >> 10
+		);
+	}
+
+	rzs->memlimit &= PAGE_MASK;
+	BUG_ON(!rzs->memlimit);
+}
+
+static void ramzswap_set_disksize(struct ramzswap *rzs, size_t totalram_bytes)
+{
+	if (!rzs->disksize) {
+		pr_info(
+		"disk size not provided. You can use disksize_kb module "
+		"param to specify size.\nUsing default: (%u%% of RAM).\n",
+		default_disksize_perc_ram
+		);
+		rzs->disksize = default_disksize_perc_ram *
+					(totalram_bytes / 100);
+	}
+
+	if (rzs->disksize > 2 * (totalram_bytes)) {
+		pr_info(
+		"There is little point creating a ramzswap of greater than "
+		"twice the size of memory since we expect a 2:1 compression "
+		"ratio. Note that ramzswap uses about 0.1%% of the size of "
+		"the swap device when not in use so a huge ramzswap is "
+		"wasteful.\n"
+		"\tMemory Size: %zu kB\n"
+		"\tSize you selected: %zu kB\n"
+		"Continuing anyway ...\n",
+		totalram_bytes >> 10, rzs->disksize
+		);
+	}
+
+	rzs->disksize &= PAGE_MASK;
+}
+
+/*
+ * Swap header (1st page of swap device) contains information
+ * to indentify it as a swap partition. Prepare such a header
+ * for ramzswap device (ramzswap0) so that swapon can identify
+ * it as swap partition. In case backing swap device is provided,
+ * copy its swap header.
+ */
+static int setup_swap_header(struct ramzswap *rzs, union swap_header *s)
+{
+	int ret = 0;
+	struct page *page;
+	struct address_space *mapping;
+	union swap_header *backing_swap_header;
+
+	/*
+	 * There is no backing swap device. Create a swap header
+	 * that is acceptable by swapon.
+	 */
+	if (!rzs->backing_swap) {
+		s->info.version = 1;
+		s->info.last_page = (rzs->disksize >> PAGE_SHIFT) - 1;
+		s->info.nr_badpages = 0;
+		memcpy(s->magic.magic, "SWAPSPACE2", 10);
+		return 0;
+	}
+
+	/*
+	 * We have a backing swap device. Copy its swap header
+	 * to ramzswap device header. If this header contains
+	 * invalid information (backing device not a swap
+	 * partition, etc.), swapon will fail for ramzswap
+	 * which is correct behavior - we don't want to swap
+	 * over filesystem partition!
+	 */
+
+	/* Read the backing swap header (code from sys_swapon) */
+	mapping = rzs->swap_file->f_mapping;
+	if (!mapping->a_ops->readpage) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	page = read_mapping_page(mapping, 0, rzs->swap_file);
+	if (IS_ERR(page)) {
+		ret = PTR_ERR(page);
+		goto out;
+	}
+
+	backing_swap_header = kmap(page);
+	memcpy(s, backing_swap_header, sizeof(*s));
+	if (s->info.nr_badpages) {
+		pr_info("Cannot use backing swap with bad pages (%u)\n",
+			s->info.nr_badpages);
+		ret = -EINVAL;
+	}
+	/*
+	 * ramzswap disksize equals number of usable pages in backing
+	 * swap. Set last_page in swap header to match this disksize
+	 * ('last_page' means 0-based index of last usable swap page).
+	 */
+	s->info.last_page = (rzs->disksize >> PAGE_SHIFT) - 1;
+	kunmap(page);
+
+out:
+	return ret;
+}
+
+void ramzswap_ioctl_get_stats(struct ramzswap *rzs,
+			struct ramzswap_ioctl_stats *s)
+{
+	strncpy(s->backing_swap_name, rzs->backing_swap_name,
+		MAX_SWAP_NAME_LEN - 1);
+	s->backing_swap_name[MAX_SWAP_NAME_LEN - 1] = '\0';
+
+	s->disksize = rzs->disksize;
+	s->memlimit = rzs->memlimit;
+
+#if defined(CONFIG_RAMZSWAP_STATS)
+	{
+	struct ramzswap_stats *rs = &rzs->stats;
+	size_t succ_writes, mem_used;
+	unsigned int good_compress_perc = 0, no_compress_perc = 0;
+
+	mem_used = xv_get_total_size_bytes(rzs->mem_pool)
+			+ (rs->pages_expand << PAGE_SHIFT);
+	succ_writes = rs->num_writes - rs->failed_writes;
+
+	if (succ_writes && rs->pages_stored) {
+		good_compress_perc = rs->good_compress * 100
+					/ rs->pages_stored;
+		no_compress_perc = rs->pages_expand * 100
+					/ rs->pages_stored;
+	}
+
+	s->num_reads = rs->num_reads;
+	s->num_writes = rs->num_writes;
+	s->failed_reads = rs->failed_reads;
+	s->failed_writes = rs->failed_writes;
+	s->invalid_io = rs->invalid_io;
+	s->pages_zero = rs->pages_zero;
+
+	s->good_compress_pct = good_compress_perc;
+	s->pages_expand_pct = no_compress_perc;
+
+	s->pages_stored = rs->pages_stored;
+	s->pages_used = mem_used >> PAGE_SHIFT;
+	s->orig_data_size = rs->pages_stored << PAGE_SHIFT;
+	s->compr_data_size = rs->compr_size;
+	s->mem_used_total = mem_used;
+
+	s->bdev_num_reads = rs->bdev_num_reads;
+	s->bdev_num_writes = rs->bdev_num_writes;
+	}
+#endif /* CONFIG_RAMZSWAP_STATS */
+}
+
+static int add_backing_swap_extent(struct ramzswap *rzs,
+				pgoff_t phy_pagenum,
+				pgoff_t num_pages)
+{
+	unsigned int idx;
+	struct list_head *head;
+	struct page *curr_page, *new_page;
+	unsigned int extents_per_page = PAGE_SIZE /
+				sizeof(struct ramzswap_backing_extent);
+
+	idx = rzs->num_extents % extents_per_page;
+	if (!idx) {
+		new_page = alloc_page(__GFP_ZERO);
+		if (!new_page)
+			return -ENOMEM;
+
+		if (rzs->num_extents) {
+			curr_page = virt_to_page(rzs->curr_extent);
+			head = &curr_page->lru;
+		} else {
+			head = &rzs->backing_swap_extent_list;
+		}
+
+		list_add(&new_page->lru, head);
+		rzs->curr_extent = page_address(new_page);
+	}
+
+	rzs->curr_extent->phy_pagenum = phy_pagenum;
+	rzs->curr_extent->num_pages = num_pages;
+
+	pr_debug("add_extent: idx=%u, phy_pgnum=%lu, num_pgs=%lu, "
+		"pg_last=%lu, curr_ext=%p\n", idx, phy_pagenum, num_pages,
+		phy_pagenum + num_pages - 1, rzs->curr_extent);
+
+	if (idx != extents_per_page - 1)
+		rzs->curr_extent++;
+
+	return 0;
+}
+
+static int setup_backing_swap_extents(struct ramzswap *rzs,
+				struct inode *inode, unsigned long *num_pages)
+{
+	int ret = 0;
+	unsigned blkbits;
+	unsigned blocks_per_page;
+	pgoff_t contig_pages = 0, total_pages = 0;
+	pgoff_t pagenum = 0, prev_pagenum = 0;
+	sector_t probe_block = 0;
+	sector_t last_block;
+
+	blkbits = inode->i_blkbits;
+	blocks_per_page = PAGE_SIZE >> blkbits;
+
+	last_block = i_size_read(inode) >> blkbits;
+	while (probe_block + blocks_per_page <= last_block) {
+		unsigned block_in_page;
+		sector_t first_block;
+
+		first_block = bmap(inode, probe_block);
+		if (first_block == 0)
+			goto bad_bmap;
+
+		/* It must be PAGE_SIZE aligned on-disk */
+		if (first_block & (blocks_per_page - 1)) {
+			probe_block++;
+			goto probe_next;
+		}
+
+		/* All blocks within this page must be contiguous on disk */
+		for (block_in_page = 1; block_in_page < blocks_per_page;
+					block_in_page++) {
+			sector_t block;
+
+			block = bmap(inode, probe_block + block_in_page);
+			if (block == 0)
+				goto bad_bmap;
+			if (block != first_block + block_in_page) {
+				/* Discontiguity */
+				probe_block++;
+				goto probe_next;
+			}
+		}
+
+		/*
+		 * We found a PAGE_SIZE length, PAGE_SIZE aligned
+		 * run of blocks.
+		 */
+		pagenum = first_block >> (PAGE_SHIFT - blkbits);
+
+		if (total_pages && (pagenum != prev_pagenum + 1)) {
+			ret = add_backing_swap_extent(rzs, prev_pagenum -
+					(contig_pages - 1), contig_pages);
+			if (ret < 0)
+				goto out;
+			rzs->num_extents++;
+			contig_pages = 0;
+		}
+		total_pages++;
+		contig_pages++;
+		prev_pagenum = pagenum;
+		probe_block += blocks_per_page;
+
+probe_next:
+		continue;
+	}
+
+	if (contig_pages) {
+		pr_debug("adding last extent: pagenum=%lu, "
+			"contig_pages=%lu\n", pagenum, contig_pages);
+		ret = add_backing_swap_extent(rzs,
+			prev_pagenum - (contig_pages - 1), contig_pages);
+		if (ret < 0)
+			goto out;
+		rzs->num_extents++;
+	}
+	if (!rzs->num_extents) {
+		pr_err("No swap extents found!\n");
+		ret = -EINVAL;
+	}
+
+	if (!ret) {
+		*num_pages = total_pages;
+		pr_info("Found %lu extents containing %luk\n",
+			rzs->num_extents, *num_pages << (PAGE_SHIFT - 10));
+	}
+	goto out;
+
+bad_bmap:
+	pr_err("Backing swapfile has holes\n");
+	ret = -EINVAL;
+out:
+	while (ret && !list_empty(&rzs->backing_swap_extent_list)) {
+		struct page *page;
+		struct list_head *entry = rzs->backing_swap_extent_list.next;
+		page = list_entry(entry, struct page, lru);
+		list_del(entry);
+		__free_page(page);
+	}
+	return ret;
+}
+
+static void map_backing_swap_extents(struct ramzswap *rzs)
+{
+	struct ramzswap_backing_extent *se;
+	struct page *table_page, *se_page;
+	unsigned long num_pages, num_table_pages, entry;
+	unsigned long se_idx, span;
+	unsigned entries_per_page = PAGE_SIZE / sizeof(*rzs->table);
+	unsigned extents_per_page = PAGE_SIZE / sizeof(*se);
+
+	/* True for block device */
+	if (!rzs->num_extents)
+		return;
+
+	se_page = list_entry(rzs->backing_swap_extent_list.next,
+					struct page, lru);
+	se = page_address(se_page);
+	span = se->num_pages;
+	num_pages = rzs->disksize >> PAGE_SHIFT;
+	num_table_pages = DIV_ROUND_UP(num_pages * sizeof(*rzs->table),
+							PAGE_SIZE);
+
+	entry = 0;
+	se_idx = 0;
+	while (num_table_pages--) {
+		table_page = vmalloc_to_page(&rzs->table[entry]);
+		while (span <= entry) {
+			se_idx++;
+			if (se_idx == rzs->num_extents)
+				BUG();
+
+			if (!(se_idx % extents_per_page)) {
+				se_page = list_entry(se_page->lru.next,
+						struct page, lru);
+				se = page_address(se_page);
+			} else
+				se++;
+
+			span += se->num_pages;
+		}
+		table_page->mapping = (struct address_space *)se;
+		table_page->private = se->num_pages - (span - entry);
+		pr_debug("map_table: entry=%lu, span=%lu, map=%p, priv=%lu\n",
+			entry, span, table_page->mapping, table_page->private);
+		entry += entries_per_page;
+	}
+}
+
+/*
+ * Check if value of backing_swap module param is sane.
+ * Claim this device and set ramzswap size equal to
+ * size of this block device.
+ */
+static int setup_backing_swap(struct ramzswap *rzs)
+{
+	int ret = 0;
+	size_t disksize;
+	unsigned long num_pages = 0;
+	struct inode *inode;
+	struct file *swap_file;
+	struct address_space *mapping;
+	struct block_device *bdev = NULL;
+
+	if (!rzs->backing_swap_name[0]) {
+		pr_debug("backing_swap param not given\n");
+		goto out;
+	}
+
+	pr_info("Using backing swap device: %s\n", rzs->backing_swap_name);
+
+	swap_file = filp_open(rzs->backing_swap_name,
+				O_RDWR | O_LARGEFILE, 0);
+	if (IS_ERR(swap_file)) {
+		pr_err("Error opening backing device: %s\n",
+			rzs->backing_swap_name);
+		ret = -EINVAL;
+		goto out;
+	}
+
+	mapping = swap_file->f_mapping;
+	inode = mapping->host;
+
+	if (S_ISBLK(inode->i_mode)) {
+		bdev = I_BDEV(inode);
+		ret = bd_claim(bdev, setup_backing_swap);
+		if (ret < 0) {
+			bdev = NULL;
+			goto bad_param;
+		}
+		disksize = i_size_read(inode);
+	} else if (S_ISREG(inode->i_mode)) {
+		bdev = inode->i_sb->s_bdev;
+		if (IS_SWAPFILE(inode)) {
+			ret = -EBUSY;
+			goto bad_param;
+		}
+		ret = setup_backing_swap_extents(rzs, inode, &num_pages);
+		if (ret < 0)
+			goto bad_param;
+		disksize = num_pages << PAGE_SHIFT;
+	} else {
+		goto bad_param;
+	}
+
+	rzs->swap_file = swap_file;
+	rzs->backing_swap = bdev;
+	rzs->disksize = disksize;
+	BUG_ON(!rzs->disksize);
+
+	return 0;
+
+bad_param:
+	if (bdev)
+		bd_release(bdev);
+	filp_close(swap_file, NULL);
+
+out:
+	rzs->backing_swap = NULL;
+	return ret;
+}
+
+/*
+ * Map logical page number 'pagenum' to physical page number
+ * on backing swap device. For block device, this is a nop.
+ */
+u32 map_backing_swap_page(struct ramzswap *rzs, u32 pagenum)
+{
+	u32 skip_pages, entries_per_page;
+	size_t delta, se_offset, skipped;
+	struct page *table_page, *se_page;
+	struct ramzswap_backing_extent *se;
+
+	if (!rzs->num_extents)
+		return pagenum;
+
+	entries_per_page = PAGE_SIZE / sizeof(*rzs->table);
+
+	table_page = vmalloc_to_page(&rzs->table[pagenum]);
+	se = (struct ramzswap_backing_extent *)table_page->mapping;
+	se_page = virt_to_page(se);
+
+	skip_pages = pagenum - (pagenum / entries_per_page * entries_per_page);
+	se_offset = table_page->private + skip_pages;
+
+	if (se_offset < se->num_pages)
+		return se->phy_pagenum + se_offset;
+
+	skipped = se->num_pages - table_page->private;
+	do {
+		struct ramzswap_backing_extent *se_base;
+		u32 se_entries_per_page = PAGE_SIZE / sizeof(*se);
+
+		/* Get next swap extent */
+		se_base = (struct ramzswap_backing_extent *)
+						page_address(se_page);
+		if (se - se_base == se_entries_per_page - 1) {
+			se_page = list_entry(se_page->lru.next,
+						struct page, lru);
+			se = page_address(se_page);
+		} else {
+			se++;
+		}
+
+		skipped += se->num_pages;
+	} while (skipped < skip_pages);
+
+	delta = skipped - skip_pages;
+	se_offset = se->num_pages - delta;
+
+	return se->phy_pagenum + se_offset;
+}
+
+static void ramzswap_free_page(struct ramzswap *rzs, size_t index)
+{
+	u32 clen;
+	void *obj;
+
+	struct page *page = rzs->table[index].page;
+	u32 offset = rzs->table[index].offset;
+
+	if (unlikely(!page)) {
+		if (rzs_test_flag(rzs, index, RZS_ZERO)) {
+			rzs_clear_flag(rzs, index, RZS_ZERO);
+			stat_dec(rzs->stats.pages_zero);
+		}
+		return;
+	}
+
+	if (unlikely(rzs_test_flag(rzs, index, RZS_UNCOMPRESSED))) {
+		clen = PAGE_SIZE;
+		__free_page(page);
+		rzs_clear_flag(rzs, index, RZS_UNCOMPRESSED);
+		stat_dec(rzs->stats.pages_expand);
+		goto out;
+	}
+
+	obj = kmap_atomic(page, KM_USER0) + offset;
+	clen = xv_get_object_size(obj) - sizeof(struct zobj_header);
+	kunmap_atomic(obj, KM_USER0);
+
+	xv_free(rzs->mem_pool, page, offset);
+	if (clen <= PAGE_SIZE / 2)
+		stat_dec(rzs->stats.good_compress);
+
+out:
+	rzs->stats.compr_size -= clen;
+	stat_dec(rzs->stats.pages_stored);
+
+	rzs->table[index].page = NULL;
+	rzs->table[index].offset = 0;
+}
+
+static int handle_zero_page(struct bio *bio)
+{
+	void *user_mem;
+	struct page *page = bio->bi_io_vec[0].bv_page;
+
+	user_mem = kmap_atomic(page, KM_USER0);
+	memset(user_mem, 0, PAGE_SIZE);
+	kunmap_atomic(user_mem, KM_USER0);
+
+	flush_dcache_page(page);
+
+	set_bit(BIO_UPTODATE, &bio->bi_flags);
+	bio_endio(bio, 0);
+	return 0;
+}
+
+static int handle_uncompressed_page(struct ramzswap *rzs, struct bio *bio)
+{
+	u32 index;
+	struct page *page;
+	unsigned char *user_mem, *cmem;
+
+	page = bio->bi_io_vec[0].bv_page;
+	index = bio->bi_sector >> SECTORS_PER_PAGE_SHIFT;
+
+	user_mem = kmap_atomic(page, KM_USER0);
+	cmem = kmap_atomic(rzs->table[index].page, KM_USER1) +
+			rzs->table[index].offset;
+
+	memcpy(user_mem, cmem, PAGE_SIZE);
+	kunmap_atomic(user_mem, KM_USER0);
+	kunmap_atomic(cmem, KM_USER1);
+
+	flush_dcache_page(page);
+
+	set_bit(BIO_UPTODATE, &bio->bi_flags);
+	bio_endio(bio, 0);
+	return 0;
+}
+
+
+/*
+ * Called when request page is not present in ramzswap.
+ * Its either in backing swap device (if present) or
+ * this is an attempt to read before any previous write
+ * to this location - this happens due to readahead when
+ * swap device is read from user-space (e.g. during swapon)
+ */
+static int handle_ramzswap_fault(struct ramzswap *rzs, struct bio *bio)
+{
+	/*
+	 * Always forward such requests to backing swap
+	 * device (if present)
+	 */
+	if (rzs->backing_swap) {
+		u32 pagenum;
+		stat_dec(rzs->stats.num_reads);
+		stat_inc(rzs->stats.bdev_num_reads);
+		bio->bi_bdev = rzs->backing_swap;
+
+		/*
+		 * In case backing swap is a file, find the right offset within
+		 * the file corresponding to logical position 'index'. For block
+		 * device, this is a nop.
+		 */
+		pagenum = bio->bi_sector >> SECTORS_PER_PAGE_SHIFT;
+		bio->bi_sector = map_backing_swap_page(rzs, pagenum)
+					<< SECTORS_PER_PAGE_SHIFT;
+		return 1;
+	}
+
+	/*
+	 * Its unlikely event in case backing dev is
+	 * not present
+	 */
+	pr_debug("Read before write on swap device: "
+		"sector=%lu, size=%u, offset=%u\n",
+		(ulong)(bio->bi_sector), bio->bi_size,
+		bio->bi_io_vec[0].bv_offset);
+
+	/* Do nothing. Just return success */
+	set_bit(BIO_UPTODATE, &bio->bi_flags);
+	bio_endio(bio, 0);
+	return 0;
+}
+
+static int ramzswap_read(struct ramzswap *rzs, struct bio *bio)
+{
+	int ret;
+	u32 index;
+	size_t clen;
+	struct page *page;
+	struct zobj_header *zheader;
+	unsigned char *user_mem, *cmem;
+
+	stat_inc(rzs->stats.num_reads);
+
+	page = bio->bi_io_vec[0].bv_page;
+	index = bio->bi_sector >> SECTORS_PER_PAGE_SHIFT;
+
+	if (rzs_test_flag(rzs, index, RZS_ZERO))
+		return handle_zero_page(bio);
+
+	/* Requested page is not present in compressed area */
+	if (!rzs->table[index].page)
+		return handle_ramzswap_fault(rzs, bio);
+
+	/* Page is stored uncompressed since its incompressible */
+	if (unlikely(rzs_test_flag(rzs, index, RZS_UNCOMPRESSED)))
+		return handle_uncompressed_page(rzs, bio);
+
+	user_mem = kmap_atomic(page, KM_USER0);
+	clen = PAGE_SIZE;
+
+	cmem = kmap_atomic(rzs->table[index].page, KM_USER1) +
+			rzs->table[index].offset;
+
+	ret = lzo1x_decompress_safe(
+		cmem + sizeof(*zheader),
+		xv_get_object_size(cmem) - sizeof(*zheader),
+		user_mem, &clen);
+
+	kunmap_atomic(user_mem, KM_USER0);
+	kunmap_atomic(cmem, KM_USER1);
+
+	/* should NEVER happen */
+	if (unlikely(ret != LZO_E_OK)) {
+		pr_err("Decompression failed! err=%d, page=%u\n",
+			ret, index);
+		stat_inc(rzs->stats.failed_reads);
+		goto out;
+	}
+
+	flush_dcache_page(page);
+
+	set_bit(BIO_UPTODATE, &bio->bi_flags);
+	bio_endio(bio, 0);
+	return 0;
+
+out:
+	bio_io_error(bio);
+	return 0;
+}
+
+static int ramzswap_write(struct ramzswap *rzs, struct bio *bio)
+{
+	int ret, fwd_write_request = 0;
+	u32 offset, index;
+	size_t clen;
+	struct zobj_header *zheader;
+	struct page *page, *page_store;
+	unsigned char *user_mem, *cmem, *src;
+
+	stat_inc(rzs->stats.num_writes);
+
+	page = bio->bi_io_vec[0].bv_page;
+	index = bio->bi_sector >> SECTORS_PER_PAGE_SHIFT;
+
+	src = rzs->compress_buffer;
+
+	/*
+	 * System swaps to same sector again when the stored page
+	 * is no longer referenced by any process. So, its now safe
+	 * to free the memory that was allocated for this page.
+	 */
+	if (rzs->table[index].page)
+		ramzswap_free_page(rzs, index);
+
+	/*
+	 * No memory ia allocated for zero filled pages.
+	 * Simply clear zero page flag.
+	 */
+	if (rzs_test_flag(rzs, index, RZS_ZERO)) {
+		stat_dec(rzs->stats.pages_zero);
+		rzs_clear_flag(rzs, index, RZS_ZERO);
+	}
+
+	mutex_lock(&rzs->lock);
+
+	user_mem = kmap_atomic(page, KM_USER0);
+	if (page_zero_filled(user_mem)) {
+		kunmap_atomic(user_mem, KM_USER0);
+		mutex_unlock(&rzs->lock);
+		stat_inc(rzs->stats.pages_zero);
+		rzs_set_flag(rzs, index, RZS_ZERO);
+
+		set_bit(BIO_UPTODATE, &bio->bi_flags);
+		bio_endio(bio, 0);
+		return 0;
+	}
+
+	if (rzs->backing_swap &&
+		(rzs->stats.compr_size > rzs->memlimit - PAGE_SIZE)) {
+		kunmap_atomic(user_mem, KM_USER0);
+		mutex_unlock(&rzs->lock);
+		fwd_write_request = 1;
+		goto out;
+	}
+
+	ret = lzo1x_1_compress(user_mem, PAGE_SIZE, src, &clen,
+				rzs->compress_workmem);
+
+	kunmap_atomic(user_mem, KM_USER0);
+
+	if (unlikely(ret != LZO_E_OK)) {
+		mutex_unlock(&rzs->lock);
+		pr_err("Compression failed! err=%d\n", ret);
+		stat_inc(rzs->stats.failed_writes);
+		goto out;
+	}
+
+	/*
+	 * Page is incompressible. Forward it to backing swap
+	 * if present. Otherwise, store it as-is (uncompressed)
+	 * since we do not want to return too many swap write
+	 * errors which has side effect of hanging the system.
+	 */
+	if (unlikely(clen > max_zpage_size)) {
+		if (rzs->backing_swap) {
+			mutex_unlock(&rzs->lock);
+			fwd_write_request = 1;
+			goto out;
+		}
+
+		clen = PAGE_SIZE;
+		page_store = alloc_page(GFP_NOIO | __GFP_HIGHMEM);
+		if (unlikely(!page_store)) {
+			mutex_unlock(&rzs->lock);
+			pr_info("Error allocating memory for incompressible "
+				"page: %u\n", index);
+			stat_inc(rzs->stats.failed_writes);
+			goto out;
+		}
+
+		offset = 0;
+		rzs_set_flag(rzs, index, RZS_UNCOMPRESSED);
+		stat_inc(rzs->stats.pages_expand);
+		rzs->table[index].page = page_store;
+		src = kmap_atomic(page, KM_USER0);
+		goto memstore;
+	}
+
+	if (xv_malloc(rzs->mem_pool, clen + sizeof(*zheader),
+			&rzs->table[index].page, &offset,
+			GFP_NOIO | __GFP_HIGHMEM)) {
+		mutex_unlock(&rzs->lock);
+		pr_info("Error allocating memory for compressed "
+			"page: %u, size=%zu\n", index, clen);
+		stat_inc(rzs->stats.failed_writes);
+		if (rzs->backing_swap)
+			fwd_write_request = 1;
+		goto out;
+	}
+
+memstore:
+	rzs->table[index].offset = offset;
+
+	cmem = kmap_atomic(rzs->table[index].page, KM_USER1) +
+			rzs->table[index].offset;
+
+#if 0
+	/* Back-reference needed for memory defragmentation */
+	if (!rzs_test_flag(rzs, index, RZS_UNCOMPRESSED)) {
+		zheader = (struct zobj_header *)cmem;
+		zheader->table_idx = index;
+		cmem += sizeof(*zheader);
+	}
+#endif
+
+	memcpy(cmem, src, clen);
+
+	kunmap_atomic(cmem, KM_USER1);
+	if (unlikely(rzs_test_flag(rzs, index, RZS_UNCOMPRESSED)))
+		kunmap_atomic(src, KM_USER0);
+
+	/* Update stats */
+	rzs->stats.compr_size += clen;
+	stat_inc(rzs->stats.pages_stored);
+	if (clen <= PAGE_SIZE / 2)
+		stat_inc(rzs->stats.good_compress);
+
+	mutex_unlock(&rzs->lock);
+
+	set_bit(BIO_UPTODATE, &bio->bi_flags);
+	bio_endio(bio, 0);
+	return 0;
+
+out:
+	if (fwd_write_request) {
+		stat_inc(rzs->stats.bdev_num_writes);
+		bio->bi_bdev = rzs->backing_swap;
+#if 0
+		/*
+		 * TODO: We currently have linear mapping of ramzswap and
+		 * backing swap sectors. This is not desired since we want
+		 * to optimize writes to backing swap to minimize disk seeks
+		 * or have effective wear leveling (for SSDs). Also, a
+		 * non-linear mapping is required to implement compressed
+		 * on-disk swapping.
+		 */
+		 bio->bi_sector = get_backing_swap_page()
+					<< SECTORS_PER_PAGE_SHIFT;
+#endif
+		/*
+		 * In case backing swap is a file, find the right offset within
+		 * the file corresponding to logical position 'index'. For block
+		 * device, this is a nop.
+		 */
+		bio->bi_sector = map_backing_swap_page(rzs, index)
+					<< SECTORS_PER_PAGE_SHIFT;
+		return 1;
+	}
+
+	bio_io_error(bio);
+	return 0;
+}
+
+
+/*
+ * Check if request is within bounds and page aligned.
+ */
+static inline int valid_swap_request(struct ramzswap *rzs, struct bio *bio)
+{
+	if (unlikely(
+		(bio->bi_sector >= (rzs->disksize >> SECTOR_SHIFT)) ||
+		(bio->bi_sector & (SECTORS_PER_PAGE - 1)) ||
+		(bio->bi_vcnt != 1) ||
+		(bio->bi_size != PAGE_SIZE) ||
+		(bio->bi_io_vec[0].bv_offset != 0))) {
+
+		return 0;
+	}
+
+	/* swap request is valid */
+	return 1;
+}
+
+/*
+ * Handler function for all ramzswap I/O requests.
+ */
+static int ramzswap_make_request(struct request_queue *queue, struct bio *bio)
+{
+	int ret = 0;
+	struct ramzswap *rzs = queue->queuedata;
+
+	if (unlikely(!rzs->init_done)) {
+		bio_io_error(bio);
+		return 0;
+	}
+
+	if (!valid_swap_request(rzs, bio)) {
+		stat_inc(rzs->stats.invalid_io);
+		bio_io_error(bio);
+		return 0;
+	}
+
+	switch (bio_data_dir(bio)) {
+	case READ:
+		ret = ramzswap_read(rzs, bio);
+		break;
+
+	case WRITE:
+		ret = ramzswap_write(rzs, bio);
+		break;
+	}
+
+	return ret;
+}
+
+static void reset_device(struct ramzswap *rzs)
+{
+	int is_backing_blkdev = 0;
+	size_t index, num_pages;
+	unsigned entries_per_page;
+	unsigned long num_table_pages, entry = 0;
+
+	if (rzs->backing_swap && !rzs->num_extents)
+		is_backing_blkdev = 1;
+
+	num_pages = rzs->disksize >> PAGE_SHIFT;
+
+	/* Free various per-device buffers */
+	kfree(rzs->compress_workmem);
+	free_pages((unsigned long)rzs->compress_buffer, 1);
+
+	rzs->compress_workmem = NULL;
+	rzs->compress_buffer = NULL;
+
+	/* Free all pages that are still in this ramzswap device */
+	for (index = 0; index < num_pages; index++) {
+		struct page *page;
+		u16 offset;
+
+		page = rzs->table[index].page;
+		offset = rzs->table[index].offset;
+
+		if (!page)
+			continue;
+
+		if (unlikely(rzs_test_flag(rzs, index, RZS_UNCOMPRESSED)))
+			__free_page(page);
+		else
+			xv_free(rzs->mem_pool, page, offset);
+	}
+
+	entries_per_page = PAGE_SIZE / sizeof(*rzs->table);
+	num_table_pages = DIV_ROUND_UP(num_pages * sizeof(*rzs->table),
+					PAGE_SIZE);
+	/*
+	 * Set page->mapping to NULL for every table page.
+	 * Otherwise, we will hit bad_page() during free.
+	 */
+	while (rzs->num_extents && num_table_pages--) {
+		struct page *page;
+		page = vmalloc_to_page(&rzs->table[entry]);
+		page->mapping = NULL;
+		entry += entries_per_page;
+	}
+	vfree(rzs->table);
+	rzs->table = NULL;
+
+	xv_destroy_pool(rzs->mem_pool);
+	rzs->mem_pool = NULL;
+
+	/* Free all swap extent pages */
+	while (!list_empty(&rzs->backing_swap_extent_list)) {
+		struct page *page;
+		struct list_head *entry;
+		entry = rzs->backing_swap_extent_list.next;
+		page = list_entry(entry, struct page, lru);
+		list_del(entry);
+		__free_page(page);
+	}
+	INIT_LIST_HEAD(&rzs->backing_swap_extent_list);
+	rzs->num_extents = 0;
+
+	/* Close backing swap device, if present */
+	if (rzs->backing_swap) {
+		if (is_backing_blkdev)
+			bd_release(rzs->backing_swap);
+		filp_close(rzs->swap_file, NULL);
+		rzs->backing_swap = NULL;
+	}
+
+	/* Reset stats */
+	memset(&rzs->stats, 0, sizeof(rzs->stats));
+
+	rzs->disksize = 0;
+	rzs->memlimit = 0;
+
+	/* Back to uninitialized state */
+	rzs->init_done = 0;
+}
+
+static int ramzswap_ioctl_init_device(struct ramzswap *rzs)
+{
+	int ret;
+	size_t num_pages;
+	struct page *page;
+	union swap_header *swap_header;
+
+	if (rzs->init_done) {
+		pr_info("Device already initialized!\n");
+		return -EBUSY;
+	}
+
+	ret = setup_backing_swap(rzs);
+	if (ret)
+		goto fail;
+
+	if (rzs->backing_swap)
+		ramzswap_set_memlimit(rzs, totalram_pages << PAGE_SHIFT);
+	else
+		ramzswap_set_disksize(rzs, totalram_pages << PAGE_SHIFT);
+
+	rzs->compress_workmem = kzalloc(LZO1X_MEM_COMPRESS, GFP_KERNEL);
+	if (!rzs->compress_workmem) {
+		pr_err("Error allocating compressor working memory!\n");
+		ret = -ENOMEM;
+		goto fail;
+	}
+
+	rzs->compress_buffer = (void *)__get_free_pages(__GFP_ZERO, 1);
+	if (!rzs->compress_buffer) {
+		pr_err("Error allocating compressor buffer space\n");
+		ret = -ENOMEM;
+		goto fail;
+	}
+
+	num_pages = rzs->disksize >> PAGE_SHIFT;
+	rzs->table = vmalloc(num_pages * sizeof(*rzs->table));
+	if (!rzs->table) {
+		pr_err("Error allocating ramzswap address table\n");
+		/* To prevent accessing table entries during cleanup */
+		rzs->disksize = 0;
+		ret = -ENOMEM;
+		goto fail;
+	}
+	memset(rzs->table, 0, num_pages * sizeof(*rzs->table));
+
+	map_backing_swap_extents(rzs);
+
+	page = alloc_page(__GFP_ZERO);
+	if (!page) {
+		pr_err("Error allocating swap header page\n");
+		ret = -ENOMEM;
+		goto fail;
+	}
+	rzs->table[0].page = page;
+	rzs_set_flag(rzs, 0, RZS_UNCOMPRESSED);
+
+	swap_header = kmap(page);
+	ret = setup_swap_header(rzs, swap_header);
+	kunmap(page);
+	if (ret) {
+		pr_err("Error setting swap header\n");
+		goto fail;
+	}
+
+	set_capacity(rzs->disk, rzs->disksize >> SECTOR_SHIFT);
+
+	/*
+	 * We have ident mapping of sectors for ramzswap and
+	 * and the backing swap device. So, this queue flag
+	 * should be according to backing dev.
+	 */
+	if (!rzs->backing_swap ||
+			blk_queue_nonrot(rzs->backing_swap->bd_disk->queue))
+		queue_flag_set_unlocked(QUEUE_FLAG_NONROT, rzs->disk->queue);
+
+	rzs->mem_pool = xv_create_pool();
+	if (!rzs->mem_pool) {
+		pr_err("Error creating memory pool\n");
+		ret = -ENOMEM;
+		goto fail;
+	}
+
+	/*
+	 * Pages that compress to size greater than this are forwarded
+	 * to physical swap disk (if backing dev is provided)
+	 * TODO: make this configurable
+	 */
+	if (rzs->backing_swap)
+		max_zpage_size = max_zpage_size_bdev;
+	else
+		max_zpage_size = max_zpage_size_nobdev;
+	pr_debug("Max compressed page size: %u bytes\n", max_zpage_size);
+
+	rzs->init_done = 1;
+
+	pr_debug("Initialization done!\n");
+	return 0;
+
+fail:
+	reset_device(rzs);
+
+	pr_err("Initialization failed: err=%d\n", ret);
+	return ret;
+}
+
+static int ramzswap_ioctl_reset_device(struct ramzswap *rzs)
+{
+	if (rzs->init_done)
+		reset_device(rzs);
+
+	return 0;
+}
+
+static int ramzswap_ioctl(struct block_device *bdev, fmode_t mode,
+			unsigned int cmd, unsigned long arg)
+{
+	int ret = 0;
+	size_t disksize_kb, memlimit_kb;
+
+	struct ramzswap *rzs = bdev->bd_disk->private_data;
+
+	switch (cmd) {
+	case RZSIO_SET_DISKSIZE_KB:
+		if (rzs->init_done) {
+			ret = -EBUSY;
+			goto out;
+		}
+		if (copy_from_user(&disksize_kb, (void *)arg,
+						_IOC_SIZE(cmd))) {
+			ret = -EFAULT;
+			goto out;
+		}
+		rzs->disksize = disksize_kb << 10;
+		pr_info("Disk size set to %zu kB\n", disksize_kb);
+		break;
+
+	case RZSIO_SET_MEMLIMIT_KB:
+		if (rzs->init_done) {
+			/* TODO: allow changing memlimit */
+			ret = -EBUSY;
+			goto out;
+		}
+		if (copy_from_user(&memlimit_kb, (void *)arg,
+						_IOC_SIZE(cmd))) {
+			ret = -EFAULT;
+			goto out;
+		}
+		rzs->memlimit = memlimit_kb << 10;
+		pr_info("Memory limit set to %zu kB\n", memlimit_kb);
+		break;
+
+	case RZSIO_SET_BACKING_SWAP:
+		if (rzs->init_done) {
+			ret = -EBUSY;
+			goto out;
+		}
+
+		if (copy_from_user(&rzs->backing_swap_name, (void *)arg,
+						_IOC_SIZE(cmd))) {
+			ret = -EFAULT;
+			goto out;
+		}
+		rzs->backing_swap_name[MAX_SWAP_NAME_LEN - 1] = '\0';
+		pr_info("Backing swap set to %s\n", rzs->backing_swap_name);
+		break;
+
+	case RZSIO_GET_STATS:
+	{
+		struct ramzswap_ioctl_stats *stats;
+		if (!rzs->init_done) {
+			ret = -ENOTTY;
+			goto out;
+		}
+		stats = kzalloc(sizeof(*stats), GFP_KERNEL);
+		if (!stats) {
+			ret = -ENOMEM;
+			goto out;
+		}
+		ramzswap_ioctl_get_stats(rzs, stats);
+		if (copy_to_user((void *)arg, stats, sizeof(*stats))) {
+			kfree(stats);
+			ret = -EFAULT;
+			goto out;
+		}
+		kfree(stats);
+		break;
+	}
+	case RZSIO_INIT:
+		ret = ramzswap_ioctl_init_device(rzs);
+		break;
+
+	case RZSIO_RESET:
+		/* Do not reset an active device! */
+		if (bdev->bd_holders) {
+			ret = -EBUSY;
+			goto out;
+		}
+		ret = ramzswap_ioctl_reset_device(rzs);
+		break;
+
+	default:
+		pr_info("Invalid ioctl %u\n", cmd);
+		ret = -ENOTTY;
+	}
+
+out:
+	return ret;
+}
+
+static struct block_device_operations ramzswap_devops = {
+	.ioctl = ramzswap_ioctl,
+	.owner = THIS_MODULE,
+};
+
+static void create_device(struct ramzswap *rzs, int device_id)
+{
+	mutex_init(&rzs->lock);
+	INIT_LIST_HEAD(&rzs->backing_swap_extent_list);
+
+	rzs->queue = blk_alloc_queue(GFP_KERNEL);
+	if (!rzs->queue) {
+		pr_err("Error allocating disk queue for device %d\n",
+			device_id);
+		return;
+	}
+
+	blk_queue_make_request(rzs->queue, ramzswap_make_request);
+	rzs->queue->queuedata = rzs;
+
+	 /* gendisk structure */
+	rzs->disk = alloc_disk(1);
+	if (!rzs->disk) {
+		blk_cleanup_queue(rzs->queue);
+		pr_warning("Error allocating disk structure for device %d\n",
+			device_id);
+		return;
+	}
+
+	rzs->disk->major = ramzswap_major;
+	rzs->disk->first_minor = device_id;
+	rzs->disk->fops = &ramzswap_devops;
+	rzs->disk->queue = rzs->queue;
+	rzs->disk->private_data = rzs;
+	snprintf(rzs->disk->disk_name, 16, "ramzswap%d", device_id);
+
+	/*
+	 * Actual capacity set using RZSIO_SET_DISKSIZE_KB ioctl
+	 * or set equal to backing swap device (if provided)
+	 */
+	set_capacity(rzs->disk, 0);
+	add_disk(rzs->disk);
+
+	rzs->init_done = 0;
+}
+
+static void destroy_device(struct ramzswap *rzs)
+{
+	if (rzs->disk) {
+		del_gendisk(rzs->disk);
+		put_disk(rzs->disk);
+	}
+
+	if (rzs->queue)
+		blk_cleanup_queue(rzs->queue);
+}
+
+static int __init ramzswap_init(void)
+{
+	int i, ret;
+
+	if (num_devices > max_num_devices) {
+		pr_warning("Invalid value for num_devices: %u\n",
+				num_devices);
+		return -EINVAL;
+	}
+
+	ramzswap_major = register_blkdev(0, "ramzswap");
+	if (ramzswap_major <= 0) {
+		pr_warning("Unable to get major number\n");
+		return -EBUSY;
+	}
+
+	if (!num_devices) {
+		pr_info("num_devices not specified. Using default: 1\n");
+		num_devices = 1;
+	}
+
+	/* Allocate the device array and initialize each one */
+	pr_info("Creating %u devices ...\n", num_devices);
+	devices = kzalloc(num_devices * sizeof(struct ramzswap), GFP_KERNEL);
+	if (!devices) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	for (i = 0; i < num_devices; i++)
+		create_device(&devices[i], i);
+
+	return 0;
+out:
+	unregister_blkdev(ramzswap_major, "ramzswap");
+	return ret;
+}
+
+static void __exit ramzswap_exit(void)
+{
+	int i;
+	struct ramzswap *rzs;
+
+	for (i = 0; i < num_devices; i++) {
+		rzs = &devices[i];
+
+		destroy_device(rzs);
+		if (rzs->init_done)
+			reset_device(rzs);
+	}
+
+	unregister_blkdev(ramzswap_major, "ramzswap");
+
+	kfree(devices);
+	pr_debug("Cleanup done!\n");
+}
+
+module_param(num_devices, uint, 0);
+MODULE_PARM_DESC(num_devices, "Number of ramzswap devices");
+
+module_init(ramzswap_init);
+module_exit(ramzswap_exit);
+
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_AUTHOR("Nitin Gupta <ngupta@vflare.org>");
+MODULE_DESCRIPTION("Compressed RAM Based Swap Device");
diff -urNBb -x linux-2.6.31.9-ER1-efikamx/Documentation/dontdiff linux-2.6.31.9-ER1-efikamx.orig/drivers/staging/ramzswap/ramzswap_drv.h linux-2.6.31.9-ER1-efikamx/drivers/staging/ramzswap/ramzswap_drv.h
--- linux-2.6.31.9-ER1-efikamx.orig/drivers/staging/ramzswap/ramzswap_drv.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.31.9-ER1-efikamx/drivers/staging/ramzswap/ramzswap_drv.h	2010-01-09 14:42:53.494301580 -0600
@@ -0,0 +1,171 @@
+/*
+ * Compressed RAM based swap device
+ *
+ * Copyright (C) 2008, 2009  Nitin Gupta
+ *
+ * This code is released using a dual license strategy: BSD/GPL
+ * You can choose the licence that better fits your requirements.
+ *
+ * Released under the terms of 3-clause BSD License
+ * Released under the terms of GNU General Public License Version 2.0
+ *
+ * Project home: http://compcache.googlecode.com
+ */
+
+#ifndef _RAMZSWAP_DRV_H_
+#define _RAMZSWAP_DRV_H_
+
+#include "ramzswap_ioctl.h"
+#include "xvmalloc.h"
+
+/*
+ * Some arbitrary value. This is just to catch
+ * invalid value for num_devices module parameter.
+ */
+static const unsigned max_num_devices = 32;
+
+/*
+ * Stored at beginning of each compressed object.
+ *
+ * It stores back-reference to table entry which points to this
+ * object. This is required to support memory defragmentation or
+ * migrating compressed pages to backing swap disk.
+ */
+struct zobj_header {
+#if 0
+	u32 table_idx;
+#endif
+};
+
+/*-- Configurable parameters */
+
+/* Default ramzswap disk size: 25% of total RAM */
+static const unsigned default_disksize_perc_ram = 25;
+static const unsigned default_memlimit_perc_ram = 15;
+
+/*
+ * Max compressed page size when backing device is provided.
+ * Pages that compress to size greater than this are sent to
+ * physical swap disk.
+ */
+static const unsigned max_zpage_size_bdev = PAGE_SIZE / 2;
+
+/*
+ * Max compressed page size when there is no backing dev.
+ * Pages that compress to size greater than this are stored
+ * uncompressed in memory.
+ */
+static const unsigned max_zpage_size_nobdev = PAGE_SIZE / 4 * 3;
+
+/*
+ * NOTE: max_zpage_size_{bdev,nobdev} sizes must be
+ * less than or equal to:
+ *   XV_MAX_ALLOC_SIZE - sizeof(struct zobj_header)
+ * since otherwise xv_malloc would always return failure.
+ */
+
+/*-- End of configurable params */
+
+#define SECTOR_SHIFT		9
+#define SECTOR_SIZE		(1 << SECTOR_SHIFT)
+#define SECTORS_PER_PAGE_SHIFT	(PAGE_SHIFT - SECTOR_SHIFT)
+#define SECTORS_PER_PAGE	(1 << SECTORS_PER_PAGE_SHIFT)
+
+/* Debugging and Stats */
+#if defined(CONFIG_RAMZSWAP_STATS)
+#define stat_inc(stat)	((stat)++)
+#define stat_dec(stat)	((stat)--)
+#else
+#define stat_inc(x)
+#define stat_dec(x)
+#endif
+
+/* Flags for ramzswap pages (table[page_no].flags) */
+enum rzs_pageflags {
+	/* Page is stored uncompressed */
+	RZS_UNCOMPRESSED,
+
+	/* Page consists entirely of zeros */
+	RZS_ZERO,
+
+	__NR_RZS_PAGEFLAGS,
+};
+
+/*-- Data structures */
+
+/*
+ * Allocated for each swap slot, indexed by page no.
+ * These table entries must fit exactly in a page.
+ */
+struct table {
+	struct page *page;
+	u16 offset;
+	u8 count;	/* object ref count (not yet used) */
+	u8 flags;
+} __attribute__((aligned(4)));;
+
+/*
+ * Swap extent information in case backing swap is a regular
+ * file. These extent entries must fit exactly in a page.
+ */
+struct ramzswap_backing_extent {
+	pgoff_t phy_pagenum;
+	pgoff_t num_pages;
+} __attribute__((aligned(4)));
+
+struct ramzswap_stats {
+	/* basic stats */
+	size_t compr_size;	/* compressed size of pages stored -
+				 * needed to enforce memlimit */
+	/* more stats */
+#if defined(CONFIG_RAMZSWAP_STATS)
+	u64 num_reads;		/* failed + successful */
+	u64 num_writes;		/* --do-- */
+	u64 failed_reads;	/* can happen when memory is too low */
+	u64 failed_writes;	/* should NEVER! happen */
+	u64 invalid_io;		/* non-swap I/O requests */
+	u32 pages_zero;		/* no. of zero filled pages */
+	u32 pages_stored;	/* no. of pages currently stored */
+	u32 good_compress;	/* % of pages with compression ratio<=50% */
+	u32 pages_expand;	/* % of incompressible pages */
+	u64 bdev_num_reads;	/* no. of reads on backing dev */
+	u64 bdev_num_writes;	/* no. of writes on backing dev */
+#endif
+};
+
+struct ramzswap {
+	struct xv_pool *mem_pool;
+	void *compress_workmem;
+	void *compress_buffer;
+	struct table *table;
+	struct mutex lock;
+	struct request_queue *queue;
+	struct gendisk *disk;
+	int init_done;
+	/*
+	 * This is limit on compressed data size (stats.compr_size)
+	 * Its applicable only when backing swap device is present.
+	 */
+	size_t memlimit;	/* bytes */
+	/*
+	 * This is limit on amount of *uncompressed* worth of data
+	 * we can hold. When backing swap device is provided, it is
+	 * set equal to device size.
+	 */
+	size_t disksize;	/* bytes */
+
+	struct ramzswap_stats stats;
+
+	/* backing swap device info */
+	struct ramzswap_backing_extent *curr_extent;
+	struct list_head backing_swap_extent_list;
+	unsigned long num_extents;
+	char backing_swap_name[MAX_SWAP_NAME_LEN];
+	struct block_device *backing_swap;
+	struct file *swap_file;
+};
+
+/*-- */
+
+#endif
+
diff -urNBb -x linux-2.6.31.9-ER1-efikamx/Documentation/dontdiff linux-2.6.31.9-ER1-efikamx.orig/drivers/staging/ramzswap/ramzswap_ioctl.h linux-2.6.31.9-ER1-efikamx/drivers/staging/ramzswap/ramzswap_ioctl.h
--- linux-2.6.31.9-ER1-efikamx.orig/drivers/staging/ramzswap/ramzswap_ioctl.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.31.9-ER1-efikamx/drivers/staging/ramzswap/ramzswap_ioctl.h	2010-01-09 14:42:53.494301580 -0600
@@ -0,0 +1,49 @@
+/*
+ * Compressed RAM based swap device
+ *
+ * Copyright (C) 2008, 2009  Nitin Gupta
+ *
+ * This code is released using a dual license strategy: BSD/GPL
+ * You can choose the licence that better fits your requirements.
+ *
+ * Released under the terms of 3-clause BSD License
+ * Released under the terms of GNU General Public License Version 2.0
+ *
+ * Project home: http://compcache.googlecode.com
+ */
+
+#ifndef _RAMZSWAP_IOCTL_H_
+#define _RAMZSWAP_IOCTL_H_
+
+#define MAX_SWAP_NAME_LEN 128
+
+struct ramzswap_ioctl_stats {
+	char backing_swap_name[MAX_SWAP_NAME_LEN];
+	u64 memlimit;		/* only applicable if backing swap present */
+	u64 disksize;		/* user specified or equal to backing swap
+				 * size (if present) */
+	u64 num_reads;		/* failed + successful */
+	u64 num_writes;		/* --do-- */
+	u64 failed_reads;	/* can happen when memory is too low */
+	u64 failed_writes;	/* should NEVER! happen */
+	u64 invalid_io;		/* non-swap I/O requests */
+	u32 pages_zero;		/* no. of zero filled pages */
+	u32 good_compress_pct;	/* no. of pages with compression ratio<=50% */
+	u32 pages_expand_pct;	/* no. of incompressible pages */
+	u32 pages_stored;
+	u32 pages_used;
+	u64 orig_data_size;
+	u64 compr_data_size;
+	u64 mem_used_total;
+	u64 bdev_num_reads;	/* no. of reads on backing dev */
+	u64 bdev_num_writes;	/* no. of writes on backing dev */
+} __attribute__ ((packed, aligned(4)));
+
+#define RZSIO_SET_DISKSIZE_KB	_IOW('z', 0, size_t)
+#define RZSIO_SET_MEMLIMIT_KB	_IOW('z', 1, size_t)
+#define RZSIO_SET_BACKING_SWAP	_IOW('z', 2, unsigned char[MAX_SWAP_NAME_LEN])
+#define RZSIO_GET_STATS		_IOR('z', 3, struct ramzswap_ioctl_stats)
+#define RZSIO_INIT		_IO('z', 4)
+#define RZSIO_RESET		_IO('z', 5)
+
+#endif
diff -urNBb -x linux-2.6.31.9-ER1-efikamx/Documentation/dontdiff linux-2.6.31.9-ER1-efikamx.orig/drivers/staging/ramzswap/ramzswap.txt linux-2.6.31.9-ER1-efikamx/drivers/staging/ramzswap/ramzswap.txt
--- linux-2.6.31.9-ER1-efikamx.orig/drivers/staging/ramzswap/ramzswap.txt	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.31.9-ER1-efikamx/drivers/staging/ramzswap/ramzswap.txt	2010-01-09 14:42:53.494301580 -0600
@@ -0,0 +1,51 @@
+ramzswap: Compressed RAM based swap device
+-------------------------------------------
+
+Project home: http://compcache.googlecode.com/
+
+* Introduction
+
+It creates RAM based block devices which can be used (only) as swap disks.
+Pages swapped to these devices are compressed and stored in memory itself.
+See project home for use cases, performance numbers and a lot more.
+
+Individual ramzswap devices are configured and initialized using rzscontrol
+userspace utility as shown in examples below. See rzscontrol man page for more
+details.
+
+* Usage
+
+Following shows a typical sequence of steps for using ramzswap.
+
+1) Load Modules:
+	modprobe ramzswap num_devices=4
+	This creates 4 (uninitialized) devices: /dev/ramzswap{0,1,2,3}
+	(num_devices parameter is optional. Default: 1)
+
+2) Initialize:
+	Use rzscontrol utility to configure and initialize individual
+	ramzswap devices. Example:
+	rzscontrol /dev/ramzswap2 --init # uses default value of disksize_kb
+
+	*See rzscontrol man page for more details and examples*
+
+3) Activate:
+	swapon /dev/ramzswap2 # or any other initialized ramzswap device
+
+4) Stats:
+	rzscontrol /dev/ramzswap2 --stats
+
+5) Deactivate:
+	swapoff /dev/ramzswap2
+
+6) Reset:
+	rzscontrol /dev/ramzswap2 --reset
+	(This frees all the memory allocated for this device).
+
+
+Please report any problems at:
+ - Mailing list: linux-mm-cc at laptop dot org
+ - Issue tracker: http://code.google.com/p/compcache/issues/list
+
+Nitin Gupta
+ngupta@vflare.org
diff -urNBb -x linux-2.6.31.9-ER1-efikamx/Documentation/dontdiff linux-2.6.31.9-ER1-efikamx.orig/drivers/staging/ramzswap/TODO linux-2.6.31.9-ER1-efikamx/drivers/staging/ramzswap/TODO
--- linux-2.6.31.9-ER1-efikamx.orig/drivers/staging/ramzswap/TODO	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.31.9-ER1-efikamx/drivers/staging/ramzswap/TODO	2010-01-09 14:42:53.494301580 -0600
@@ -0,0 +1,5 @@
+TODO:
+	- Add support for swap notifiers
+
+Please send patches to Greg Kroah-Hartman <greg@kroah.com> and
+Nitin Gupta <ngupta@vflare.org>
diff -urNBb -x linux-2.6.31.9-ER1-efikamx/Documentation/dontdiff linux-2.6.31.9-ER1-efikamx.orig/drivers/staging/ramzswap/xvmalloc.c linux-2.6.31.9-ER1-efikamx/drivers/staging/ramzswap/xvmalloc.c
--- linux-2.6.31.9-ER1-efikamx.orig/drivers/staging/ramzswap/xvmalloc.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.31.9-ER1-efikamx/drivers/staging/ramzswap/xvmalloc.c	2010-01-09 14:42:53.494301580 -0600
@@ -0,0 +1,507 @@
+/*
+ * xvmalloc memory allocator
+ *
+ * Copyright (C) 2008, 2009  Nitin Gupta
+ *
+ * This code is released using a dual license strategy: BSD/GPL
+ * You can choose the licence that better fits your requirements.
+ *
+ * Released under the terms of 3-clause BSD License
+ * Released under the terms of GNU General Public License Version 2.0
+ */
+
+#include <linux/bitops.h>
+#include <linux/errno.h>
+#include <linux/highmem.h>
+#include <linux/init.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+
+#include "xvmalloc.h"
+#include "xvmalloc_int.h"
+
+static void stat_inc(u64 *value)
+{
+	*value = *value + 1;
+}
+
+static void stat_dec(u64 *value)
+{
+	*value = *value - 1;
+}
+
+static int test_flag(struct block_header *block, enum blockflags flag)
+{
+	return block->prev & BIT(flag);
+}
+
+static void set_flag(struct block_header *block, enum blockflags flag)
+{
+	block->prev |= BIT(flag);
+}
+
+static void clear_flag(struct block_header *block, enum blockflags flag)
+{
+	block->prev &= ~BIT(flag);
+}
+
+/*
+ * Given <page, offset> pair, provide a derefrencable pointer.
+ * This is called from xv_malloc/xv_free path, so it
+ * needs to be fast.
+ */
+static void *get_ptr_atomic(struct page *page, u16 offset, enum km_type type)
+{
+	unsigned char *base;
+
+	base = kmap_atomic(page, type);
+	return base + offset;
+}
+
+static void put_ptr_atomic(void *ptr, enum km_type type)
+{
+	kunmap_atomic(ptr, type);
+}
+
+static u32 get_blockprev(struct block_header *block)
+{
+	return block->prev & PREV_MASK;
+}
+
+static void set_blockprev(struct block_header *block, u16 new_offset)
+{
+	block->prev = new_offset | (block->prev & FLAGS_MASK);
+}
+
+static struct block_header *BLOCK_NEXT(struct block_header *block)
+{
+	return (struct block_header *)
+		((char *)block + block->size + XV_ALIGN);
+}
+
+/*
+ * Get index of free list containing blocks of maximum size
+ * which is less than or equal to given size.
+ */
+static u32 get_index_for_insert(u32 size)
+{
+	if (unlikely(size > XV_MAX_ALLOC_SIZE))
+		size = XV_MAX_ALLOC_SIZE;
+	size &= ~FL_DELTA_MASK;
+	return (size - XV_MIN_ALLOC_SIZE) >> FL_DELTA_SHIFT;
+}
+
+/*
+ * Get index of free list having blocks of size greater than
+ * or equal to requested size.
+ */
+static u32 get_index(u32 size)
+{
+	if (unlikely(size < XV_MIN_ALLOC_SIZE))
+		size = XV_MIN_ALLOC_SIZE;
+	size = ALIGN(size, FL_DELTA);
+	return (size - XV_MIN_ALLOC_SIZE) >> FL_DELTA_SHIFT;
+}
+
+/**
+ * find_block - find block of at least given size
+ * @pool: memory pool to search from
+ * @size: size of block required
+ * @page: page containing required block
+ * @offset: offset within the page where block is located.
+ *
+ * Searches two level bitmap to locate block of at least
+ * the given size. If such a block is found, it provides
+ * <page, offset> to identify this block and returns index
+ * in freelist where we found this block.
+ * Otherwise, returns 0 and <page, offset> params are not touched.
+ */
+static u32 find_block(struct xv_pool *pool, u32 size,
+			struct page **page, u32 *offset)
+{
+	ulong flbitmap, slbitmap;
+	u32 flindex, slindex, slbitstart;
+
+	/* There are no free blocks in this pool */
+	if (!pool->flbitmap)
+		return 0;
+
+	/* Get freelist index correspoding to this size */
+	slindex = get_index(size);
+	slbitmap = pool->slbitmap[slindex / BITS_PER_LONG];
+	slbitstart = slindex % BITS_PER_LONG;
+
+	/*
+	 * If freelist is not empty at this index, we found the
+	 * block - head of this list. This is approximate best-fit match.
+	 */
+	if (test_bit(slbitstart, &slbitmap)) {
+		*page = pool->freelist[slindex].page;
+		*offset = pool->freelist[slindex].offset;
+		return slindex;
+	}
+
+	/*
+	 * No best-fit found. Search a bit further in bitmap for a free block.
+	 * Second level bitmap consists of series of 32-bit chunks. Search
+	 * further in the chunk where we expected a best-fit, starting from
+	 * index location found above.
+	 */
+	slbitstart++;
+	slbitmap >>= slbitstart;
+
+	/* Skip this search if we were already at end of this bitmap chunk */
+	if ((slbitstart != BITS_PER_LONG) && slbitmap) {
+		slindex += __ffs(slbitmap) + 1;
+		*page = pool->freelist[slindex].page;
+		*offset = pool->freelist[slindex].offset;
+		return slindex;
+	}
+
+	/* Now do a full two-level bitmap search to find next nearest fit */
+	flindex = slindex / BITS_PER_LONG;
+
+	flbitmap = (pool->flbitmap) >> (flindex + 1);
+	if (!flbitmap)
+		return 0;
+
+	flindex += __ffs(flbitmap) + 1;
+	slbitmap = pool->slbitmap[flindex];
+	slindex = (flindex * BITS_PER_LONG) + __ffs(slbitmap);
+	*page = pool->freelist[slindex].page;
+	*offset = pool->freelist[slindex].offset;
+
+	return slindex;
+}
+
+/*
+ * Insert block at <page, offset> in freelist of given pool.
+ * freelist used depends on block size.
+ */
+static void insert_block(struct xv_pool *pool, struct page *page, u32 offset,
+			struct block_header *block)
+{
+	u32 flindex, slindex;
+	struct block_header *nextblock;
+
+	slindex = get_index_for_insert(block->size);
+	flindex = slindex / BITS_PER_LONG;
+
+	block->link.prev_page = 0;
+	block->link.prev_offset = 0;
+	block->link.next_page = pool->freelist[slindex].page;
+	block->link.next_offset = pool->freelist[slindex].offset;
+	pool->freelist[slindex].page = page;
+	pool->freelist[slindex].offset = offset;
+
+	if (block->link.next_page) {
+		nextblock = get_ptr_atomic(block->link.next_page,
+					block->link.next_offset, KM_USER1);
+		nextblock->link.prev_page = page;
+		nextblock->link.prev_offset = offset;
+		put_ptr_atomic(nextblock, KM_USER1);
+	}
+
+	__set_bit(slindex % BITS_PER_LONG, &pool->slbitmap[flindex]);
+	__set_bit(flindex, &pool->flbitmap);
+}
+
+/*
+ * Remove block from head of freelist. Index 'slindex' identifies the freelist.
+ */
+static void remove_block_head(struct xv_pool *pool,
+			struct block_header *block, u32 slindex)
+{
+	struct block_header *tmpblock;
+	u32 flindex = slindex / BITS_PER_LONG;
+
+	pool->freelist[slindex].page = block->link.next_page;
+	pool->freelist[slindex].offset = block->link.next_offset;
+	block->link.prev_page = 0;
+	block->link.prev_offset = 0;
+
+	if (!pool->freelist[slindex].page) {
+		__clear_bit(slindex % BITS_PER_LONG, &pool->slbitmap[flindex]);
+		if (!pool->slbitmap[flindex])
+			__clear_bit(flindex, &pool->flbitmap);
+	} else {
+		/*
+		 * DEBUG ONLY: We need not reinitialize freelist head previous
+		 * pointer to 0 - we never depend on its value. But just for
+		 * sanity, lets do it.
+		 */
+		tmpblock = get_ptr_atomic(pool->freelist[slindex].page,
+				pool->freelist[slindex].offset, KM_USER1);
+		tmpblock->link.prev_page = 0;
+		tmpblock->link.prev_offset = 0;
+		put_ptr_atomic(tmpblock, KM_USER1);
+	}
+}
+
+/*
+ * Remove block from freelist. Index 'slindex' identifies the freelist.
+ */
+static void remove_block(struct xv_pool *pool, struct page *page, u32 offset,
+			struct block_header *block, u32 slindex)
+{
+	u32 flindex;
+	struct block_header *tmpblock;
+
+	if (pool->freelist[slindex].page == page
+	   && pool->freelist[slindex].offset == offset) {
+		remove_block_head(pool, block, slindex);
+		return;
+	}
+
+	flindex = slindex / BITS_PER_LONG;
+
+	if (block->link.prev_page) {
+		tmpblock = get_ptr_atomic(block->link.prev_page,
+				block->link.prev_offset, KM_USER1);
+		tmpblock->link.next_page = block->link.next_page;
+		tmpblock->link.next_offset = block->link.next_offset;
+		put_ptr_atomic(tmpblock, KM_USER1);
+	}
+
+	if (block->link.next_page) {
+		tmpblock = get_ptr_atomic(block->link.next_page,
+				block->link.next_offset, KM_USER1);
+		tmpblock->link.prev_page = block->link.prev_page;
+		tmpblock->link.prev_offset = block->link.prev_offset;
+		put_ptr_atomic(tmpblock, KM_USER1);
+	}
+}
+
+/*
+ * Allocate a page and add it freelist of given pool.
+ */
+static int grow_pool(struct xv_pool *pool, gfp_t flags)
+{
+	struct page *page;
+	struct block_header *block;
+
+	page = alloc_page(flags);
+	if (unlikely(!page))
+		return -ENOMEM;
+
+	stat_inc(&pool->total_pages);
+
+	spin_lock(&pool->lock);
+	block = get_ptr_atomic(page, 0, KM_USER0);
+
+	block->size = PAGE_SIZE - XV_ALIGN;
+	set_flag(block, BLOCK_FREE);
+	clear_flag(block, PREV_FREE);
+	set_blockprev(block, 0);
+
+	insert_block(pool, page, 0, block);
+
+	put_ptr_atomic(block, KM_USER0);
+	spin_unlock(&pool->lock);
+
+	return 0;
+}
+
+/*
+ * Create a memory pool. Allocates freelist, bitmaps and other
+ * per-pool metadata.
+ */
+struct xv_pool *xv_create_pool(void)
+{
+	u32 ovhd_size;
+	struct xv_pool *pool;
+
+	ovhd_size = roundup(sizeof(*pool), PAGE_SIZE);
+	pool = kzalloc(ovhd_size, GFP_KERNEL);
+	if (!pool)
+		return NULL;
+
+	spin_lock_init(&pool->lock);
+
+	return pool;
+}
+
+void xv_destroy_pool(struct xv_pool *pool)
+{
+	kfree(pool);
+}
+
+/**
+ * xv_malloc - Allocate block of given size from pool.
+ * @pool: pool to allocate from
+ * @size: size of block to allocate
+ * @page: page no. that holds the object
+ * @offset: location of object within page
+ *
+ * On success, <page, offset> identifies block allocated
+ * and 0 is returned. On failure, <page, offset> is set to
+ * 0 and -ENOMEM is returned.
+ *
+ * Allocation requests with size > XV_MAX_ALLOC_SIZE will fail.
+ */
+int xv_malloc(struct xv_pool *pool, u32 size, struct page **page,
+		u32 *offset, gfp_t flags)
+{
+	int error;
+	u32 index, tmpsize, origsize, tmpoffset;
+	struct block_header *block, *tmpblock;
+
+	*page = NULL;
+	*offset = 0;
+	origsize = size;
+
+	if (unlikely(!size || size > XV_MAX_ALLOC_SIZE))
+		return -ENOMEM;
+
+	size = ALIGN(size, XV_ALIGN);
+
+	spin_lock(&pool->lock);
+
+	index = find_block(pool, size, page, offset);
+
+	if (!*page) {
+		spin_unlock(&pool->lock);
+		if (flags & GFP_NOWAIT)
+			return -ENOMEM;
+		error = grow_pool(pool, flags);
+		if (unlikely(error))
+			return error;
+
+		spin_lock(&pool->lock);
+		index = find_block(pool, size, page, offset);
+	}
+
+	if (!*page) {
+		spin_unlock(&pool->lock);
+		return -ENOMEM;
+	}
+
+	block = get_ptr_atomic(*page, *offset, KM_USER0);
+
+	remove_block_head(pool, block, index);
+
+	/* Split the block if required */
+	tmpoffset = *offset + size + XV_ALIGN;
+	tmpsize = block->size - size;
+	tmpblock = (struct block_header *)((char *)block + size + XV_ALIGN);
+	if (tmpsize) {
+		tmpblock->size = tmpsize - XV_ALIGN;
+		set_flag(tmpblock, BLOCK_FREE);
+		clear_flag(tmpblock, PREV_FREE);
+
+		set_blockprev(tmpblock, *offset);
+		if (tmpblock->size >= XV_MIN_ALLOC_SIZE)
+			insert_block(pool, *page, tmpoffset, tmpblock);
+
+		if (tmpoffset + XV_ALIGN + tmpblock->size != PAGE_SIZE) {
+			tmpblock = BLOCK_NEXT(tmpblock);
+			set_blockprev(tmpblock, tmpoffset);
+		}
+	} else {
+		/* This block is exact fit */
+		if (tmpoffset != PAGE_SIZE)
+			clear_flag(tmpblock, PREV_FREE);
+	}
+
+	block->size = origsize;
+	clear_flag(block, BLOCK_FREE);
+
+	put_ptr_atomic(block, KM_USER0);
+	spin_unlock(&pool->lock);
+
+	*offset += XV_ALIGN;
+
+	return 0;
+}
+
+/*
+ * Free block identified with <page, offset>
+ */
+void xv_free(struct xv_pool *pool, struct page *page, u32 offset)
+{
+	void *page_start;
+	struct block_header *block, *tmpblock;
+
+	offset -= XV_ALIGN;
+
+	spin_lock(&pool->lock);
+
+	page_start = get_ptr_atomic(page, 0, KM_USER0);
+	block = (struct block_header *)((char *)page_start + offset);
+
+	/* Catch double free bugs */
+	BUG_ON(test_flag(block, BLOCK_FREE));
+
+	block->size = ALIGN(block->size, XV_ALIGN);
+
+	tmpblock = BLOCK_NEXT(block);
+	if (offset + block->size + XV_ALIGN == PAGE_SIZE)
+		tmpblock = NULL;
+
+	/* Merge next block if its free */
+	if (tmpblock && test_flag(tmpblock, BLOCK_FREE)) {
+		/*
+		 * Blocks smaller than XV_MIN_ALLOC_SIZE
+		 * are not inserted in any free list.
+		 */
+		if (tmpblock->size >= XV_MIN_ALLOC_SIZE) {
+			remove_block(pool, page,
+				    offset + block->size + XV_ALIGN, tmpblock,
+				    get_index_for_insert(tmpblock->size));
+		}
+		block->size += tmpblock->size + XV_ALIGN;
+	}
+
+	/* Merge previous block if its free */
+	if (test_flag(block, PREV_FREE)) {
+		tmpblock = (struct block_header *)((char *)(page_start) +
+						get_blockprev(block));
+		offset = offset - tmpblock->size - XV_ALIGN;
+
+		if (tmpblock->size >= XV_MIN_ALLOC_SIZE)
+			remove_block(pool, page, offset, tmpblock,
+				    get_index_for_insert(tmpblock->size));
+
+		tmpblock->size += block->size + XV_ALIGN;
+		block = tmpblock;
+	}
+
+	/* No used objects in this page. Free it. */
+	if (block->size == PAGE_SIZE - XV_ALIGN) {
+		put_ptr_atomic(page_start, KM_USER0);
+		spin_unlock(&pool->lock);
+
+		__free_page(page);
+		stat_dec(&pool->total_pages);
+		return;
+	}
+
+	set_flag(block, BLOCK_FREE);
+	if (block->size >= XV_MIN_ALLOC_SIZE)
+		insert_block(pool, page, offset, block);
+
+	if (offset + block->size + XV_ALIGN != PAGE_SIZE) {
+		tmpblock = BLOCK_NEXT(block);
+		set_flag(tmpblock, PREV_FREE);
+		set_blockprev(tmpblock, offset);
+	}
+
+	put_ptr_atomic(page_start, KM_USER0);
+	spin_unlock(&pool->lock);
+}
+
+u32 xv_get_object_size(void *obj)
+{
+	struct block_header *blk;
+
+	blk = (struct block_header *)((char *)(obj) - XV_ALIGN);
+	return blk->size;
+}
+
+/*
+ * Returns total memory used by allocator (userdata + metadata)
+ */
+u64 xv_get_total_size_bytes(struct xv_pool *pool)
+{
+	return pool->total_pages << PAGE_SHIFT;
+}
diff -urNBb -x linux-2.6.31.9-ER1-efikamx/Documentation/dontdiff linux-2.6.31.9-ER1-efikamx.orig/drivers/staging/ramzswap/xvmalloc.h linux-2.6.31.9-ER1-efikamx/drivers/staging/ramzswap/xvmalloc.h
--- linux-2.6.31.9-ER1-efikamx.orig/drivers/staging/ramzswap/xvmalloc.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.31.9-ER1-efikamx/drivers/staging/ramzswap/xvmalloc.h	2010-01-09 14:42:53.494301580 -0600
@@ -0,0 +1,30 @@
+/*
+ * xvmalloc memory allocator
+ *
+ * Copyright (C) 2008, 2009  Nitin Gupta
+ *
+ * This code is released using a dual license strategy: BSD/GPL
+ * You can choose the licence that better fits your requirements.
+ *
+ * Released under the terms of 3-clause BSD License
+ * Released under the terms of GNU General Public License Version 2.0
+ */
+
+#ifndef _XV_MALLOC_H_
+#define _XV_MALLOC_H_
+
+#include <linux/types.h>
+
+struct xv_pool;
+
+struct xv_pool *xv_create_pool(void);
+void xv_destroy_pool(struct xv_pool *pool);
+
+int xv_malloc(struct xv_pool *pool, u32 size, struct page **page,
+			u32 *offset, gfp_t flags);
+void xv_free(struct xv_pool *pool, struct page *page, u32 offset);
+
+u32 xv_get_object_size(void *obj);
+u64 xv_get_total_size_bytes(struct xv_pool *pool);
+
+#endif
diff -urNBb -x linux-2.6.31.9-ER1-efikamx/Documentation/dontdiff linux-2.6.31.9-ER1-efikamx.orig/drivers/staging/ramzswap/xvmalloc_int.h linux-2.6.31.9-ER1-efikamx/drivers/staging/ramzswap/xvmalloc_int.h
--- linux-2.6.31.9-ER1-efikamx.orig/drivers/staging/ramzswap/xvmalloc_int.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.31.9-ER1-efikamx/drivers/staging/ramzswap/xvmalloc_int.h	2010-01-09 14:42:53.494301580 -0600
@@ -0,0 +1,86 @@
+/*
+ * xvmalloc memory allocator
+ *
+ * Copyright (C) 2008, 2009  Nitin Gupta
+ *
+ * This code is released using a dual license strategy: BSD/GPL
+ * You can choose the licence that better fits your requirements.
+ *
+ * Released under the terms of 3-clause BSD License
+ * Released under the terms of GNU General Public License Version 2.0
+ */
+
+#ifndef _XV_MALLOC_INT_H_
+#define _XV_MALLOC_INT_H_
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+
+/* User configurable params */
+
+/* Must be power of two */
+#define XV_ALIGN_SHIFT	2
+#define XV_ALIGN	(1 << XV_ALIGN_SHIFT)
+#define XV_ALIGN_MASK	(XV_ALIGN - 1)
+
+/* This must be greater than sizeof(link_free) */
+#define XV_MIN_ALLOC_SIZE	32
+#define XV_MAX_ALLOC_SIZE	(PAGE_SIZE - XV_ALIGN)
+
+/* Free lists are separated by FL_DELTA bytes */
+#define FL_DELTA_SHIFT	3
+#define FL_DELTA	(1 << FL_DELTA_SHIFT)
+#define FL_DELTA_MASK	(FL_DELTA - 1)
+#define NUM_FREE_LISTS	((XV_MAX_ALLOC_SIZE - XV_MIN_ALLOC_SIZE) \
+				/ FL_DELTA + 1)
+
+#define MAX_FLI		DIV_ROUND_UP(NUM_FREE_LISTS, BITS_PER_LONG)
+
+/* End of user params */
+
+enum blockflags {
+	BLOCK_FREE,
+	PREV_FREE,
+	__NR_BLOCKFLAGS,
+};
+
+#define FLAGS_MASK	XV_ALIGN_MASK
+#define PREV_MASK	(~FLAGS_MASK)
+
+struct freelist_entry {
+	struct page *page;
+	u16 offset;
+	u16 pad;
+};
+
+struct link_free {
+	struct page *prev_page;
+	struct page *next_page;
+	u16 prev_offset;
+	u16 next_offset;
+};
+
+struct block_header {
+	union {
+		/* This common header must be ALIGN bytes */
+		u8 common[XV_ALIGN];
+		struct {
+			u16 size;
+			u16 prev;
+		};
+	};
+	struct link_free link;
+};
+
+struct xv_pool {
+	ulong flbitmap;
+	ulong slbitmap[MAX_FLI];
+	spinlock_t lock;
+
+	struct freelist_entry freelist[NUM_FREE_LISTS];
+
+	/* stats */
+	u64 total_pages;
+};
+
+#endif
diff -urNBb -x linux-2.6.31.9-ER1-efikamx/Documentation/dontdiff linux-2.6.31.9-ER1-efikamx.orig/drivers/usb/storage/usb.c linux-2.6.31.9-ER1-efikamx/drivers/usb/storage/usb.c
--- linux-2.6.31.9-ER1-efikamx.orig/drivers/usb/storage/usb.c	2010-01-07 14:32:40.903677529 -0600
+++ linux-2.6.31.9-ER1-efikamx/drivers/usb/storage/usb.c	2010-01-07 22:20:55.079875555 -0600
@@ -330,7 +330,10 @@
 
 		/* we've got a command, let's do it! */
 		else {
-			US_DEBUG(usb_stor_show_command(us->srb));
+			US_DEBUGP(usb_stor_show_command(us->srb));
+#ifdef CONFIG_MACH_MX51_BABBAGE
+			if (us->srb->cmnd[0] != 0x85)
+#endif
 			us->proto_handler(us->srb, us);
 		}
 
diff -urNBb -x linux-2.6.31.9-ER1-efikamx/Documentation/dontdiff linux-2.6.31.9-ER1-efikamx.orig/drivers/video/fbmem.c linux-2.6.31.9-ER1-efikamx/drivers/video/fbmem.c
--- linux-2.6.31.9-ER1-efikamx.orig/drivers/video/fbmem.c	2010-01-07 14:32:41.135824455 -0600
+++ linux-2.6.31.9-ER1-efikamx/drivers/video/fbmem.c	2010-01-24 13:36:49.000000000 -0600
@@ -35,11 +35,6 @@
 
 #include <asm/fb.h>
 
-#if defined(CONFIG_MACH_MX51_EFIKAMX)
-extern video_output;
-int mxcfb_di_clock_adjust(int hdmi_output, u32 pixel_clock);
-#endif
-
     /*
      *  Frame buffer device initialization and setup routines
      */
@@ -1047,9 +1042,6 @@
 			ret = -EFAULT;
 			break;
 		}
-#if defined(CONFIG_MACH_MX51_EFIKAMX)
-		mxcfb_di_clock_adjust(video_output, var.pixclock);
-#endif		
 		if (!lock_fb_info(info))
 			return -ENODEV;
 		acquire_console_sem();
diff -urNBb -x linux-2.6.31.9-ER1-efikamx/Documentation/dontdiff linux-2.6.31.9-ER1-efikamx.orig/drivers/video/mxc/mxcfb_sii9022.c linux-2.6.31.9-ER1-efikamx/drivers/video/mxc/mxcfb_sii9022.c
--- linux-2.6.31.9-ER1-efikamx.orig/drivers/video/mxc/mxcfb_sii9022.c	2010-01-07 19:41:20.716166071 -0600
+++ linux-2.6.31.9-ER1-efikamx/drivers/video/mxc/mxcfb_sii9022.c	2010-01-24 15:04:47.000000000 -0600
@@ -46,18 +46,26 @@
 #define DPRINTK printk
 
 struct i2c_client *sii9022_client;
+extern int video_output;
+extern int video_mode;
 extern char vmode[32];
-extern int mxcfb_di_clock_adjust(int hdmi_output, unsigned long rate);
+extern int sink_dvi;
+extern int sink_monitor;
+extern int video_max_res;
+extern u8 edid[256];
+
+
+extern void mxcfb_adjust(struct fb_var_screeninfo *var );
 extern void fb_dump_modeline( struct fb_videomode *modedb, int num);
 extern void mxcfb_update_default_var(struct fb_var_screeninfo *var, 
 									struct fb_info *info, 
 									const struct fb_videomode *def_video_mode );
-extern void mxcfb_videomode_to_modelist(const struct fb_info *info, const struct fb_videomode *modedb, int num,
-			      struct list_head *head);
-extern void mxcfb_sanitize_modelist(const struct fb_info *info, const struct fb_videomode *modedb, int num,
-			      struct list_head *head);
+extern int handle_edid2(struct i2c_adapter *adp, char *buffer, u16 len);
+
 extern int (*sii9022_func)( const char *procfs_buffer );
 
+
+
 #define HDMI_VMODE_DEFAULT	"1280x720-16@60"
 
 #define HDMI_CTL_VIDEO_ENABLE	0x01
@@ -81,6 +89,11 @@
 #define TPI_SYS_CTRL_DDC_BUS_REQUEST (1 << 2)
 #define TPI_SYS_CTRL_DDC_BUS_GRANTED (1 << 1)
 
+#define TPI_SYS_CTRL_OUTPUT_MODE_DVI	(0 << 0)
+#define TPI_SYS_CTRL_OUTPUT_MODE_HDMI	(1 << 0)
+
+#define TPI_SYS_CTRL_POWER_DOWN		(1 << 4)
+#define TPI_SYS_CTRL_POWER_ACTIVE	(0 << 4)
 
 /* Stream Header Data */
 #define HDMI_SH_PCM (0x1 << 4)
@@ -103,15 +116,16 @@
 #define EDID_SIZE_BLOCK1_TIMING_DESCRIPTOR     4
 
 int hdmi_video_init = 0;
-extern u8 edid[256];
 
 EXPORT_SYMBOL(sii9022_client);
 
 int sii9022_hdmi_video_init(struct fb_var_screeninfo *var);
 int sii9022_hdmi_audio_init(void);
 int sii9022_reinit(struct fb_var_screeninfo *var);
+
+extern void mxcfb_videomode_to_modelist(const struct fb_info *info, const struct fb_videomode *modedb, int num,
+			      struct list_head *head);
 static int sii9022_handle_edid(struct i2c_client *client, char *edid, u16 len );
-extern int handle_edid2(struct i2c_adapter *adp, char *buffer, u16 len);
 void mxc_init_fb(void);
 
 static void lcd_poweron(struct fb_info *info);
@@ -125,6 +139,8 @@
 extern int hdmi_audio;
 extern int video_output;
 
+extern struct fb_videomode mxcfb_preferred;
+
 static struct fb_videomode video_modes_ce_mode_4 = {
      /* 720p60 TV output */
      .name          = "720P60",
@@ -194,25 +210,63 @@
 	.flag		   = FB_MODE_IS_VESA,
 };
 
+#if 0
+static struct fb_videomode video_modes_1980x1080_60 = {
+	.name		   = "1980x1080@60-148Mhz",
+	.refresh	   = 60,
+	.xres		   = 1980,
+	.yres		   = 1080,
+	.pixclock	   = 6734,
+	.left_margin   = 148, 
+	.right_margin  = 88,
+	.upper_margin  = 36,   
+	.lower_margin  = 4,
+	.hsync_len	   = 44,
+	.vsync_len	   = 5,
+	.sync		   = FB_SYNC_EXT,
+	.vmode		   = FB_VMODE_NONINTERLACED,
+};
+#endif 
+
 static struct fb_var_screeninfo var;
 
-#if 0 // silence compiler warning because we don't use this right now
-static int fb_dump_var( struct device *dev, const char *func_char, struct fb_var_screeninfo *var)
+int edid_parse(u8 *edid, int *sink_monitor, int *sink_dvi)
 {
-	if ( var == NULL )	
-		return -1;
+	if (edid[126] > 0) {
+		if (edid[EDID_DESCRIPTOR_BLOCK1_ADDRESS] == 0x02) {
+			/* This block is CEA extension */
+			DPRINTK("----------------------------------------\n");
+			DPRINTK("	Revision number: %d\n", 
+						edid[EDID_DESCRIPTOR_BLOCK1_ADDRESS+1] );
+			DPRINTK("	DTV underscan: %s\n",
+						(edid[EDID_DESCRIPTOR_BLOCK1_ADDRESS+3] & 0x80 ) ?
+							"Supported" : "Not supported");
+			DPRINTK("	Basic audio: %s\n",
+						(edid[EDID_DESCRIPTOR_BLOCK1_ADDRESS+3] & 0x40 ) ?
+							"Supported" : "Not supported");
+			if ( (edid[EDID_DESCRIPTOR_BLOCK1_ADDRESS+3] & 0x40 ) ) {
+				*sink_monitor = 0;
+				*sink_dvi = 0;
+			}
+			else {
+				*sink_monitor = 1;
+				*sink_dvi = 1;
+			}
+		}			
+	}
+	else {
+		/* no CEA extension, it must be DVI */
+		*sink_monitor = 1;
+		*sink_dvi = 1;
+	}
 
-	dev_dbg( dev, "%s geometry %u %u %u %u\n", 
-	  func_char,  var->xres, var->yres, var->xres_virtual, var->yres_virtual);
-	dev_dbg( dev, "%s offset %u %u %u %u %u\n",
-	  func_char, var->xoffset, var->yoffset, var->height, var->width, var->bits_per_pixel);
-	dev_dbg( dev, "%s timings %u %u %u %u %u %u %u\n",
-	  func_char, var->pixclock, var->left_margin, var->right_margin, 
-	  var->upper_margin, var->lower_margin, var->hsync_len, var->vsync_len ); 	
-	dev_dbg( dev, "%s accel_flags %u sync %u vmode %u\n",
-	  func_char, var->accel_flags, var->sync, var->vmode );	
+	printk(KERN_INFO "	Sink device: %s, %s\n", 
+					*sink_monitor ? "Monitor" : "TV",
+					*sink_dvi ? "DVI" : "HDMI" );
+
+	return 0;
 }
-#endif 
+
 static int sii9022_handle_edid(struct i2c_client *client, char *edid, u16 len )
 {
 	int err = 0;
@@ -222,6 +276,7 @@
 	len = (len < HDMI_EDID_MAX_LENGTH) ? len : HDMI_EDID_MAX_LENGTH;
 	memset(edid, 0, len);
 
+	/* hardware reset to tx subsystem */
 	i2c_smbus_write_byte_data(sii9022_client, SI9022_REG_TPI_RQB, 0x00);
 
 	val = i2c_smbus_read_byte_data(sii9022_client, HDMI_SYS_CTRL_DATA_REG);
@@ -381,9 +436,6 @@
 
 	sii9022_hdmi_audio_ctl(0);
 
-	//TURN on TMDS 
-	i2c_smbus_write_byte_data(sii9022_client, 0x1A, 0x01);
-
 	return 0;
 }
 
@@ -443,20 +495,20 @@
 int sii9022_hdmi_video_init(struct fb_var_screeninfo *var)
 {
 	unsigned char avi_info[14] = { 0x00, 0x12, 0x28, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }; 
+	char video_mode[8] = { 0x01, 0x1d, 0x88, 0x13, 0xbc, 0x07, 0xee, 0x02 };
+	static int video_init = 0;	
 	u32 htotal = 0, vtotal=0, refresh_rate;
-	u8	cksum = 0;
+	u8	cksum = 0, dat = 0;
 	int i;
 	int vmap_idx = 0;
 	
 	if ( var == NULL )
 		return -1;
 	
-	// Power up, wakeup to D0
-	i2c_smbus_write_byte_data(sii9022_client, 0x1E, 0x00);
-
-	// Turn on TMDS
-	i2c_smbus_write_byte_data(sii9022_client, 0x1A, 0x01);
-
+	dat  = (sink_dvi ? TPI_SYS_CTRL_OUTPUT_MODE_DVI : TPI_SYS_CTRL_OUTPUT_MODE_HDMI);
+	dat |= TPI_SYS_CTRL_POWER_DOWN;
+	i2c_smbus_write_byte_data(sii9022_client, HDMI_SYS_CTRL_DATA_REG, dat);
+	msleep(128);
 
 	// back door reG0x81
 	//i2c_smbus_write_byte_data(sii9022_client, 0xBC, 0x01);
@@ -465,38 +517,32 @@
 
 	// Video Input Mode
 	i2c_smbus_write_byte_data(sii9022_client, 0x09, 0x00); 	// All 8 bit mode, Auto-selected by [1:0]; RGB
-	// Video Output Mode
-	i2c_smbus_write_byte_data(sii9022_client, 0x0A, 0x00);	//BT.601, Auto-selected by[1:0], RGB HDMI mode
+	/* Video Output Mode
+	 * 0x0A[4], 0 : BT.601  1: BT.709 
+	  * 0x0A[3:2], 00: Auto-selected, 01: Full range, 10: limited range, 11: rsvd
+	  * 0x0A[1], 00: HDMI RGB, 01: HDMI-YCbCr 4:4:4, 10: HDMI-YCbCr 4:2:2, 11: DVI RGB
+	*/
+	dat = sink_dvi ? 0x03: 0x00;	
+	i2c_smbus_write_byte_data(sii9022_client, 0x0A, dat);	
 
 	i2c_smbus_write_byte_data(sii9022_client, 0x19, 0x00);
 
-	// Turn off TMDS
-	i2c_smbus_write_byte_data(sii9022_client, 0x1A,0x10);
-
 	//video mode parameter to reg 00-07 \n ");
 
 	htotal = (var->xres+var->left_margin+var->right_margin+var->hsync_len);
 	vtotal = (var->yres+var->upper_margin+var->lower_margin+var->vsync_len);
 	refresh_rate = 1000000/(htotal*vtotal/(PICOS2KHZ(var->pixclock)/10));
 
-	i2c_smbus_write_byte_data(sii9022_client, 0x00, (PICOS2KHZ(var->pixclock)/10) & 0xFF );
-	i2c_smbus_write_byte_data(sii9022_client, 0x01, ((PICOS2KHZ(var->pixclock)/10) >> 8) & 0xFF );
-	i2c_smbus_write_byte_data(sii9022_client, 0x02, refresh_rate & 0xff);
-	i2c_smbus_write_byte_data(sii9022_client, 0x03, (refresh_rate>>8) & 0xff); // v refresh rate
-	i2c_smbus_write_byte_data(sii9022_client, 0x04, htotal & 0xff); 
-	i2c_smbus_write_byte_data(sii9022_client, 0x05, (htotal>>8) & 0xff); //total pixel
-	i2c_smbus_write_byte_data(sii9022_client, 0x06,  vtotal & 0xff);
-	i2c_smbus_write_byte_data(sii9022_client, 0x07, (vtotal>>8) & 0xff); //total line
+	video_mode[0x00] = (PICOS2KHZ(var->pixclock)/10) & 0xFF ;
+	video_mode[0x01] = ((PICOS2KHZ(var->pixclock)/10) >> 8) & 0xFF ;
+	video_mode[0x02] = refresh_rate & 0xff;
+	video_mode[0x03] = (refresh_rate>>8) & 0xff; // v refresh rate
+	video_mode[0x04] = htotal & 0xff; 
+	video_mode[0x05] = (htotal>>8) & 0xff; //total pixel
+	video_mode[0x06] = vtotal & 0xff;
+	video_mode[0x07] = (vtotal>>8) & 0xff; //total line
+	i2c_smbus_write_i2c_block_data(sii9022_client, 0x00, 8, video_mode );
 
-	dev_printk( KERN_INFO, &sii9022_client->dev, "geometry %u %u %u %u %u\n", 
-		var->xres_virtual, var->yres_virtual, var->xres, var->yres, var->bits_per_pixel);
-	dev_printk( KERN_INFO, &sii9022_client->dev, "timings %u %u %u %u %u %u %u\n",
-		var->pixclock, var->left_margin, var->right_margin, 
-		var->upper_margin, var->lower_margin, var->hsync_len, var->vsync_len );
-	dev_printk( KERN_INFO, &sii9022_client->dev, "accel %u sync %u vmode=%u\n",
-		var->accel_flags, var->sync, var->vmode );
-	dev_printk( KERN_INFO, &sii9022_client->dev, "pclk %lu refresh %u total x %u total y %u\n", 
-												((PICOS2KHZ(var->pixclock)/10)), refresh_rate, htotal,vtotal );
 #if 0
 	if (mode == 4 ) { /* ce mode 4: 1280x720@60 Hz */
 		dev_printk( KERN_INFO, &sii9022_client->dev, "1280x720@60 pclk:74.18MHz\n");
@@ -514,16 +560,14 @@
 	// burst write 720p60 AVI infoframe to Reg 0c-19 
 	//i2c_smbus_write_block_data(sii9022_client, 0x0C, 14, avi_info );
 	vmap_idx = video_mode_map_get( var->xres, var->yres, (refresh_rate / 100) );
-	cksum = 0x82 + 0x02 + 13;
+	cksum = 0x82 + 0x02 + 0x0d;
 	avi_info[2] = vmode_map[vmap_idx].aspect_ratio; //16:9 , 4:3 
 	avi_info[4] = vmode_map[vmap_idx].video_code; //video code 720p@60: 4, 720p@50: 19  
 	for( i=0; i < 14; i++ )
 		cksum += avi_info[i];
 	avi_info[0] = 0x100 - cksum;
 
-	for(i=0; i<14; i++) {
-		i2c_smbus_write_byte_data(sii9022_client, 0x0C+i, avi_info[i]);	
-	}
+	i2c_smbus_write_i2c_block_data(sii9022_client, 0x0C, 14, avi_info );
 
 	//sii9022_hdmi_audio_init();
 	dev_printk( KERN_INFO, &sii9022_client->dev, "vmap idx=%d vcode=%d\n",
@@ -531,6 +575,24 @@
 	//TURN on TMDS 
 	i2c_smbus_write_byte_data(sii9022_client, 0x1A, 0x01);               
 
+	video_init++;
+
+	dev_printk( KERN_INFO, &sii9022_client->dev, "geometry %u %u %u %u %u\n", 
+		var->xres_virtual, var->yres_virtual, var->xres, var->yres, var->bits_per_pixel);
+	dev_printk( KERN_INFO, &sii9022_client->dev, "timings %u %u %u %u %u %u %u\n",
+		var->pixclock, var->left_margin, var->right_margin, 
+		var->upper_margin, var->lower_margin, var->hsync_len, var->vsync_len );
+	dev_printk( KERN_INFO, &sii9022_client->dev, "accel %u sync %u vmode=%u\n",
+		var->accel_flags, var->sync, var->vmode );
+	dev_printk( KERN_INFO, &sii9022_client->dev, "pclk %lu refresh %u total x %u y %u\n", 
+												((PICOS2KHZ(var->pixclock)/10)), 
+												refresh_rate,
+												htotal,vtotal );
+
+	dev_printk( KERN_INFO, &sii9022_client->dev, "vmap idx=%d vcode=%d\n",
+												vmap_idx, avi_info[4] );
+
+	
 	return 0;
 }
 
@@ -574,6 +636,7 @@
 		if ( err == 0 ) {
 			struct fb_monspecs *monspecs = (struct fb_monspecs *)opt;
 
+			edid_parse(edid, &sink_monitor, &sink_dvi);
 			fb_edid_to_monspecs(edid, monspecs);
 
 			if ( monspecs->modedb_len ) {
@@ -587,12 +650,9 @@
 		return 0;
 	}
 	
-	// Power up, wakeup to D0
+	// Power up, wakeup to D0, otherwise sink will show "no signal"
 	i2c_smbus_write_byte_data(sii9022_client, 0x1E, 0x00);
 	
-	// Turn on TMDS
-	i2c_smbus_write_byte_data(sii9022_client, 0x1A, 0x01);
-
 	if( cmd & HDMI_CTL_VIDEO_ENABLE) {
 		sii9022_hdmi_video_init((struct fb_var_screeninfo *)opt);
 	}
@@ -607,8 +667,12 @@
 		sii9022_hdmi_audio_ctl(0);
 
 	//TURN on TMDS 
-	i2c_smbus_write_byte_data(sii9022_client, 0x1A, 0x01);				 
+	dat = (sink_dvi ? TPI_SYS_CTRL_OUTPUT_MODE_DVI : TPI_SYS_CTRL_OUTPUT_MODE_HDMI);
+	dat |= TPI_SYS_CTRL_POWER_ACTIVE;
+	i2c_smbus_write_byte_data(sii9022_client, HDMI_SYS_CTRL_DATA_REG, dat );
 
+	// Power up, wakeup to D0 again to take effect of 0x1A[0] sink type!
+	i2c_smbus_write_byte_data(sii9022_client, 0x1E, 0x00);
 	return 0;
 	
 }
@@ -632,23 +696,33 @@
 
 int sii9022_reinit(struct fb_var_screeninfo *var)
 {
-	int status = -1;
 	static u32 pclk = 0;
 	static u32 xres = 0, yres= 0;
 
+	if ( hdmi_video_init == 0 ) {
+		printk(KERN_INFO "skip %s!\n", __func__ );
+		return -1;
+	}
+	
+	if ( var->xres < 640 || var->yres < 480 || (var->pixclock < 8000 || var->pixclock > 40000) ) {
+		printk(KERN_INFO "reinit %ux%u %u fail!\n", 
+			var->xres, var->yres, var->pixclock );
+		return -2;
+	}
+	
 	if ( var->xres != xres || var->yres != yres || var->pixclock != pclk ) {
 
-		printk(KERN_INFO "reinit %ux%u %u\n", var->xres, var->yres, var->pixclock );
+		printk(KERN_INFO "%s %ux%u %u\n", __func__, var->xres, var->yres, var->pixclock );
 
 		xres = var->xres;
 		yres = var->yres;
 		pclk = var->pixclock;
-	}
-	else
-		return 0;
-
-	status = sii9022_hdmi_ctl( HDMI_CTL_VIDEO_ENABLE|HDMI_CTL_AUDIO_ENABLE, var );
 
+		sii9022_hdmi_ctl( HDMI_CTL_VIDEO_ENABLE|HDMI_CTL_AUDIO_ENABLE, var );
+	}
+	else {
+		printk(KERN_INFO "%s %ux%u %u same to previous one, skipping\n", __func__, var->xres, var->yres, var->pixclock );
+	}	
 	return 0;
 }
 
@@ -672,8 +746,6 @@
 		
 			mxcfb_videomode_to_modelist(info, info->monspecs.modedb, info->monspecs.modedb_len,
 							 &info->modelist);
-			mxcfb_sanitize_modelist(info, info->monspecs.modedb, info->monspecs.modedb_len,
-							 &info->modelist);
 
 		}
 	}
@@ -683,7 +755,7 @@
 	  * else find 720p timing from modelist.
 	  * modelist is generated from edid. if no edid, use modedb in modedb.c
 	  */
-#if 0
+
 	if( video_mode == 4 )
 		fb_videomode_to_var(&var, &video_modes_ce_mode_4);
 
@@ -697,11 +769,23 @@
 		fb_videomode_to_var(&var, &video_modes_1280x720_65);
 	
 	else {
-#endif
-		mxcfb_update_default_var( &var, info, &video_modes_1024x768_60 );
-//	}
+		struct fb_videomode *def_mode;
 
-	mxcfb_di_clock_adjust( video_output, var.pixclock );
+		if (video_max_res)
+			// use the monitor preferred resolution as a fallback
+			def_mode = &mxcfb_preferred;
+		else if (sink_dvi)
+			// if it's DVI, use 1024x768@60 since it's more reasonable than 1280x720 TV mode
+			def_mode = &video_modes_1024x768_60;
+		else
+			// fall back to 720p
+			def_mode = &video_modes_ce_mode_4;
+			
+		mxcfb_update_default_var( &var, info, def_mode);
+	}
+
+	hdmi_video_init = 1;
+	mxcfb_adjust( &var );
 
 	var.activate = FB_ACTIVATE_ALL;
 
@@ -789,30 +873,9 @@
 static int __devinit lcd_probe(struct device *dev)
 {
 	int i;
-//	struct mxc_lcd_platform_data *plat = dev->platform_data;
 
 	printk("*** sii9022 %s\n", __func__);
 
-#if 0 /* this never ever compiled - Neko */
-	if (plat) {
-		/*
-		io_reg = regulator_get(dev, plat->io_reg);
-		if (!IS_ERR(io_reg)) {
-			regulator_set_voltage(io_reg, 1800000);
-			regulator_enable(io_reg);
-		}
-		core_reg = regulator_get(dev, plat->core_reg);
-		if (!IS_ERR(core_reg)) {
-			regulator_set_voltage(core_reg, 1200000);
-			regulator_enable(core_reg);
-		}
-		*/
-		lcd_reset = plat->reset;
-		if (lcd_reset)
-			lcd_reset();
-	}
-#endif
-
 	for (i = 0; i < num_registered_fb; i++) {
 		if (strcmp(registered_fb[i]->fix.id, "DISP3 BG") == 0) {
 			lcd_init_fb(registered_fb[i]);
@@ -821,11 +884,6 @@
 		}
 	}
 
-	if ( sii9022_reinit(&var) < 0 ) {
-		printk("init hdmi fail!\n");
-		return -1;
-	}
-	
 	fb_register_client(&nb);
 
 	return 0;
diff -urNBb -x linux-2.6.31.9-ER1-efikamx/Documentation/dontdiff linux-2.6.31.9-ER1-efikamx.orig/drivers/video/mxc/mxc_ipuv3_fb.c linux-2.6.31.9-ER1-efikamx/drivers/video/mxc/mxc_ipuv3_fb.c
--- linux-2.6.31.9-ER1-efikamx.orig/drivers/video/mxc/mxc_ipuv3_fb.c	2010-01-07 14:32:41.146770824 -0600
+++ linux-2.6.31.9-ER1-efikamx/drivers/video/mxc/mxc_ipuv3_fb.c	2010-01-15 13:30:06.000000000 -0600
@@ -56,6 +56,7 @@
 extern int mxc_debug;
 extern int clock_auto;
 extern int extsync;
+extern void mxcfb_adjust(struct fb_var_screeninfo *var );
 
 int fb_dump_var( struct device *dev, const char *func_char, struct fb_var_screeninfo *var)
 {
@@ -143,6 +144,7 @@
 static bool g_dp_in_use;
 LIST_HEAD(fb_alloc_list);
 static struct fb_info *mxcfb_info[3];
+static int ext_clk_used;
 
 static uint32_t bpp_to_pixfmt(struct fb_info *fbi)
 {
@@ -188,8 +190,16 @@
 	fix->xpanstep = 1;
 	fix->ypanstep = 1;
 
-	if( clock_auto && extsync )
+	if( clock_auto && extsync ) {
+		if ( var->pixclock < 7500 ) { /* 133MHz */ 
+			printk(KERN_INFO "exceed pixel clock limit 7500ps, auto adjust to 800x600\n");
+			fb_find_mode( var, info, "800x600-16@60", NULL, 0, NULL, 0 );
+		}
 		var->sync |= FB_SYNC_EXT;	/* x window need it otherwise refresh rate will become bigger than user specified */
+	}
+	/* skip mxc_sdc_fb.2 (overlay) configure */
+	if ( ((struct mxcfb_info *)info->par)->ipu_ch != MEM_FG_SYNC)
+		mxcfb_adjust( var );	
 	
 	return 0;
 }
@@ -216,6 +226,8 @@
 			if (mxc_fbi_tmp->ipu_ch == MEM_BG_SYNC) {
 				fbi->var.vmode =
 				registered_fb[i]->var.vmode;
+				mxc_fbi->ipu_di_pix_fmt =
+				mxc_fbi_tmp->ipu_di_pix_fmt;
 				break;
 			}
 		}
@@ -377,7 +389,7 @@
 		}
 		if (fbi->var.vmode & FB_VMODE_ODD_FLD_FIRST) /* PAL */
 			sig_cfg.odd_field_first = true;
-		if (fbi->var.sync & FB_SYNC_EXT)
+		if ((fbi->var.sync & FB_SYNC_EXT) || ext_clk_used)
 			sig_cfg.ext_clk = true;
 		if (fbi->var.sync & FB_SYNC_HOR_HIGH_ACT)
 			sig_cfg.Hsync_pol = true;
@@ -785,7 +797,7 @@
 				break;
 			}
 
-			if (la.enable) {
+			if (la.enable && !la.alpha_in_pixel) {
 				mxc_fbi->alpha_chan_en = true;
 
 				if (mxc_fbi->ipu_ch == MEM_FG_SYNC)
@@ -1593,9 +1605,10 @@
 
 	mxcfb_check_var(&fbi->var, fbi);
 
+#if !defined(CONFIG_MACH_MX51_EFIKAMX)
 	/* Default Y virtual size is 2x panel size */
 	fbi->var.yres_virtual = fbi->var.yres * 2;
-
+#endif
 	mxcfb_set_fix(fbi);
 
 	/* alocate fb first */
@@ -1670,6 +1683,12 @@
 	while ((opt = strsep(&options, ",")) != NULL) {
 		if (!*opt)
 			continue;
+		if (!strncmp(opt, "ext_clk", 7)) {
+			ext_clk_used = true;
+			continue;
+		} else
+			ext_clk_used = false;
+
 		if (!strncmp(opt, "bpp=", 4))
 			default_bpp = simple_strtoul(opt + 4, NULL, 0);
 		else
diff -urNBb -x linux-2.6.31.9-ER1-efikamx/Documentation/dontdiff linux-2.6.31.9-ER1-efikamx.orig/drivers/video/mxc/tve.c linux-2.6.31.9-ER1-efikamx/drivers/video/mxc/tve.c
--- linux-2.6.31.9-ER1-efikamx.orig/drivers/video/mxc/tve.c	2009-12-12 13:16:53.000000000 -0600
+++ linux-2.6.31.9-ER1-efikamx/drivers/video/mxc/tve.c	2010-01-07 22:20:55.646464843 -0600
@@ -65,6 +65,7 @@
 #define TVOUT_FMT_720P60		3
 
 static int enabled;		/* enable power on or not */
+DEFINE_SPINLOCK(tve_lock);
 
 static struct fb_info *tve_fbi;
 
@@ -221,29 +222,38 @@
 {
 	u32 reg;
 	struct clk *pll3_clk;
-	unsigned long pll3_clock_rate = 216000000;
+	unsigned long pll3_clock_rate = 216000000, di1_clock_rate = 27000000;
+	struct clk *ipu_di1_clk;
+	unsigned long lock_flags;
 
 	if (tve.cur_mode == mode)
 		return 0;
 
+	spin_lock_irqsave(&tve_lock, lock_flags);
+
 	tve.cur_mode = mode;
 
 	switch (mode) {
 	case TVOUT_FMT_PAL:
 	case TVOUT_FMT_NTSC:
 		pll3_clock_rate = 216000000;
+		di1_clock_rate = 27000000;
 		break;
 	case TVOUT_FMT_720P60:
 		pll3_clock_rate = 297000000;
+		di1_clock_rate = 74250000;
 		break;
 	}
 	if (enabled)
 		clk_disable(tve.clk);
 
 	pll3_clk = clk_get(NULL, "pll3");
+	ipu_di1_clk = clk_get(NULL, "ipu_di1_clk");
+
 	clk_disable(pll3_clk);
 	clk_set_rate(pll3_clk, pll3_clock_rate);
 	clk_enable(pll3_clk);
+	clk_set_rate(ipu_di1_clk, di1_clock_rate);
 
 	clk_enable(tve.clk);
 
@@ -274,12 +284,14 @@
 		pr_debug("TVE: no such video format.\n");
 		if (!enabled)
 			clk_disable(tve.clk);
+		spin_unlock_irqrestore(&tve_lock, lock_flags);
 		return -EINVAL;
 	}
 
 	if (!enabled)
 		clk_disable(tve.clk);
 
+	spin_unlock_irqrestore(&tve_lock, lock_flags);
 	return 0;
 }
 
@@ -290,7 +302,9 @@
 static void tve_enable(void)
 {
 	u32 reg;
+	unsigned long lock_flags;
 
+	spin_lock_irqsave(&tve_lock, lock_flags);
 	if (!enabled) {
 		enabled = 1;
 		clk_enable(tve.clk);
@@ -305,6 +319,7 @@
 				tve.base + tve_regs->tve_stat_reg);
 	__raw_writel(CD_SM_INT | CD_LM_INT | CD_MON_END_INT,
 				tve.base + tve_regs->tve_int_cont_reg);
+	spin_unlock_irqrestore(&tve_lock, lock_flags);
 }
 
 /**
@@ -314,7 +329,9 @@
 static void tve_disable(void)
 {
 	u32 reg;
+	unsigned long lock_flags;
 
+	spin_lock_irqsave(&tve_lock, lock_flags);
 	if (enabled) {
 		enabled = 0;
 		reg = __raw_readl(tve.base + tve_regs->tve_com_conf_reg);
@@ -323,31 +340,50 @@
 		clk_disable(tve.clk);
 		pr_debug("TVE power off.\n");
 	}
+	spin_unlock_irqrestore(&tve_lock, lock_flags);
 }
 
 static int tve_update_detect_status(void)
 {
 	int old_detect = tve.detect;
 	u32 stat_lm, stat_sm, stat;
-	u32 int_ctl = __raw_readl(tve.base + tve_regs->tve_int_cont_reg);
-	u32 cd_cont_reg =
-		__raw_readl(tve.base + tve_regs->tve_cd_cont_reg);
+	u32 int_ctl;
+	u32 cd_cont_reg;
 	u32 timeout = 40;
+	unsigned long lock_flags;
+
+	spin_lock_irqsave(&tve_lock, lock_flags);
+
+	if (!enabled) {
+		pr_warning("Warning: update tve status while it disabled!\n");
+		tve.detect = 0;
+		goto done;
+	}
+
+	int_ctl = __raw_readl(tve.base + tve_regs->tve_int_cont_reg);
+	cd_cont_reg = __raw_readl(tve.base + tve_regs->tve_cd_cont_reg);
 
 	if ((cd_cont_reg & 0x1) == 0) {
 		pr_warning("Warning: pls enable TVE CD first!\n");
-		return tve.detect;
+		goto done;
 	}
 
 	stat = __raw_readl(tve.base + tve_regs->tve_stat_reg);
 	while (((stat & CD_MON_END_INT) == 0) && (timeout > 0)) {
+		spin_unlock_irqrestore(&tve_lock, lock_flags);
 		msleep(2);
+		spin_lock_irqsave(&tve_lock, lock_flags);
 		timeout -= 2;
+		if (!enabled) {
+			pr_warning("Warning: update tve status while it disabled!\n");
+			tve.detect = 0;
+			goto done;
+		} else
 		stat = __raw_readl(tve.base + tve_regs->tve_stat_reg);
 	}
 	if (((stat & CD_MON_END_INT) == 0) && (timeout <= 0)) {
 		pr_warning("Warning: get detect resultwithout CD_MON_END_INT!\n");
-		return tve.detect;
+		goto done;
 	}
 
 	stat = stat >> tve_reg_fields->cd_ch_stat_offset;
@@ -401,6 +437,8 @@
 
 	dev_dbg(&tve.pdev->dev, "detect = %d mode = %d\n",
 			tve.detect, tve.output_mode);
+done:
+	spin_unlock_irqrestore(&tve_lock, lock_flags);
 	return tve.detect;
 }
 
@@ -608,6 +646,7 @@
 	return rev;
 }
 
+extern int g_di1_tvout;
 static int tve_probe(struct platform_device *pdev)
 {
 	int ret, i;
@@ -615,6 +654,11 @@
 	struct tve_platform_data *plat_data = pdev->dev.platform_data;
 	u32 conf_reg;
 
+	if (!g_di1_tvout) {
+		pr_debug("TVE: DI1 was occupied by other device,TVE will not enable\n");
+		return -EBUSY;
+	}
+
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (res == NULL)
 		return -ENOMEM;
diff -urNBb -x linux-2.6.31.9-ER1-efikamx/Documentation/dontdiff linux-2.6.31.9-ER1-efikamx.orig/drivers/video/stmp37xxfb.c linux-2.6.31.9-ER1-efikamx/drivers/video/stmp37xxfb.c
--- linux-2.6.31.9-ER1-efikamx.orig/drivers/video/stmp37xxfb.c	2009-12-12 13:16:57.000000000 -0600
+++ linux-2.6.31.9-ER1-efikamx/drivers/video/stmp37xxfb.c	2010-01-07 22:20:55.732290330 -0600
@@ -25,7 +25,6 @@
 #include <linux/init.h>
 #include <linux/list.h>
 #include <linux/mutex.h>
-#include <linux/delay.h>
 #include <linux/dma-mapping.h>
 #include <linux/err.h>
 #include <linux/uaccess.h>
@@ -42,10 +41,20 @@
 
 #define NUM_SCREENS	1
 
+enum {
+	F_DISABLE = 0,
+	F_ENABLE,
+	F_REENABLE,
+	F_STARTUP,
+};
+
 struct stmp3xxx_fb_data {
 	struct fb_info info;
 	struct stmp3xxx_platform_fb_data *pdata;
-	int is_blank;
+	struct work_struct work;
+	struct mutex blank_mutex;
+	u32 state;
+	u32 task_state;
 	ssize_t mem_size;
 	ssize_t map_size;
 	dma_addr_t phys_start;
@@ -63,6 +72,122 @@
 static int stmp3xxxfb_blank(int blank, struct fb_info *info);
 static unsigned char *default_panel_name;
 static struct stmp3xxx_fb_data *cdata;
+static void init_timings(struct stmp3xxx_fb_data *data);
+
+static void stmp3xxxfb_enable_controller(struct stmp3xxx_fb_data *data)
+{
+	struct stmp3xxx_platform_fb_entry *pentry = data->pdata->cur;
+
+	if (!data || !data->pdata || !data->pdata->cur)
+		return;
+
+	stmp3xxx_init_lcdif();
+	init_timings(data);
+	pentry->init_panel(data->dev, data->phys_start,
+			data->info.fix.smem_len, data->pdata->cur);
+	pentry->run_panel();
+
+	if (pentry->blank_panel)
+		pentry->blank_panel(FB_BLANK_UNBLANK);
+}
+
+static void stmp3xxxfb_disable_controller(struct stmp3xxx_fb_data *data)
+{
+	struct stmp3xxx_platform_fb_entry *pentry = data->pdata->cur;
+
+	if (!data || !data->pdata || !data->pdata->cur)
+		return;
+
+	if (pentry->blank_panel)
+		pentry->blank_panel(FB_BLANK_POWERDOWN);
+
+	if (pentry->stop_panel)
+		pentry->stop_panel();
+	pentry->release_panel(data->dev, pentry);
+}
+
+static void set_controller_state(struct stmp3xxx_fb_data *data, u32 state)
+{
+	struct stmp3xxx_platform_fb_entry *pentry = data->pdata->cur;
+	struct fb_info *info = &data->info;
+	u32 old_state;
+
+	mutex_lock(&data->blank_mutex);
+	old_state = data->state;
+	pr_debug("%s, old_state %d, state %d\n", __func__, old_state, state);
+
+	switch (state) {
+	case F_DISABLE:
+		/*
+		 * Disable controller
+		 */
+		if (old_state != F_DISABLE) {
+			data->state = F_DISABLE;
+			stmp3xxxfb_disable_controller(data);
+		}
+		break;
+
+	case F_REENABLE:
+		/*
+		 * Re-enable the controller when panel changed.
+		 */
+		if (old_state == F_ENABLE || old_state == F_STARTUP) {
+			stmp3xxxfb_disable_controller(data);
+
+			pentry = data->pdata->cur = data->pdata->next;
+			info->fix.smem_len = pentry->y_res * pentry->x_res *
+						pentry->bpp / 8;
+			info->screen_size = info->fix.smem_len;
+			memset((void *)info->screen_base, 0, info->screen_size);
+
+			stmp3xxxfb_enable_controller(data);
+
+			data->state = F_ENABLE;
+		} else if (old_state == F_DISABLE) {
+			pentry = data->pdata->cur = data->pdata->next;
+			info->fix.smem_len = pentry->y_res * pentry->x_res *
+						pentry->bpp / 8;
+			info->screen_size = info->fix.smem_len;
+			memset((void *)info->screen_base, 0, info->screen_size);
+
+			data->state = F_DISABLE;
+		}
+		break;
+
+	case F_ENABLE:
+		if (old_state != F_ENABLE) {
+			data->state = F_ENABLE;
+			stmp3xxxfb_enable_controller(data);
+		}
+		break;
+	}
+	mutex_unlock(&data->blank_mutex);
+
+}
+
+static void stmp3xxxfb_task(struct work_struct *work)
+{
+	struct stmp3xxx_fb_data *data =
+			container_of(work, struct stmp3xxx_fb_data, work);
+
+	u32 state = xchg(&data->task_state, -1);
+	pr_debug("%s: state = %d, data->task_state = %d\n",
+				__func__, state, data->task_state);
+
+	set_controller_state(data, state);
+}
+
+static void stmp3xxx_schedule_work(struct stmp3xxx_fb_data *data, u32 state)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+
+	data->task_state = state;
+	schedule_work(&data->work);
+
+	local_irq_restore(flags);
+}
 
 static irqreturn_t lcd_irq_handler(int irq, void *dev_id)
 {
@@ -295,23 +420,10 @@
 	if (pentry == pdata->cur || !pdata->cur)
 		return 0;
 
-	/* release prev panel */
-	stmp3xxxfb_blank(FB_BLANK_POWERDOWN, &data->info);
-	if (pdata->cur->stop_panel)
-		pdata->cur->stop_panel();
-	pdata->cur->release_panel(data->dev, pdata->cur);
-
-	info->fix.smem_len = pentry->y_res * pentry->x_res * pentry->bpp / 8;
-	info->screen_size = info->fix.smem_len;
-	memset((void *)info->screen_base, 0, info->screen_size);
-
 	/* init next panel */
-	pdata->cur = pentry;
-	stmp3xxx_init_lcdif();
-	pentry->init_panel(data->dev, data->phys_start, info->fix.smem_len,
-			   pentry);
-	pentry->run_panel();
-	stmp3xxxfb_blank(FB_BLANK_UNBLANK, &data->info);
+	pdata->next = pentry;
+
+	set_controller_state(data, F_REENABLE);
 
 	return 0;
 }
@@ -441,11 +553,25 @@
 static int stmp3xxxfb_blank(int blank, struct fb_info *info)
 {
 	struct stmp3xxx_fb_data *data = (struct stmp3xxx_fb_data *)info;
-	int ret = data->pdata->cur->blank_panel ?
-		data->pdata->cur->blank_panel(blank) :
-		-ENOTSUPP;
-	if (ret == 0)
-		data->is_blank = (blank != FB_BLANK_UNBLANK);
+	int ret = 0;
+
+	switch (blank) {
+	case FB_BLANK_NORMAL:
+	case FB_BLANK_VSYNC_SUSPEND:
+	case FB_BLANK_HSYNC_SUSPEND:
+	case FB_BLANK_POWERDOWN:
+		pr_debug("%s: FB_BLANK_POWERDOWN\n", __func__);
+		stmp3xxx_schedule_work(data, F_DISABLE);
+		break;
+
+	case FB_BLANK_UNBLANK:
+		pr_debug("%s: FB_BLANK_UNBLANK\n", __func__);
+		stmp3xxx_schedule_work(data, F_ENABLE);
+		break;
+
+	default:
+		ret = -EINVAL;
+	}
 	return ret;
 }
 
@@ -519,14 +645,24 @@
 	struct stmp3xxxfb_notifier_block *block =
 		container_of(self, struct stmp3xxxfb_notifier_block, nb);
 	struct stmp3xxx_fb_data *data = block->fb_data;
+	struct stmp3xxx_platform_fb_entry *pentry = data->pdata->cur;
+	u32 old_state = data->state;
+
+	if (!data || !data->pdata || !data->pdata->cur)
+		return NOTIFY_BAD;
 
+	/* REVISIT */
 	switch (phase) {
-	case CPUFREQ_POSTCHANGE:
-		stmp3xxxfb_blank(FB_BLANK_UNBLANK, &data->info);
+	case CPUFREQ_PRECHANGE:
+		if (old_state == F_ENABLE || old_state == F_STARTUP)
+			if (pentry->blank_panel)
+				pentry->blank_panel(FB_BLANK_POWERDOWN);
 		break;
 
-	case CPUFREQ_PRECHANGE:
-		stmp3xxxfb_blank(FB_BLANK_POWERDOWN, &data->info);
+	case CPUFREQ_POSTCHANGE:
+		if (old_state == F_ENABLE || old_state == F_STARTUP)
+			if (pentry->blank_panel)
+				pentry->blank_panel(FB_BLANK_UNBLANK);
 		break;
 
 	default:
@@ -618,6 +754,9 @@
 	}
 	dev_dbg(&pdev->dev, "allocated at %p:0x%x\n", data->virt_start,
 		data->phys_start);
+	mutex_init(&data->blank_mutex);
+	INIT_WORK(&data->work, stmp3xxxfb_task);
+	data->state = F_STARTUP;
 
 	stmp3xxxfb_default.bits_per_pixel = pentry->bpp;
 	/* NB: rotated */
@@ -750,13 +889,8 @@
 static int stmp3xxxfb_remove(struct platform_device *pdev)
 {
 	struct stmp3xxx_fb_data *data = platform_get_drvdata(pdev);
-	struct stmp3xxx_platform_fb_data *pdata = pdev->dev.platform_data;
-	struct stmp3xxx_platform_fb_entry *pentry = pdata->cur;
 
-	stmp3xxxfb_blank(FB_BLANK_POWERDOWN, &data->info);
-	if (pentry->stop_panel)
-		pentry->stop_panel();
-	pentry->release_panel(&pdev->dev, pentry);
+	set_controller_state(data, F_DISABLE);
 
 	unregister_framebuffer(&data->info);
 	framebuffer_release(&data->info);
@@ -774,33 +908,17 @@
 static int stmp3xxxfb_suspend(struct platform_device *pdev, pm_message_t state)
 {
 	struct stmp3xxx_fb_data *data = platform_get_drvdata(pdev);
-	struct stmp3xxx_platform_fb_data *pdata = pdev->dev.platform_data;
-	struct stmp3xxx_platform_fb_entry *pentry = pdata->cur;
-	int ret;
 
-	ret = stmp3xxxfb_blank(FB_BLANK_POWERDOWN, &data->info);
-	if (ret)
-		goto out;
-	if (pentry->stop_panel)
-		pentry->stop_panel();
-	pentry->release_panel(data->dev, pentry);
+	set_controller_state(data, F_DISABLE);
 
-out:
-	return ret;
+	return 0;
 }
 
 static int stmp3xxxfb_resume(struct platform_device *pdev)
 {
 	struct stmp3xxx_fb_data *data = platform_get_drvdata(pdev);
-	struct stmp3xxx_platform_fb_data *pdata = pdev->dev.platform_data;
-	struct stmp3xxx_platform_fb_entry *pentry = pdata->cur;
 
-	stmp3xxx_init_lcdif();
-	init_timings(data);
-	pentry->init_panel(data->dev, data->phys_start, data->info.fix.smem_len,
-			   pentry);
-	pentry->run_panel();
-	stmp3xxxfb_blank(FB_BLANK_UNBLANK, &data->info);
+	set_controller_state(data, F_ENABLE);
 	return 0;
 }
 #else
diff -urNBb -x linux-2.6.31.9-ER1-efikamx/Documentation/dontdiff linux-2.6.31.9-ER1-efikamx.orig/fs/drop_caches.c linux-2.6.31.9-ER1-efikamx/fs/drop_caches.c
--- linux-2.6.31.9-ER1-efikamx.orig/fs/drop_caches.c	2009-09-09 17:13:59.000000000 -0500
+++ linux-2.6.31.9-ER1-efikamx/fs/drop_caches.c	2010-01-15 12:58:31.000000000 -0600
@@ -74,3 +74,15 @@
 	}
 	return 0;
 }
+
+
+#ifdef CONFIG_MACH_MX51_EFIKAMX
+extern asmlinkage long sys_sync(void);
+
+void mx51_efikamx_drop_caches(void)
+{
+	sys_sync();
+	drop_pagecache();
+	drop_slab(); 
+}
+#endif
\ No newline at end of file
diff -urNBb -x linux-2.6.31.9-ER1-efikamx/Documentation/dontdiff linux-2.6.31.9-ER1-efikamx.orig/include/linux/ipu.h linux-2.6.31.9-ER1-efikamx/include/linux/ipu.h
--- linux-2.6.31.9-ER1-efikamx.orig/include/linux/ipu.h	2009-12-12 13:16:57.000000000 -0600
+++ linux-2.6.31.9-ER1-efikamx/include/linux/ipu.h	2010-01-07 22:20:55.475569113 -0600
@@ -321,6 +321,7 @@
 		uint32_t out_width;
 		uint32_t out_height;
 		uint32_t out_pixel_fmt;
+		uint32_t out_resize_ratio;
 	} mem_prp_enc_mem;
 	struct {
 		uint32_t in_width;
@@ -363,6 +364,7 @@
 		uint32_t out_width;
 		uint32_t out_height;
 		uint32_t out_pixel_fmt;
+		uint32_t out_resize_ratio;
 		bool graphics_combine_en;
 		bool global_alpha_en;
 		bool key_color_en;
@@ -386,6 +388,7 @@
 		uint32_t out_width;
 		uint32_t out_height;
 		uint32_t out_pixel_fmt;
+		uint32_t out_resize_ratio;
 		bool graphics_combine_en;
 		bool global_alpha_en;
 		bool key_color_en;
@@ -393,7 +396,6 @@
 		uint8_t alpha;
 		uint32_t key_color;
 		bool alpha_chan_en;
-		uint32_t out_resize_ratio;
 	} mem_pp_mem;
 	struct {
 		uint32_t temp;
@@ -1013,6 +1015,30 @@
 int ipu_register_generic_isr(int irq, void *dev);
 void ipu_close(void);
 
+/* two stripe calculations */
+struct stripe_param{
+	unsigned int input_width; /* width of the input stripe */
+	unsigned int output_width; /* width of the output stripe */
+	unsigned int input_column; /* the first column on the input stripe */
+	unsigned int output_column; /* the first column on the output stripe */
+	unsigned int idr;
+	/* inverse downisizing ratio parameter; expressed as a power of 2 */
+	unsigned int irr;
+	/* inverse resizing ratio parameter; expressed as a multiple of 2^-13 */
+};
+
+typedef struct _ipu_stripe_parm {
+	unsigned int input_width;
+	unsigned int output_width;
+	unsigned int maximal_stripe_width;
+	unsigned long long cirr;
+	unsigned int equal_stripes;
+	u32 input_pixelformat;
+	u32 output_pixelformat;
+	struct stripe_param left;
+	struct stripe_param right;
+} ipu_stripe_parm;
+
 typedef struct _ipu_channel_parm {
 	ipu_channel_t channel;
 	ipu_channel_params_t params;
@@ -1034,6 +1060,19 @@
 	uint32_t bufNum;
 } ipu_channel_buf_parm;
 
+typedef struct _ipu_buf_offset_parm {
+	ipu_channel_t channel;
+	ipu_buffer_t type;
+	uint32_t pixel_fmt;
+	uint16_t width;
+	uint16_t height;
+	uint16_t stride;
+	uint32_t u_offset;
+	uint32_t v_offset;
+	uint32_t vertical_offset;
+	uint32_t horizontal_offset;
+} ipu_buf_offset_parm;
+
 typedef struct _ipu_channel_link {
 	ipu_channel_t src_ch;
 	ipu_channel_t dest_ch;
@@ -1207,22 +1246,8 @@
 #define IPU_ALOC_MEM		      _IOWR('I', 0x24, ipu_mem_info)
 #define IPU_FREE_MEM		      _IOW('I', 0x25, ipu_mem_info)
 #define IPU_IS_CHAN_BUSY	      _IOW('I', 0x26, ipu_channel_t)
-
-
-/* two stripe calculations */
-struct stripe_param{
-	unsigned int input_width; /* width of the input stripe */
-	unsigned int output_width; /* width of the output stripe */
-	unsigned int input_column; /* the first column on the input stripe */
-	unsigned int output_column; /* the first column on the output stripe */
-	unsigned int idr;
-	/* inverse downisizing ratio parameter; expressed as a power of 2 */
-	unsigned int irr;
-	/* inverse resizing ratio parameter; expressed as a multiple of 2^-13 */
-};
-
-
-
+#define IPU_CALC_STRIPES_SIZE	      _IOWR('I', 0x27, ipu_stripe_parm)
+#define IPU_UPDATE_BUF_OFFSET     _IOW('I', 0x28, ipu_buf_offset_parm)
 
 int ipu_calc_stripes_sizes(const unsigned int input_frame_width,
 				unsigned int output_frame_width,
diff -urNBb -x linux-2.6.31.9-ER1-efikamx/Documentation/dontdiff linux-2.6.31.9-ER1-efikamx.orig/include/linux/mxcfb.h linux-2.6.31.9-ER1-efikamx/include/linux/mxcfb.h
--- linux-2.6.31.9-ER1-efikamx.orig/include/linux/mxcfb.h	2009-12-12 13:16:57.000000000 -0600
+++ linux-2.6.31.9-ER1-efikamx/include/linux/mxcfb.h	2010-01-07 22:20:55.670000570 -0600
@@ -37,6 +37,7 @@
 
 struct mxcfb_loc_alpha {
 	int enable;
+	int alpha_in_pixel;
 	unsigned long alpha_phy_addr0;
 	unsigned long alpha_phy_addr1;
 };
diff -urNBb -x linux-2.6.31.9-ER1-efikamx/Documentation/dontdiff linux-2.6.31.9-ER1-efikamx.orig/sound/soc/codecs/stmp378x_codec.c linux-2.6.31.9-ER1-efikamx/sound/soc/codecs/stmp378x_codec.c
--- linux-2.6.31.9-ER1-efikamx.orig/sound/soc/codecs/stmp378x_codec.c	2009-12-12 13:16:57.000000000 -0600
+++ linux-2.6.31.9-ER1-efikamx/sound/soc/codecs/stmp378x_codec.c	2010-01-07 22:20:55.599291886 -0600
@@ -70,15 +70,15 @@
 	REGS_AUDIOOUT_BASE + HW_AUDIOOUT_DATA,
 	REGS_AUDIOOUT_BASE + HW_AUDIOOUT_SPEAKERCTRL,
 	REGS_AUDIOOUT_BASE + HW_AUDIOOUT_VERSION,
-	REGS_AUDIOOUT_BASE + HW_AUDIOIN_CTRL,
-	REGS_AUDIOOUT_BASE + HW_AUDIOIN_STAT,
-	REGS_AUDIOOUT_BASE + HW_AUDIOIN_ADCSRR,
-	REGS_AUDIOOUT_BASE + HW_AUDIOIN_ADCVOLUME,
-	REGS_AUDIOOUT_BASE + HW_AUDIOIN_ADCDEBUG,
-	REGS_AUDIOOUT_BASE + HW_AUDIOIN_ADCVOL,
-	REGS_AUDIOOUT_BASE + HW_AUDIOIN_MICLINE,
-	REGS_AUDIOOUT_BASE + HW_AUDIOIN_ANACLKCTRL,
-	REGS_AUDIOOUT_BASE + HW_AUDIOIN_DATA,
+	REGS_AUDIOIN_BASE + HW_AUDIOIN_CTRL,
+	REGS_AUDIOIN_BASE + HW_AUDIOIN_STAT,
+	REGS_AUDIOIN_BASE + HW_AUDIOIN_ADCSRR,
+	REGS_AUDIOIN_BASE + HW_AUDIOIN_ADCVOLUME,
+	REGS_AUDIOIN_BASE + HW_AUDIOIN_ADCDEBUG,
+	REGS_AUDIOIN_BASE + HW_AUDIOIN_ADCVOL,
+	REGS_AUDIOIN_BASE + HW_AUDIOIN_MICLINE,
+	REGS_AUDIOIN_BASE + HW_AUDIOIN_ANACLKCTRL,
+	REGS_AUDIOIN_BASE + HW_AUDIOIN_DATA,
 };
 
 static u16 stmp378x_audio_regs[ADC_REGNUM];
diff -urNBb -x linux-2.6.31.9-ER1-efikamx/Documentation/dontdiff linux-2.6.31.9-ER1-efikamx.orig/sound/soc/imx/imx-3stack-bt.c linux-2.6.31.9-ER1-efikamx/sound/soc/imx/imx-3stack-bt.c
--- linux-2.6.31.9-ER1-efikamx.orig/sound/soc/imx/imx-3stack-bt.c	2009-12-12 13:16:54.000000000 -0600
+++ linux-2.6.31.9-ER1-efikamx/sound/soc/imx/imx-3stack-bt.c	2010-01-07 22:20:54.718700581 -0600
@@ -191,6 +191,7 @@
 	else
 		bt_cpu_dai = &imx_ssi_dai[2];
 
+	bt_cpu_dai->dev = &pdev->dev;
 	imx_3stack_dai.cpu_dai = bt_cpu_dai;
 
 	/* Configure audio port */
diff -urNBb -x linux-2.6.31.9-ER1-efikamx/Documentation/dontdiff linux-2.6.31.9-ER1-efikamx.orig/sound/soc/imx/imx-pcm.c linux-2.6.31.9-ER1-efikamx/sound/soc/imx/imx-pcm.c
--- linux-2.6.31.9-ER1-efikamx.orig/sound/soc/imx/imx-pcm.c	2009-12-12 13:16:53.000000000 -0600
+++ linux-2.6.31.9-ER1-efikamx/sound/soc/imx/imx-pcm.c	2010-01-07 22:20:54.721616680 -0600
@@ -542,7 +542,7 @@
 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
 	struct snd_soc_device *socdev = rtd->socdev;
 	struct snd_soc_dai *cpu_dai = socdev->card->dai_link->cpu_dai;
-	struct mxc_audio_platform_data *dev_data = cpu_dai->private_data;
+	struct mxc_audio_platform_data *dev_data;
 	int ext_ram = 0;
 	int ret = 0;
 
@@ -551,8 +551,10 @@
 	    UseIram, (unsigned int)runtime->dma_addr,
 	    runtime->dma_area, runtime->dma_bytes);
 
-	if (dev_data)
+	if (cpu_dai->dev && cpu_dai->dev->platform_data) {
+		dev_data = cpu_dai->dev->platform_data;
 		ext_ram = dev_data->ext_ram;
+	}
 
 	if ((substream->stream == SNDRV_PCM_STREAM_CAPTURE)
 	    || ext_ram || !UseIram) {
@@ -586,12 +588,14 @@
 	struct snd_soc_pcm_runtime *rtd = pcm->private_data;
 	struct snd_soc_device *socdev = rtd->socdev;
 	struct snd_soc_dai *cpu_dai = socdev->card->dai_link->cpu_dai;
-	struct mxc_audio_platform_data *dev_data = cpu_dai->private_data;
+	struct mxc_audio_platform_data *dev_data;
 	int ext_ram = 0;
 	size_t size = imx_pcm_hardware.buffer_bytes_max;
 
-	if (dev_data)
+	if (cpu_dai->dev && cpu_dai->dev->platform_data) {
+		dev_data = cpu_dai->dev->platform_data;
 		ext_ram = dev_data->ext_ram;
+	}
 
 	buf->dev.type = SNDRV_DMA_TYPE_DEV;
 	buf->dev.dev = pcm->card->dev;
@@ -620,12 +624,14 @@
 	struct snd_soc_pcm_runtime *rtd = pcm->private_data;
 	struct snd_soc_device *socdev = rtd->socdev;
 	struct snd_soc_dai *cpu_dai = socdev->card->dai_link->cpu_dai;
-	struct mxc_audio_platform_data *dev_data = cpu_dai->private_data;
+	struct mxc_audio_platform_data *dev_data;
 	int ext_ram = 0;
 	int stream;
 
-	if (dev_data)
+	if (cpu_dai->dev && cpu_dai->dev->platform_data) {
+		dev_data = cpu_dai->dev->platform_data;
 		ext_ram = dev_data->ext_ram;
+	}
 
 	for (stream = 0; stream < 2; stream++) {
 		substream = pcm->streams[stream].substream;
